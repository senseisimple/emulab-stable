#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2010-2011 University of Utah and the Flux Group.
# All rights reserved.
#
use strict;
use English;
use Getopt::Std;
use Data::Dumper;

#
# Update DB.
#
sub usage()
{
    print STDERR "Usage: update-testbed\n";
    print STDERR "-v     - Verify install scripts by loading them only\n";
    print STDERR "-n     - Run install script in impotent mode\n";
    print STDERR "-d     - Debugging mode\n";
    print STDERR "-i     - Run 'gmake boss-install' after running scripts\n";
    print STDERR "-s     - Stop/Restart the testbed before/after running scripts\n";
    exit(-1);
}
my $optlist   = "idsvfn";
my $debug     = 0;
my $force     = 0;
my $verify    = 0;
my $install   = 0;
my $stopbed   = 0;
my $stopped   = 0;
my $nologins  = 0;
my $committed = 0;
my $impotent  = 0;
my $forceopt  = "";

#
# Configure variables
#
my $TB	         = "@prefix@";
my $TBOPS        = "@TBOPSEMAIL@";
my $DBNAME       = "@TBDBNAME@";
my $SRCDIR       = "@top_srcdir@";
my $SQLUPDATEDIR = "$SRCDIR/sql/updates";
my $PGENIUPDATEDIR = "$SRCDIR/protogeni/updates";
my $UPDATEDIR    = "$SRCDIR/install/updates";
my $DBUPDATE     = "$TB/sbin/dbupdate";
my $PGENIUPDATE  = "$TB/sbin/protogeni/update";
my $PGENISUPPORT = @PROTOGENI_SUPPORT@;
my $INSTALLUPDATE= "$TB/sbin/update-install";
my $SETSITEVAR   = "$TB/sbin/setsitevar";
my $STARTUP      = "/usr/local/etc/rc.d/3.testbed.sh";
my $FRISBEE      = "$TB/sbin/frisbeelauncher";
my $tempfile     = "/var/tmp/update.$$";

# Protos
sub Fatal($);
sub CheckForReboot();

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# We want to force this to run from the build tree to avoid any
# problems with the install tree not being in a consistent state.
#
BEGIN
{
    if (-e "../Makeconf") {
	my $srcdir = "@top_srcdir@";
	my $objdir = `/bin/pwd`;
	chomp($objdir);
	# Prior to first install or running from object dir.
	unshift(@INC, "$objdir/../db");
	if ($srcdir =~ /^\//) {
	    unshift(@INC, "$srcdir/install");
	    unshift(@INC, "$srcdir/tbsetup");
	} else {
	    unshift(@INC, "$objdir/$srcdir/install");
	    unshift(@INC, "$objdir/$srcdir/tbsetup");
	}
	unshift(@INC, "$objdir/../tbsetup");
    }
}
use emdb;
use libEmulab;
use libtestbed;
use Image;

#
# Parse command arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $force = 1;
    $forceopt = "-f";
}
if (defined($options{"i"})) {
    $install = 1;
}
if (defined($options{"v"})) {
    $verify = 1;
}
if (defined($options{"s"})) {
    $stopbed = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}

#
# Must be root if actually doing this.
#
if (!($verify || $impotent) && $UID) {
    Fatal("This script must be run as root! Maybe use sudo?")
}

if (! (-e "../db/dbupdate" && -e "./update-install")) {
    Fatal("Cannot find dbupdate script! Running from the object dir?");
}

my $objdir = `/bin/pwd`;
chomp($objdir);

my $abssrcdir;
if ($SRCDIR =~ /^\//) {
    $abssrcdir = "$SRCDIR";
} else {
    $abssrcdir = "$objdir/$SRCDIR";
}

my @INCDIRS = ("-I${objdir}", "-I${objdir}/../tbsetup",
	       "-I${objdir}/../db", "-I${objdir}/../event/lib", 
	       "-I${abssrcdir}/tbsetup",
	       "-I${abssrcdir}/install",
	       # To catch a few extra things that do not normally change.
	       "-I@prefix@/lib"
	       );

# Chicken or Egg.
# XXX only set specific fields as the ns_include field may not be there yet.
DBQueryFatal("INSERT INTO sitevariables (name,value,defaultvalue,description)".
	     " VALUES ".
	     " ('general/testbed_shutdown',NULL,'0', ".
	     "  'Non-zero value indicates that the testbed is shutdown ".
	     "and scripts should not do anything when they run. ".
	     "DO NOT SET THIS BY HAND!')")
    if (!SiteVarExists("general/testbed_shutdown"));

#
# Dump the testbed version numbers in all modes.
#
print "Testbed version info:\n";
system("perl @INCDIRS ./testbed-version");

#
# Impotent mode, just runs the install scripts. 
#
if ($impotent) {
    system("perl @INCDIRS ./update-install -n -p $UPDATEDIR");
    if ($?) {
	exit(1);
    }
    CheckForReboot();
    exit(0);
}

#
# In verify mode, just run the update scripts in verify.
#
if ($verify) {
    my $exitval = 0;
    
    print "Checking for DB updates ...\n";
    system("perl @INCDIRS ../db/dbupdate -q -v -p $SQLUPDATEDIR $DBNAME");
    $exitval++
	if ($?);
    
    print "Checking for install updates ...\n";
    system("perl @INCDIRS ./update-install -q -v -p $UPDATEDIR");
    $exitval++
	if ($?);

    if ($PGENISUPPORT) {
	print "Checking for ProtoGENI DB updates ...\n";
	system("perl @INCDIRS ../protogeni/scripts/update ".
	       "       -q -v -p $PGENIUPDATEDIR");
	$exitval++
	    if ($?);
    }

    exit(0)
	if (!$exitval);

    print "*** You have update scripts that have not been run.\n";
    print "    As a safety measure, you will not be able to install until\n";
    print "    this is resolved. Typically, you can resolve this by:\n\n";
    print "        boss> cd /your/object/dir\n";
    print "        boss> gmake update-testbed\n\n";
    print "    More information is available at:\n";
    print "       https://users.emulab.net/trac/emulab/wiki/install/update-testbed-v2\n\n";
    exit($exitval);
}

#
# Cleanup handler when stopping the testbed.
#
sub Restart()
{
    if ($committed) {
	print "*** Update has progressed too far; you must renable by hand\n";
	return;
    }
    if ($stopped) {
	print "Starting up testbed daemons.\n";
	system("$STARTUP start");
	if ($?) {
	    print "*** Could not restart testbed daemons.\n";
	    exit(1);
	}
	print "\n";
    }
    if ($nologins) {
	print "Turning on the web interface and allowing swaps\n";
	if (system("$SETSITEVAR general/testbed_shutdown -") ||
	    system("$SETSITEVAR web/nologins -") ||
	    system("$SETSITEVAR web/message -")) {
	    print "*** Could not renable the web interface and swapping!\n";
	    exit(1);
	}
    }
}

sub Handler()
{
    Restart();
    exit(1);
}

if ($stopbed) {
    $SIG{INT} = \&Handler;
    
    #
    # Stop the testbed before doing the update.
    #
    print "** Putting the testbed to sleep before updating ...\n";
    print "-> Turning off the web interface and disallowing swaps.\n";

    my $msg = "Testbed software update in progress; back in a little while";
    $msg =~ s|\&|&amp;|g;
    $msg =~ s|\<|&lt;|g;
    system("$SETSITEVAR","web/message", $msg);
    if ($?) {
	Fatal("Could not update web message");
    }
    system("$SETSITEVAR web/nologins 1");
    if ($?) {
	Fatal("Could not disable web logins and experiment swaps");
    }
    system("$SETSITEVAR general/testbed_shutdown 1");
    if ($?) {
	Fatal("Could not set general/testbed_shutdown");
    }
    $nologins = 1;
    
    print "-> Waiting a few seconds for testbed to quiet down ...\n";
    sleep(5);
    print "-> Looking for experiments still in transition.\n";

    #
    # Look for any experiments in transition, and wait for them to stop.
    # This could take an arbitrarily long time of course, but its the only
    # safe way to do it. Don't worry about any experiments that are older
    # then 24 hours though; they are likely stuck and not going anywhere.
    #
    while (1) {
	my $query_result =
	    emdb::DBQueryWarn("select pid,eid,idx,state,expt_locked ".
			"   from experiments ".
			"where expt_locked is not null and ".
			"      DATE_SUB(NOW(),INTERVAL 1 DAY) <= expt_locked");
	if (!$query_result) {
	    Fatal("Error getting info from the DB. Stopping.");
	}
	last
	    if (!$query_result->numrows());

	print "-> Experiments still in transition:\n";
	while (my ($pid,$eid,$idx,$state,$expt_locked) =
	       $query_result->fetchrow_array()) {

	    print "  $pid,$eid,$idx -- $state, $expt_locked\n";
	}
	print "-> Waiting 30 seconds before trying again. ^C is okay\n\n";
	sleep(30);
    }
    print "** Testbed is quiet; stopping testbed daemons ... \n";
    system("$STARTUP stop >/dev/null 2>&1");
    if ($?) {
	Fatal("Could not stop testbed daemons. Stopping.");
    }
    $stopped = 1;

    #
    # XXX cannot just call Image->ActiveImages as the implementation
    # changed and thus the code would not work when upgrading from a
    # code base with the old implementation to one with the new.
    #
    my $table = "images";
    if (!emdb::DBSlotExists("images", "frisbee_pid")) {
	$table = "frisbee_blobs";
    }
    my $query_result =
      emdb::DBQueryWarn("select imageid from $table where frisbee_pid!=0");
    my @activeimages = ();
    if ($query_result) {
	while (my ($imageid) = $query_result->fetchrow_array()) {
	    my $image = Image->Lookup($imageid);
	    if (!defined($image)) {
		print STDERR
		    "*** Could not find DB object for image $imageid\n";
		next;
	    }
	    push(@activeimages, $image);
	}
    }
    if (@activeimages > 0) {
	print "** Stopping running frisbee processes ...\n";
	foreach my $image (@activeimages) {
	    my $imageid = $image->imageid();
	    print "-> Killing frisbee for $image ...\n";
	    system("$FRISBEE -k $imageid");
	    if ($?) {
		Fatal("Could not stop frisbee for $image!");
	    }
	}
    }
    
    print "** Testbed is stopped. Proceeding to update\n";

    #
    # No going back; we do not want to re-enable the testbed if things fail
    # from this point on.
    #
    $committed = 1;
}

print "Running DB updates ...\n";
system("perl @INCDIRS ../db/dbupdate -q -p $SQLUPDATEDIR $DBNAME");
exit(1)
    if ($?);
    
print "Running pre-install updates ...\n";
system("perl @INCDIRS ./update-install $forceopt -q -a pre -p $UPDATEDIR");
exit(1)
    if ($?);

if ($PGENISUPPORT) {
    print "Running ProtoGENI DB updates ...\n";
    system("perl @INCDIRS ../protogeni/scripts/update ".
	   "       -q -p $PGENIUPDATEDIR");
    exit(1)
	if ($?);
}

if ($install) {
    print "Installing testbed software ... this will take a while!\n";
    print "Output saved to $tempfile\n";
    
    system("(cd ..; gmake; gmake boss-install-noupdatecheck) >$tempfile 2>&1");
    if ($?) {
	exit(1);
    }
}

print "Running post-install updates ...\n";
system("perl @INCDIRS ./update-install $forceopt -q -a post -p $UPDATEDIR");
exit(1)
    if ($?);

if (CheckForReboot()) {
    exit(0);
}
# So we can turn the testbed back on.
elsif ($stopbed) {
    $committed = 0;
    Restart();
}
exit(0);

sub Fatal($)
{
    my ($msg) = @_;

    Restart();
    die("*** $0:\n".
	"    $msg\n");
}

#
# See if a reboot is needed. Typically not, but sometimes it might.
#
sub CheckForReboot()
{
    my $reboot_query =
	emdb::DBQueryWarn("select value from version_info ".
			  "where name='needreboot'");
    if ($reboot_query->numrows) {
	my ($needreboot) = $reboot_query->fetchrow_array();
	if ($needreboot) {
	    print "********************************************************\n";
	    print "*\n";
	    if ($impotent) {
		print "* THESE UPDATES WILL REQUIRE BOSS REBOOT!\n";
	    }
	    else {
		print "* YOU MUST NOW REBOOT BOSS!\n";
	    }
	    print "*\n";
	    print "********************************************************\n";
	    return 1;
	}
    }
    return 0;
}
