#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004, 2005, 2006, 2007 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

sub usage()
{
    print "Usage: " .
	scriptname() . " [-j vnodeid] boot|shutdown|reconfig|reset\n";
    exit(1);
}
my $optlist = "j:";
my $action  = "boot";

# Turn off line buffering on output
$| = 1;

# Drag in path stuff so we can find emulab stuff.
BEGIN { require "/etc/emulab/paths.pm"; import emulabpaths; }

#
# Load the OS independent support library. It will load the OS dependent
# library and initialize itself. 
# 
use libsetup;
use libtmcc;
use librc;

# Only root.
# XXX on Windows we let non-root run this since linktest does not run as root.
if ($EUID != 0 && !WINDOWS()) {
    die("*** $0:\n".
	"    Must be root to run this script!\n");
}

#
# Not all clients support this.
#
exit(0)
    if (MFS() || (REMOTE() && !(PLAB() || JAILED())));

# Protos.
sub doboot($);
sub doshutdown();
sub doreconfig();
sub docleanup();

# Parse command line.
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{'j'})) {
    my $vnodeid = $options{'j'};
    libsetup_setvnodeid($vnodeid);
}
# Allow default above.
if (@ARGV) {
    $action = $ARGV[0];
}

# Execute the action.
SWITCH: for ($action) {
    /^boot$/i && do {
	doboot(0);
	last SWITCH;
    };
    /^shutdown$/i && do {
	doshutdown();
	last SWITCH;
    };
    /^reconfig$/i && do {
	doreconfig();
	last SWITCH;
    };
    /^reset$/i && do {
	docleanup();
	last SWITCH;
    };
    fatal("Invalid action: $action\n");
}
exit(0);

# More protos
sub dotopomap();

#
# Boot Action.
#
sub doboot($)
{
    my ($allowjails) = @_;

    # Handled elsewhere for other node types.
    dotopomap()
	if (!PLAB() && ($allowjails || !JAILED()) && !IXP());
}

#
# Shutdown Action.
#
sub doshutdown()
{
    # Nothing to do
}

#
# Node Reconfig Action (without rebooting).
#
sub doreconfig()
{
    doshutdown();
    return doboot(1);
}

#
# Node cleanup action (node is reset to completely clean state).
#
sub docleanup()
{
    unlink TMTOPOMAP();
}

#
# Get topomap
#
sub dotopomap()
{
    my ($pid, $eid, $vname) = check_nickname();
    
    #
    # Copy over the topomap so that it is locally resident. We will eventually
    # get this via a tarfile instead of NFS.
    #
    my $topomap = "/proj/$pid/exp/$eid/tbdata/topomap.gz";
    my $ltmap = "/proj/$pid/exp/$eid/tbdata/ltmap.gz";
    my $ltpmap = "/proj/$pid/exp/$eid/tbdata/ltpmap.gz";
    my $tempmap = "/tmp/topomap.gz";
    my $templt = "/tmp/ltmap.gz";
    my $templtp = "/tmp/ltpmap.gz";

    #
    # Try a couple of times to get the file cause of NFS sillyness.
    # Should probably have our own version of cp that retries at the block
    # level?
    #
    if (! (USESFS() || WINDOWS())) {
	for (my $i = 0; $i < 5; $i++) {
	    last
		if (system("cp -fp $topomap $tempmap") == 0);
	    unlink("$tempmap");
	}
	for (my $i = 0; $i < 5; $i++) {
	    last
		if (system("cp -fp $ltmap $templt") == 0);
	    unlink("$templt");
	}
	if (-e $ltpmap) {
	    for (my $i = 0; $i < 5; $i++) {
		last
		    if (system("cp -fp $ltpmap $templtp") == 0);
		unlink("$templtp");
	    }
	}
    }
    #
    # Make sure we always try to fetch it fresh
    #
    else {
	unlink("$tempmap");
	unlink("$templt");
	unlink("$templtp");
    }
    
    if (! -e $tempmap) {
	#
	# Try using tmcc. It returns compressed data so do it directly.
	#
	system(TMCC() . " topomap > $tempmap");
	#
	# tmcc does not really return useful error codes.
	#
	if ($?) {
	    fatal("Could not get topomap from tmcd or from NFS");
	}
    }

    if (! -e $templt) {
	#
	# Try using tmcc. It returns compressed data so do it directly.
	#
	system(TMCC() . " ltmap > $templt");
	#
	# tmcc does not really return useful error codes.
	#
	if ($?) {
	    fatal("Could not get ltmap from tmcd or from NFS");
	}
    }

    if (! -e $templtp) {
	#
	# Try using tmcc. It returns compressed data so do it directly.
	#
	system(TMCC() . " ltpmap > $templtp");
	#
	# tmcc does not really return useful error codes.
	#
	if ($?) {
	    fatal("Could not get ltpmap from tmcd or from NFS");
	}
    }

    if (-s $tempmap) {
	system("cat ${tempmap} | gunzip > " . TMTOPOMAP());
	if ($?) {
	    fatal("Could not unzip topomap");
	}
	unlink("$tempmap");
    }
    else {
	fatal("Could not get topomap");
    }

    if (-s $templt) {
	system("cat ${templt} | gunzip > " . TMLTMAP());
	if ($?) {
	    fatal("Could not unzip ltmap");
	}
	unlink("$templt");
    }
    else {
	warning("Could not get ltmap");
    }

    if (-s $templtp) {
	system("cat ${templtp} | gunzip > " . TMLTPMAP());
	if ($?) {
	    fatal("Could not unzip ltpmap");
	}
	unlink("$templtp");
    }
    else {
	warning("Could not get ltpmap");
    }
}
