#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use Fcntl ':flock';
use English;
use Getopt::Std;

sub usage() {
    print("Usage: genelists [-d] [-n] -a\n".
	  "Usage: genelists [-d] [-n] [-m] -u user\n".
	  "Usage: genelists [-d] [-n] -p project\n".
	  "Usage: genelists [-d] [-n] -t\n".
	  "where:\n".
	  "  -d    - Turn on debugging\n".
	  "  -n    - Impotent mode\n".
	  "  -u    - Generate lists for a user; add -m for new email address\n".
	  "  -p    - Generate lists for a project (includes subgroups)\n".
	  "  -t    - Generate activity lists\n".
	  "  -a    - Generate all email lists; careful ...\n");
    exit(-1);
}

sub ActiveUsers();
sub RecentUsers();
sub RecentProjects();
sub RecentProjectLeaders();
sub Users();
sub WideAreaPeople();
sub ProjectLeaders();
sub ProjectLists($$);
sub genelist($$$$);

my $optlist = "anu:p:tdmf";
my $debug   = 0;
my $all     = 0;
my $update  = 0;
my $activity= 0;
my $impotent= 0;
my $force   = 0;
my $pid;
my $user;

# Configure variables
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $USERS       = "@USERNODE@";
my $OURDOMAIN   = "@OURDOMAIN@";
my $TBACTIVE    = "@TBACTIVEARCHIVE@";
my $TBALL       = "@TBUSERSARCHIVE@";
my $ELISTS      = "$TB/lists";
my $ELABINELAB  = @ELABINELAB@;
my $MAILMANSUPPORT= @MAILMANSUPPORT@;
my $MMPROG	= "$TB/sbin/setmmlistmembers";

# Note no -n option. We redirect stdin from the new exports file below.
my $SSH		= "$TB/bin/sshtb -l root -host $USERS";
my $PROG	= "/usr/testbed/sbin/genelists.proxy";
my $lockfile    = "/var/tmp/testbed_genelists_lockfile";
my $tempfile    = "/var/tmp/testbed_genelists_tempfile";
my $SAVEUID	= $UID;

#
# Turn off line buffering on output
#
$| = 1;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}
# XXX Hacky!
if (0 && $TB ne "/usr/testbed") {
    die("*** $0:\n".
	"    Wrong version. Maybe its a development version?\n");
}

#
# un-taint path
#
$ENV{'PATH'} = '/bin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV) {
    usage();
}
if (defined($options{"d"})) {
    $debug++;
}
if (defined($options{"a"})) {
    $all = 1;
}
if (defined($options{"m"})) {
    $update = 1;
}
if (defined($options{"t"})) {
    $activity = 1;
}
if (defined($options{"n"})) {
    $impotent = 1;
}
if (defined($options{"u"})) {
    $user = $options{"u"};
    
    #
    # Untaint.
    #
    if ($user =~ /^([-\w]+)$/) {
	$user = $1;
    }
    else {
	die("Tainted argument $user!\n");
    }
}

if (defined($options{"p"})) {
    $pid = $options{"p"};
    
    #
    # Untaint.
    #
    if ($pid =~ /^([-\w]+)$/) {
	$pid = $1;
    }
    else {
	die("Tainted argument $pid!\n");
    }
}

if (defined($user) && defined($pid)) {
    usage();
}
if ($update && !defined($user)) {
    usage();
}

#
# We need to serialize this script to avoid a trashed map file. Use
# a dummy file in /var/tmp, opened for writing and flock'ed.
#
open(LOCK, ">>$lockfile") || fatal("Couldn't open $lockfile\n");
$count = 0;
if (flock(LOCK, LOCK_EX|LOCK_NB) == 0) {
    #
    # If we don't get it the first time, we wait for:
    # 1) The lock to become free, in which case we do our thing
    # 2) The time on the lock to change, in which case we wait for that process
    #    to finish
    #
    my $oldlocktime = (stat(LOCK))[9];
    my $gotlock = 0;
    while (1) {
	print "Another genelists in progress, waiting for it to finish\n";
	if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
	    # OK, got the lock, we can do what we're supposed to
	    $gotlock = 1;
	    last;
	}
	$locktime = (stat(LOCK))[9];
	if ($locktime != $oldlocktime) {
	    $oldlocktime = $locktime;
	    last;
	}
	if ($count++ > 20)  {
	    fatal("Could not get the lock after a long time!\n");
	}
	sleep(1);
    }

    $count = 0;
    #
    # If we didn't get the lock, wait for the processes that did to finish
    #
    if (!$gotlock) {
	while (1) {
	    if ((stat(LOCK))[9] != $oldlocktime) {
		exit(0);
	    }
	    if (flock(LOCK, LOCK_EX|LOCK_NB) != 0) {
		close(LOCK);
		exit(0);
	    }
	    if ($count++ > 30)  {
		fatal("Process with the lock didn't finish after a long time!\n");
	    }
	    sleep(1);
	}
    }
}

#
# Perl-style touch(1)
#
my $now = time;
utime $now, $now, $lockfile;

#
# Grab the mailman admin password for TBOPS.
#
my $admin_address;

if ($MAILMANSUPPORT) {
    my $mailman_password;
    
    if (! TBGetSiteVar("general/mailman/password", \$mailman_password)) {
	fatal("Could not mailman admin password from sitevars!");
    }
    $admin_address = "$TBOPS $mailman_password 'Emulab Operations'";
}
else {
    $admin_address = $TBOPS;
}

ActiveUsers()
    if ($all || $activity || $update);

RecentUsers()
    if ($all || $activity || $update);

RecentProjects()
    if ($all || $activity || $update);

RecentProjectLeaders()
    if ($all || $activity || $update);

Users()
    if ($all || defined($user));

WideAreaPeople()
    if ($all || defined($user));

ProjectLeaders()
    if ($all || defined($user) || defined($pid));

if ($all || defined($user) || defined($pid)) {
    my $query;
    my $phash = {};
    my $query_result;
    
    if ($all) {
	$query = "select g.pid,g.gid from groups as g ".
		 "left join projects as p on p.pid=g.pid ".
		 "where p.approved=1 ";
	$query .= "order by g.pid,g.gid";
    }
    elsif ($user) {
	$query  = "select pid,gid from group_membership where uid='$user' ";
	$query .= "order by pid,gid";
    }
    else {
	$query  = "select pid,gid from groups where pid='$pid' ";
	$query .= "order by pid,gid";
    }

    if (! ($query_result = DBQuery($query))) {
	DBFatal("Getting Project List!");
    }
    while (my ($pid,$gid) = $query_result->fetchrow_array()) {
	ProjectLists($pid, $gid);
    }
}

#
# Close the lock file. Exiting releases it, but might as well.
#
close(LOCK);
exit 0;

#
# All active users on the testbed
#
sub ActiveUsers()
{
    my $userlist;
    my $query_result;

    print "Getting Active Users\n" if $debug;
    
    if (! ($query_result =
	   DBQuery("SELECT DISTINCT u.usr_email from experiments as e ".
		   "left join group_membership as p ".
		   "     on e.pid=p.pid and p.pid=p.gid ".
		   "left join users as u on u.uid=p.uid ".
		   "where u.status='active' and ".
		   "      e.state='active' ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Active Users!");
    }
    $userlist = "$TBOPS\n".
	        "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-active-users", 0);
}

#
# Recently active users.
# 
sub RecentUsers()
{
    my $userlist;
    my $query_result;

    my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");
    print "Getting Recently Active Users\n" if $debug;

    if (! ($query_result =
	   DBQuery("select distinct u.usr_email from user_stats as s ".
		   "left join users as u on u.uid=s.uid ".
		   "where ((UNIX_TIMESTAMP(now()) - ".
		   "       UNIX_TIMESTAMP(s.last_activity)) <= $limit) ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Recently Active Users!");
    }
    $userlist  = "$TBOPS\n";
    $userlist .= "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-recently-active-users", 0);
}

#
# Recently active projects (members).
#
sub RecentProjects()
{
    my $userlist;
    my $query_result;

    my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");
    print "Getting Recently Active Projects (members)\n" if $debug;

    if (! ($query_result =
	   DBQuery("select distinct u.usr_email from project_stats as s ".
		   "left join group_membership as g on ".
		   "  g.pid=s.pid and g.gid=g.pid ".
		   "left join users as u on u.uid=g.uid ".
		   "where u.status='active' and ".
		   "      ((UNIX_TIMESTAMP(now()) - ".
		   "       UNIX_TIMESTAMP(s.last_activity)) <= $limit) ".
		   "order by u.usr_email"))) {
	DBFatal("Getting Recently Active Projects!");
    }
    $userlist  = "$TBOPS\n";
    $userlist .= "$TBACTIVE";

    genelist($query_result, $userlist, "emulab-recently-active-projects", 0);
}

#
# Recently active projects (leaders).
#
sub RecentProjectLeaders()
{
    my $userlist;
    my $query_result;

    my $limit = (60 * 60 * 24) * TBGetSiteVar("general/recently_active");

    if (! ($query_result =
	   DBQuery("select distinct u.usr_email from project_stats as s ".
		   "left join group_membership as g on ".
		   "  g.pid=s.pid and g.gid=g.pid ".
		   "left join users as u on u.uid=g.uid ".
                   "left join projects as p on u.uid=p.head_uid ".
		   "where u.status='active' and ".
		   "      ((UNIX_TIMESTAMP(now()) - ".
		   "       UNIX_TIMESTAMP(s.last_activity)) <= $limit) ".
                   " and p.pid is not null " .
		   "order by u.usr_email"))) {
	DBFatal("Getting Recently Active Project Leaders!");
    }
    $userlist  = "$TBOPS\n";
    $userlist .= "$TBACTIVE";

    genelist($query_result, $userlist,
             "emulab-recently-active-project-leaders", 0);
}

#
# All active users of the testbed.
# 
sub Users()
{
    my $userlist;
    my $query_result;

    print "Getting All Users\n" if $debug;

    if (! ($query_result =
	   DBQuery("SELECT DISTINCT usr_email FROM users ".
		   "where status='active' order by usr_email"))) {
	DBFatal("Getting Users!");
    }
    $userlist  = "$TBOPS\n";
    $userlist .= "$TBALL";
    
    genelist($query_result, $userlist, "emulab-allusers", 0);
}

#
# Special list for people approved to use the widearea-nodes.
#
sub WideAreaPeople()
{
    my $query_result =
	DBQueryFatal("SELECT DISTINCT u.usr_email from projects as p ".
		     "left join group_membership as m on m.pid=p.pid ".
		     "left join users as u on u.uid=m.uid ".
		     "where p.approved!=0 and p.pcremote_ok is not null ".
		     "      and m.trust!='none' and u.status='active' ".
		     "order by usr_email");

    genelist($query_result, "$TBOPS", "emulab-widearea-users", 0);
}

#
# Another list of project leaders.
#
sub ProjectLeaders()
{
    my $query_result =
	DBQueryFatal("SELECT DISTINCT u.usr_email ".
		     ($MAILMANSUPPORT ?
		      ", u.uid ,u.usr_name, u.mailman_password " : "") .
		     "  from projects as p ".
		     "left join users as u on u.uid=p.head_uid ".
		     "where p.approved!=0 ".
		     "order by usr_email");

    genelist($query_result, "$TBOPS", "emulab-project-leaders", 0);
}

#
# Regen project lists. 
#
sub ProjectLists($$)
{
    my ($pid, $gid) = @_;
    my $proj_result;

    print "Getting project members for $pid/$gid\n" if $debug;

    my $query_result =
	DBQueryFatal("SELECT distinct u.usr_email ".
		     ($MAILMANSUPPORT ?
		      ", u.uid ,u.usr_name, u.mailman_password " : "") .
		     " from group_membership as p ".
		     "left join users as u on u.uid=p.uid ".
		     "where p.pid='$pid' and p.gid='$gid' and ".
		     " p.trust!='none' and u.status='active' ".
		     "order by u.usr_email");

    if ($query_result->numrows) {
	if ($pid eq $gid) {
	    genelist($query_result, undef, "$pid-users", 1);
	}
	else {
	    genelist($query_result, undef, "$pid-$gid-users",
		     ($ELABINELAB ? 0 : 1));
	}
    }
}

#
# Generate and fire over a list.
#
sub genelist($$$$)
{
    my($query_result, $inituserlist, $listname, $usemailman) = @_;

    print "Processing $listname at: \t".time()." \t(".
      $query_result->numrows()." entries)\n" if $debug;

    open(LIST,"> $tempfile") ||
	fatal("Couldn't open $tempfile: $!\n");

    print LIST "#\n";
    print LIST "# WARNING! THIS FILE IS AUTOGENERATED. DO NOT EDIT!\n";
    print LIST "#\n";
    if (defined($inituserlist)) {
	print LIST "$inituserlist\n";
    }

    for ($i = 0; $i < $query_result->numrows; $i++) {
	my ($user_email, $uid, $user_name, $mailman_password) =
	    $query_result->fetchrow_array();
	
	if (! defined($user_email)) {
	    next;
	}
	# HACK! These special accounts should be flagged in the DB
	next 
	    if ($usemailman && ($uid eq "elabman" || $uid eq "elabckup" ||
				$uid eq "operator"));
	    
	if ($usemailman && $MAILMANSUPPORT) {
	    print LIST "$uid $user_email $mailman_password '$user_name'\n";
	}
	else {
	    print LIST "$user_email\n";
	    print "$user_email\n" if $debug>1;
	}
    }
    close(LIST);
    chmod(0664, $tempfile);

    if (! -d $ELISTS) {
	if (! mkdir($ELISTS, 0770)) {
	    fatal("Could not make directory $ELISTS: $!");
	}

	if (! chmod(0775, $ELISTS)) {
	    fatal("Could not chmod directory $ELISTS: $!");
	}
    }

    if (-e "$ELISTS/$listname" &&
	system("cmp -s $tempfile $ELISTS/$listname") == 0) {
	print "$listname has not changed. Skipping.\n"
	    if ($debug);
	if (!$force) {
	    unlink("$tempfile");
	    return;
	}
    }

    system("/bin/cp -pf $tempfile $ELISTS/$listname") == 0 ||
	fatal("Could not move $tempfile to $ELISTS/$listname: $!");
    
    #
    # Fire the new file over to the fileserver to finish up.
    #
    if (!$impotent) {
	if ($usemailman && $MAILMANSUPPORT) {
	    my $optarg = ($debug ? "-d" : "");

	    $EUID = $UID;
	    system("$MMPROG $optarg $listname $tempfile") == 0 or
		fatal("Failed: $MMPROG $listname $tempfile: $?");
	    $EUID = 0;
	}
	else {
	    $UID = 0;
	    system("$SSH $PROG $listname < $tempfile") == 0 or
		fatal("Failed: $SSH $PROG $listname < $tempfile: $?");
	    $UID = $SAVEUID;
	}
    }
    unlink("$tempfile");
}

sub fatal {
  local($msg) = $_[0];
  SENDMAIL($TBOPS, "Failure Generating Email Lists", $msg);
  die($msg);
}
