#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# nfree - Takes pysical node names, and frees them from the experiment they
# are allocated to. If nodes are ommited, frees up all nodes in the given
# experiment. Looks in the scheduled_reloads and next_reserve tables to see
# if this node should be re-reserved into another experiment and/or reloaded,
# rather than being put back into the pool of free nodes
#
sub usage ()
{
    die("Usage: nfree [-x] <pid> <eid> [<node> <node> <...>]\n".
	"Releases all nodes in the specified experiment.\n".
	"If nodes are listed, nfree releases only those nodes.\n".
	" '-x' frees all virtual nodes on any physical node that gets freed.\n"
	);
}

# Configure variables
my $TB       = "@prefix@";
my $TESTMODE = @TESTMODE@;

# Testbed Support libraries
use lib "@prefix@/lib";
use libdb;
use libtestbed;

my $consetup	= "$TB/libexec/console_setup";
my $osselect    = "$TB/bin/os_select";
my $reloadpid	= "emulab-ops";
my $pendingeid  = "reloadpending";
my $reloadeid   = "reloading";

my @nodes;
my @freed_nodes=();
my $error = 0;

$| = 1;  # Turn off line buffering on output

# Untaint the path
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
my  $optlist = "x";

%options = ();

if (! getopts($optlist, \%options)) {
    usage();
}

my $freeDependantVirtuals = 0;

if (defined($options{"x"})) {
    $freeDependantVirtuals = 1;
}

if (@ARGV < 2) {
    usage();
}

my $pid = shift;
my $eid = shift;

# Untaint args.
if ($pid =~ /^([-\@\w]+)$/) { $pid = $1; }
else { die("Bad data in pid: $pid."); }
if ($eid =~ /^([-\@\w]+)$/) { $eid = $1; }
else { die("Bad data in eid: $eid."); }

# Make sure that the experiment actually exists
if (!ExpState($pid,$eid)) {
    die("There is no experiment '$eid' in project '$pid'.\n");
}

# Make sure the user has the ability to modify this experiment
if (!TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
    die("You do not have permission to modify '$eid' in project '$pid'.\n");
}

# Make a list of nodes given on the command line, or get the whole list from
# the DB if none provided.
if (@ARGV) {
    foreach my $n (@ARGV) {
	# Taint check first! Solves silly perl problems.
	if ($n =~ /^([-\w]+)$/) { $n = $1; }
	else { die("*** $0:\n    Bad node name: $n.\n"); }

	# Shark hack
	if ($n =~ /(sh\d+)/ ) {
	    # It's a shark - do the whole shelf if its not done already.
	    my $shelf = $1;
	    if ( ! (join(",", @nodes) =~ /,$shelf-\d,/)) {
		# Shelf hasn't been done yet...
		foreach my $n ( 1 .. 8 ) {
		    push(@nodes, "$shelf-$n");
		}
	    }
	    # End shark hack
	} else {
	    # its not a shark - just add it in...
	    push(@nodes, $n);

	    # if -x was specified, remove any 
	    # mapping to a node which has a phys_nodeid of $n.
	    if ($freeDependantVirtuals) {
		my $result = 
		    DBQueryFatal("SELECT r.node_id FROM reserved AS r ".
				 "LEFT JOIN nodes AS n ".
				 "ON r.node_id=n.node_id ".
				 "WHERE n.phys_nodeid='$n' AND ".
				 "r.eid='$eid' AND r.pid='$pid'");
		while (my ($dependantVirtual) = $result->fetchrow_array()) {
		    if (defined $dependantVirtual && $dependantVirtual ne $n) {
			push(@nodes, $dependantVirtual);
		    }
		}
	    }
	}
    }
} else {
    print "Releasing all nodes from experiment '$eid' in project '$pid'.\n";
    @nodes = ExpNodes($pid, $eid);
}

######################################################################
# Step 1
#
# See what nodes need to be freed, and then lock them down my moving
# them to a holding reservation.
#
# We lock just the reserved table. The prevents races between multiple
# invocations of nfree trying to free the same node. Rather than lock
# a zillion tables, move the reservation into a holding pattern. This
# effectively prevents someone else from freeing the same nodes, and from
# someone else allocating the nodes until we are done cleaning things up.
#
# NOTE: My reason for not wanting to lock all those tables (9 in the
# original version) is that library calls will fail since mysql locking
# requires that every table used within the locked area, be locked.
# Of course, who knows what tables the library uses, so thats a silly
# way to go.
#
######################################################################

# Form a unique temporary EID. I want this to be unique in case something
# goes wrong, and they get left in the DB.
my $lockedeid = "nfree-locked-$PID";

DBQueryFatal("lock tables reserved write");

foreach my $n (@nodes) {
    # Check to make sure they have actually reserved the nodes.
    my $result =
	DBQueryFatal("select * from reserved where node_id='$n' ".
		     "and eid='$eid' and pid='$pid'");
    if ($result->numrows == 0) {
	print "Node '$n' is not reserved by your experiment.\n";
	$error++;
	next;
    }

    # Move to locked reservation. Node is not free, but is no longer
    # owned by the pid/eid, so cannot be mucked with.
    if (! DBQueryWarn("update reserved " .
		      "set vname='$n', pid='$reloadpid', eid='$lockedeid' ".
		      "where node_id='$n'")) {
	print "*** WARNING: Error locking down node $n!\n";
	next;
    }

    push(@freed_nodes, $n);
}

DBQueryFatal("unlock tables");

######################################################################
# Step 2
#
# Go through the list of nodes we successfully locked down, and clean
# up the node state (nodes, delays, interfaces, etc). Once that is done,
# move them to whatever new reservations are pending, or free the node.
#
######################################################################

foreach my $n (@freed_nodes) {
    my $mustclean = 1;

    # Clean out all delays
    DBQueryWarn("delete from delays where node_id='$n'") || $error++;

    # Find the control net interface for this node type, as well as some
    # of the default values for its node type.
    my $result =
	DBQueryFatal("select control_net,nt.osid,nt.pxe_boot_path, " .
		     "n.def_boot_osid,n.def_boot_path, ".
		     "nt.isvirtnode, nt.imageable, o.osid ".
		     "from node_types as nt " .
		     "left join nodes as n on n.type=nt.type " .
		     "left join os_info as o on o.path=nt.pxe_boot_path " .
		     "where node_id='$n'");
    my ($control, $osid, $pxe_boot_path, $def_boot_osid, $def_boot_path,
	$isvirt, $imageable, $pxe_osid) = $result->fetchrow_array();
    if (!defined($pxe_osid) || $pxe_osid eq "") {
	$pxe_osid = "-p $pxe_boot_path";
    }

    # See if the OS it was running was marked as mustclean or not. Basically,
    # this is an OSKit hack to avoid reloading disks that have not been
    # touched by the kernel. If a def_boot_path was set, there is nothing
    # we can figure out, so just reload it. This needs to be more general
    # purpose.
    if ($isvirt || !$imageable) {
	# VIRTNODE HACK: Virtual nodes are special. Do not clean or reload.
	$mustclean = 0;
    } elsif (! defined($def_boot_osid) ||
	 (defined($def_boot_path) && $def_boot_path ne "")) {
	$mustclean = 1;
    } else {
	my $result =
	    DBQueryFatal("select mustclean from os_info " .
			 "where osid='$def_boot_osid'");
	if ($result->numrows()) {
	    ($mustclean) = $result->fetchrow_array();
	}
    }

    # Clean up interfaces by clearing IPs and/or aliases.
    if (! ($n =~ /sh\d+/)) {
        # Its not a shark, so clean out all IPs except the control net.
	DBQueryWarn("update interfaces set IP='' " .
		    "where node_id='$n' and card!='$control'") || $error++;
    } else {
	# XXX Shark Hack!
	DBQueryWarn("update interfaces set IPalias='' ".
		    "where node_id='$n'") || $error++;
    }

    # Map the default OSID to something that is actually loaded on the
    # machine. I think this is a hack, but its the best I can come up
    # with right now.
    if (! $isvirt && $imageable) {
	my $mapped_osid = MapNodeOSID($n, $osid);
	if ($mapped_osid) {
	    $osid = $mapped_osid;
	}
    }

    # Reset the OS to the default osid for the node type
    #
    # XXX disabled while forced reload hack is in place
    #system("$osselect -m $pxe_osid $n");
    #system("$osselect $osid $n");

    # Clean up the nodes table so that its in a moderately clean state.

    #foreach $var ( 'osid','pxe_boot_path','n') {
	#print "\$$var = ";
	#if (!defined ${$var}) {
	#    print "(null)";
	#} else {
	#    print ${$var};
        #}
        #print "\n";
    #}
    my $allocFreeState = TBDB_ALLOCSTATE_FREE_DIRTY();

    DBQueryWarn("update nodes set startupcmd='',rpms='',deltas='', ".
		"tarballs='',failureaction='fatal', routertype='none', ".
		"def_boot_cmd_line='',next_boot_cmd_line='', ".
		"update_accounts=0,ipport_next=ipport_low, ".
		"allocstate='$allocFreeState' ".
		"where node_id='$n'") || $error++;

    # Clean out the current_reloads table (a just in case measure).
    DBQueryWarn("delete from current_reloads where node_id='$n'") || $error++;

    # Reset its port allocation stuff.
    DBQueryWarn("delete from nodeipportnum where node_id='$n'") || $error++;

    # Now its safe to change the reservation.

    # If the node has a next_reserve entry, change the reservation.
    $result =
	DBQueryFatal("select node_id,pid,eid from next_reserve ".
		     "where node_id='$n'");

    if ($result->num_rows()) {
	my ($node, $next_pid, $next_eid) = $result->fetchrow_array();
	
	print "Moving $n to $next_pid/$next_eid.\n";

	DBQueryWarn("update reserved set pid='$next_pid',eid='$next_eid'," .
		    "vname='$n' where node_id='$n'")
	    || $error++;
	
	DBQueryWarn("delete from next_reserve where node_id='$n'")
	    || $error++;

	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }

    # If the node has a reloads entry, change the reservation so that the
    # reload_daemon will pick it up.
    $result =
	DBQueryFatal("select node_id,image_id from scheduled_reloads " .
		     "where node_id='$n'");

    # XXX force reload hack!
    if ( !$TESTMODE && ((!$isvirt && $imageable) || $result->numrows()) ) {
	print "Moving $n to $reloadpid/$pendingeid.\n";
	
	DBQueryWarn("update reserved set pid='$reloadpid',eid='$pendingeid',".
		    "vname='$n' where node_id='$n'") || $error++;

	# This little sillyness is for disk reloading.
	# Kill the last reservation since this path is special.
	DBQueryWarn("delete from last_reservation where node_id='$n'") ||
	    $error++;

	next;
    }

    # No reloads or reservation changes, so really free the node
    #
    # This little sillyness is for disk reloading. Remember the last
    # project a node was reserved into. At present, there might already
    # be an entry. Eventually, os_setup will look for this and force
    # a reload.
    if ($mustclean) {
	DBQueryWarn("replace into last_reservation values ('$n', '$pid')");
    }

    print "Releasing node '$n' ... ";
    if (DBQueryWarn("delete from reserved where node_id='$n'")) {
	print "Succeeded.\n";
    }
    else {
	print "Failed!\n";
	$error++;
    }
}

######################################################################
# Step 3 - Set up console for freed nodes.
#
# Using a list of freed nodes build eariler, run consetup to reset
# their serial consoles.
#
# NOTE: While it may seem like a race to do this after releasing the
# reservation, it really is not. Even if the node is allocated again
# console_setup looks at the current reservation and does the right
# thing, and since nalloc locks the reserved table, ordering will be
# preserved.
#
######################################################################

if (@freed_nodes) {
    system("$consetup @freed_nodes") == 0 ||
	print STDERR "WARNING: $consetup @freed_nodes failed!\n";
}

exit($error);

