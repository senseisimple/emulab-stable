#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
#
# XXX Need to deal with locking at some point ...
#
package Template;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT);

@ISA    = "Exporter";
@EXPORT = qw ( );

# Must come after package declaration!
use lib '@prefix@/lib';
use libdb;
use libtestbed;
use libtblog;
use Experiment;
use English;
use overload ('""' => 'Stringify');

# Configure variables
my $TB		= "@prefix@";
my $CONTROL	= "@USERNODE@";
my $MD5         = "/sbin/md5";
my $MKDIR       = "/bin/mkdir";
my $RMDIR       = "/bin/rmdir";
my $RM		= "/bin/rm";
my $makegraph   = "$TB/bin/template_graph";
my $TEVC	= "$TB/bin/tevc";
my $DBCONTROL   = "$TB/sbin/opsdb_control";
my $RSYNC	= "/usr/local/bin/rsync";

# Cache of template instances to avoid regenerating them.
my %templates   = ();
my $debug	= 1;

# Flags for functions below.
sub STARTRUN_FLAGS_FIRSTRUN()	{ 0x1 ;}
sub STARTRUN_FLAGS_SWAPMOD()	{ 0x2 ;}

#
# Grab a new GUID for a template. We do not have to use it of course.
#
sub NewGUID($)
{
    my ($pidx) = @_;
    my $idx;
    
    DBQueryFatal("lock tables emulab_indicies write");

    my $query_result = 
	DBQueryFatal("select idx from emulab_indicies ".
		     "where name='next_guid'");
	
    if (! $query_result->num_rows) {
	$idx = 10000;
	
	DBQueryFatal("insert into emulab_indicies (name, idx) ".
		     "values ('next_guid', $idx)");
    }
    else {
	($idx) = $query_result->fetchrow_array();
    }
    my $nextidx = $idx + 1;
    
    DBQueryFatal("update emulab_indicies set idx='$nextidx' ".
		 "where name='next_guid'");

    DBQueryFatal("unlock tables");

    $$pidx = $idx;
    return 0;
}

# Little helper and debug function.
sub mysystem($)
{
    my ($command) = @_;

    print STDERR "Running '$command'\n"
	if ($debug);
    return system($command);
}

#
# Lookup a template and create a class instance to return.
#
sub Lookup($$$)
{
    my ($class, $guid, $vers) = @_;

    # Look in cache first
    return $templates{"$guid/$vers"}
        if (exists($templates{"$guid/$vers"}));
    
    my $query_result =
	DBQueryWarn("select * from experiment_templates ".
		    "where guid='$guid' and vers='$vers'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self             = {};
    $self->{'TEMPLATE'}  = $query_result->fetchrow_hashref();
    # Filled lazily.
    $self->{'INSTANCES'} = undef;
    bless($self, $class);
    
    # Add to cache. 
    $templates{"$guid/$vers"} = $self;
    
    return $self;
}
# accessors
sub guid($) { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'guid'}); }
sub vers($) { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'vers'}); }
sub pid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'pid'}); }
sub gid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'gid'}); }
sub eid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'eid'}); }
sub tid($)  { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'tid'}); }
sub path($) { return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'path'}); }
sub archive_idx($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'archive_idx'}); }
sub parent_guid($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'parent_guid'}); }
sub IsRoot($) {
    return ! defined($_[0]->{'TEMPLATE'}->{'parent_guid'}); }
sub child_guid($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'child_guid'}); }
sub child_vers($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'child_vers'}); }
sub description($) {
    return ((! ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}->{'description'}); }

#
# Lookup a template given an experiment index.
#
sub LookupByExptidx($$)
{
    my ($class, $exptidx) = @_;

    # Use the Template Instance routine, and grab the template out of it.
    my $template_instance = Template::Instance->LookupByExptidx($exptidx);

    return undef
	if (!defined($template_instance));

    return $template_instance->template();
}

#
# Lookup a template given pid,eid. This refers to the template itself,
# not an instance of the template.
#
sub LookupByPidEid($$$)
{
    my ($class, $pid, $eid) = @_;

    my $query_result =
	DBQueryWarn("select guid,vers from experiment_templates ".
		    "where pid='$pid' and eid='$eid'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my ($guid,$vers) = $query_result->fetchrow_array();

    return Template->Lookup($guid, $vers);
}

#
# Refresh a template instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    my $query_result =
	DBQueryWarn("select * from experiment_templates ".
		    "where guid='$guid' and vers='$vers'");

    return -1
	if (!$query_result || !$query_result->numrows);
	
    $self->{'TEMPLATE'} = $query_result->fetchrow_hashref();
    return 0;
}

#
# Create a new template. This installs the new record in the DB,
# and returns an instance. There is some bookkeeping along the way.
#
sub Create($$)
{
    my ($class, $argref) = @_;
    my ($guid, $vers);

    return undef
	if (ref($class));

    # See if this a child of an existing template.
    if (defined($argref->{'parent_guid'})) {
	$guid = $argref->{'parent_guid'};
    }
    else {
	#
	# Grab a new GUID before we lock other tables.
	#
	if (NewGUID(\$guid) < 0) {
	    tberror("Could not get a new GUID!");
	    return undef;
	}
	$vers = 1;
    }

    DBQueryWarn("lock tables experiments write, ".
		"            experiment_templates write")
	or return undef;

    #
    # Find unused version number now that tables are locked. 
    #
    if (! defined($vers)) {
	my $query_result =
	    DBQueryWarn("select MAX(vers) from experiment_templates ".
			"where guid='$guid'");

	if (!$query_result) {
	    DBQueryWarn("unlock tables");
	    return undef;
	}

	$vers = ($query_result->fetchrow_array())[0];
	$vers++;
    }

    # We make up an eid using the guid and version. This is the eid for the
    # hidden experiment behind each template. 
    my $eid = "T${guid}-${vers}";
    my $pid = $argref->{'pid'};

    #
    # Sanity check; make sure this eid is not in use. Tables are still locked.
    #
    my $query_result =
	DBQueryWarn("select pid,eid from experiments ".
		    "where eid='$eid' and pid='$pid'");

    if (!$query_result) {
	DBQueryWarn("unlock tables");
	return undef;
    }
    
    if ($query_result->numrows) {
	DBQueryWarn("unlock tables");
	tberror("Experiment ID $eid in project $pid is already in use!");
	return undef;
    }

    my $query = "insert into experiment_templates set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    # Append the rest
    $query .= ",created=now(),guid='$guid',vers='$vers',eid='$eid'";

    if (! DBQueryWarn($query)) {
	DBQueryWarn("unlock tables");
	return undef;
    }
    DBQueryWarn("unlock tables");

    return Template->Lookup($guid, $vers);
}

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self) = @_;
    my $guid   = $self->guid();
    my $vers   = $self->vers();

    return "[Template: $guid/$vers]";
}

#
# Update a template record given an array reference of slot/value pairs.
#
sub Update($$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();

    my $query = "update experiment_templates set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    $query .= " where guid='$guid' and vers='$vers'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}

#
# Delete a template (all tables). Note that other parts of the template
# like instances must already be gone when this is called.
#
sub Delete($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $path = $self->path();

    if (defined($path) && $path ne "" && -e $path) {
	mysystem("$RM -rf $path") == 0
	    or return -1;
    }

    DeleteAllMetadata($self) == 0
	or return -1;

    DeleteInputFiles($self) == 0
	or return -1;

    # The graph can be removed if this is the last template version.
    my $query_result =
	DBQueryWarn("select vers from experiment_templates ".
		    "where guid='$guid' and vers!='$vers'");
    return -1
	if (! $query_result);

    if (! $query_result->numrows) {
	DBQueryWarn("delete from experiment_template_graphs ".
		    "where parent_guid='$guid'")
	    or return -1;
    }

    # Make sure the experiment_templates table is always last, in case
    # something goes wrong. 
    my @tables = ("experiment_template_parameters",
		  "experiment_templates");

    foreach my $table (@tables) {
        if ($table eq "experiment_templates") {
            DBQueryWarn("delete from $table ".
			"where guid='$guid' and vers='$vers'")
		or return -1;
        }
        else {
            DBQueryWarn("delete from $table ".
			"where parent_guid='$guid' and parent_vers='$vers'")
		or return -1;
        }
    }
    $self->{'TEMPLATE'} = undef;
    return 0;
}

#
# Template permission checks. Using the experiment access check stuff.
#
# Usage: AccessCheck($guid, $uid, $access_type)
#	 returns 0 if not allowed.
#        returns 1 if allowed.
#
sub AccessCheck($$$;$)
{
    my ($self, $guid, $uid, $access_type);
    my $mintrust;
    
    #
    # If called as a method, no guid argument is provided. 
    #
    $self = shift();

    if (ref($self)) {
	($uid, $access_type) = @_;
    }
    else {
	($guid, $uid, $access_type) = @_;

	$self = Template->Lookup($guid, 1);
	return 0
	    if (! $self);
    }
    
    if ($access_type < TB_EXPT_MIN ||
	$access_type > TB_EXPT_MAX) {
	tbdie("Invalid access type: $access_type!");
    }

    #
    # Admins do whatever they want!
    #
    if (TBAdmin($uid)) {
	return 1;
    }
    $uid = MapNumericUID($uid);

    my $pid = $self->pid();
    my $gid = $self->gid();

    #
    # An experiment may be destroyed by the experiment creator or the
    # project/group leader.
    #
    if ($access_type == TB_EXPT_READINFO) {
	$mintrust = PROJMEMBERTRUST_USER;
    }
    else {
	$mintrust = PROJMEMBERTRUST_LOCALROOT;
    }

    #
    # Either proper permission in the group, or group_root in the project.
    # This lets group_roots muck with other people's experiments, including
    # those in groups they do not belong to.
    #
    return TBMinTrust(TBGrpTrust($uid, $pid, $gid), $mintrust) ||
	TBMinTrust(TBGrpTrust($uid, $pid, $pid), PROJMEMBERTRUST_GROUPROOT);
}

#
# Return a list of all children of the given template.
#
sub Children($$)
{
    my ($self, $resultp) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid      = $self->guid();
    my %children  = ();
    my @allkids   = ();
    my @kids      = ();
    my @result    = ();
    
    my $query_result =
	DBQueryWarn("select vers,parent_vers from experiment_templates ".
		    "where parent_guid='$guid' ".
		    "order by vers desc");
    return -1
	if (!$query_result);

    while (my ($vers, $parent_vers) = $query_result->fetchrow_array()) {
	$children{$parent_vers} = []
	    if (!exists($children{$parent_vers}));

	# List of all children for the parent.
	push(@{ $children{$parent_vers} }, $vers);
    }

    # Start with direct children of this template.
    unshift(@allkids, @{ $children{$self->vers()} })
	if (exists($children{$self->vers()}));

    # Descend the tree getting all children recursively.
    while (@allkids) {
	my $kid   = pop(@allkids);

	# New kid to return
	push(@kids, $kid);

	# New children of kid
	unshift(@allkids, @{ $children{$kid} })
	    if (exists($children{$kid}));
    }
    # Most recent templates first.
    @kids = sort {$b <=> $a} @kids;

    # Now convert to template objects.
    foreach my $vers (@kids) {
	my $template = Template->Lookup($guid, $vers);
	return -1
	    if (! $template);
	push(@result, $template);
    }

    @$resultp = @result;
    return 0;
}

#
# Add an input file to the template. The point of this is to reduce
# duplication by taking an md5 of the input file, and sharing that
# record/file.
# 
sub AddInputFile($$)
{
    my ($self, $inputfile) = @_;
    my $input_data_idx;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $data_string = `cat $inputfile`;
    return -1
	if ($?);

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $pid  = $self->pid();
    my $tid  = $self->tid();

    if ($data_string) {
	# As you can see, we md5 the raw data.
	$data_string = DBQuoteSpecial($data_string);
	if (length($data_string) >= DBLIMIT_NSFILESIZE()) {
	    tberror("Input file is too big (> " . DBLIMIT_NSFILESIZE() . ")!");
	    return -1;
	}

	#
	# Grab an MD5 of the file to see if we already have a copy of it.
	# Avoids needless duplication.
	#
	my $md5 = `$MD5 -q $inputfile`;
	chomp($md5);

	DBQueryWarn("lock tables experiment_template_inputs write, ".
		    "            experiment_template_input_data write")
	    or return -1;

	my $query_result =
	    DBQueryWarn("select idx from experiment_template_input_data ".
			"where md5='$md5'");

	if (!$query_result) {
	    DBQueryWarn("unlock tables");
	    return -1;
	}

	if ($query_result->numrows) {
	    ($input_data_idx) = $query_result->fetchrow_array();
	}
	else {
	    $query_result =
		DBQueryWarn("insert into experiment_template_input_data ".
			    "(idx, md5, input) ".
			    "values (NULL, '$md5', $data_string)");
	    
	    if (!$query_result) {
		DBQueryWarn("unlock tables");
		return -1;
	    }
	    $input_data_idx = $query_result->insertid;
	}

	$query_result =
	    DBQueryWarn("insert into experiment_template_inputs ".
			" (idx, parent_guid, parent_vers, ".
			"  pid, tid, input_idx) values ".
			" (NULL, '$guid', '$vers', '$pid', '$tid', ".
			"  '$input_data_idx')");
	DBQueryWarn("unlock tables");
	return -1
	    if (!$query_result);
    }
    return 0;
}

#
# Delete all input files, say for a template create/modify that fails.
#
sub DeleteInputFiles($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("lock tables experiment_template_inputs as i write, ".
		"            experiment_template_inputs as j write, ".
		"            experiment_template_inputs write, ".
		"            experiment_template_input_data write")
	or return -1;

    #
    # The point of this query is to see if any of the input files in this
    # template are shared with some other template, and thus should not
    # be deleted from the input_data table.
    #
    my $query_result =
	DBQueryWarn("select i.idx,i.input_idx,count(j.input_idx) as count ".
		    "   from experiment_template_inputs as i ".
		    "left join experiment_template_inputs as j on ".
		    "     j.input_idx=i.input_idx ".
		    "where i.parent_guid='$guid' and ".
		    "      i.parent_vers='$vers' ".
		    "group by j.input_idx having count > 1");

    if (! $query_result) {
	DBQueryWarn("unlock tables");
	return -1;
    }

    while (my ($input_idx, $data_idx) = $query_result->fetchrow_array()) {
	DBQueryWarn("delete from experiment_template_input_data ".
		    "where idx='$data_idx'");
    }
    $query_result = 
	DBQueryWarn("delete from experiment_template_inputs ".
		    "where parent_guid='$guid' and parent_vers='$vers'");
    DBQueryWarn("unlock tables");
    
    return -1
	if (! $query_result);

    return 0;
}

#
# Add a metadata record. 
#
sub NewMetadata($$$$;$)
{
    my ($self, $name, $value, $creator, $type) = @_;
    my $guid;
    my $version  = 1;
    my $internal = 0;
    my $metadata_type;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    return -1
	if (NewGUID(\$guid) < 0);

    # Special ...
    $internal = 1
	if (defined($type));

    # Current set of allowed types;
    my @okay_types = ("tid", "template_description", "parameter_description");

    if (defined($type)) {
	if (! grep {$_ eq $type} @okay_types) {
	    tberror("Illegal metadata type: $type");
	    return -1;
	}
	$metadata_type = "'$type'";
    }
    else {
	$metadata_type = "NULL";
    }

    my $safename  = DBQuoteSpecial($name);
    my $safevalue = DBQuoteSpecial($value);

    my $query_result =
	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$creator', ".
		    "   template_guid='$template_guid', ".
		    "   name=$safename, value=$safevalue, created=now()");
    return -1
	if (!$query_result);

    DBQueryWarn("insert into experiment_template_metadata set ".
		"   parent_guid='$template_guid', ".
		"   parent_vers='$template_vers', ".
		"   metadata_guid='$guid', ".
		"   metadata_vers='$version', ".
		"   metadata_type=$metadata_type, ".
		"   internal=$internal")
	or return -1;

    # Some metadata is special ...
    if (defined($type)) {
	if ($type eq "parameter_description") {
	    $query_result =
		DBQueryWarn("update experiment_template_parameters set ".
			    "   metadata_guid='$guid', ".
			    "   metadata_vers='$version' ".
			    "where parent_guid='$template_guid' and ".
			    "      parent_vers='$template_vers' and ".
			    "      name=$safename");
	    return -1
		if (!$query_result);
	}
    }
    
    return 0;
}

#
# Lookup a metadata value by name, optionally returning guid/vers.
#
sub LookupMetadata($$;$$$)
{
    my ($self, $name, $pguid, $pvers, $ptype) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select metadata_guid,metadata_vers,metadata_type ".
		    "   from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     m.metadata_guid=i.guid and m.metadata_vers=i.vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      i.name=$name");
    
    return -1
	if (!$query_result);
    return 0
	if (!$query_result->numrows);

    my ($metadata_guid, $metadata_vers, $metadata_type) =
	$query_result->fetchrow_array();
    $$pguid = $metadata_guid
	if (defined($pguid));
    $$pvers = $metadata_vers
	if (defined($pvers));
    $$ptype = $metadata_type
	if (defined($ptype));
    
    return 1;
}

#
# Modify a metadata record; these are versioned of course.
#
sub ModifyMetadata($$$$)
{
    my ($self, $name, $value, $creator) = @_;
    my $guid;
    my $version = 1;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    my $parent_guid;
    my $parent_vers;
    my $metadata_type;
    my $already_exists =
	$self->LookupMetadata($name,
			      \$parent_guid, \$parent_vers, \$metadata_type);
    return -1
	if ($already_exists <= 0);

    $name  = DBQuoteSpecial($name);
    $value = DBQuoteSpecial($value);

    DBQueryWarn("lock tables experiment_template_metadata_items write")
	or return -1;
    
    my $query_result =
	DBQueryWarn("select MAX(vers) ".
		    " from experiment_template_metadata_items ".
		    "where guid='$parent_guid'");
    if (!$query_result) {
	DBQueryWarn("unlock tables");
	return -1;
    }
    my ($metadata_vers) = $query_result->fetchrow_array();
    $metadata_vers++;

    #
    # Insert new item.
    #
    if (!DBQueryWarn("insert into experiment_template_metadata_items set ".
		     "     guid='$parent_guid',vers='$metadata_vers', ".
		     "     template_guid='$template_guid', uid='$creator', ".
		     "     parent_guid='$parent_guid',".
		     "     parent_vers='$parent_vers'," .
		     "     name=$name, value=$value, created=now()")) {
	DBQueryWarn("unlock tables");
	return -1;
    }
    DBQueryWarn("unlock tables");

    if (!DBQueryWarn("update experiment_template_metadata ".
		     "  set metadata_vers='$metadata_vers' ".
		     "where metadata_guid='$parent_guid' and ".
		     "      metadata_vers='$parent_vers'")) {
	DBQueryWarn("delete from experiment_template_metadata_items ".
		    "where guid='$parent_guid',vers='$metadata_vers'");
	return -1;
    }

    #
    # XXX Some metadata is special ...
    #
    if (defined($metadata_type)) {
	if ($metadata_type eq "tid") {
	    DBQueryWarn("update experiment_templates set tid=$value ".
			"where guid='$template_guid' and ".
			"      vers='$template_vers'")
		or return -1;
	    
	    Refresh($self);
	    # This can fail; it is not critical.
	    Template::mysystem("$makegraph $template_guid");
	}
	elsif ($metadata_type eq "template_description") {
	    DBQueryWarn("update experiment_templates set description=$value ".
			"where guid='$template_guid' and ".
			"      vers='$template_vers'")
		or return -1;
	    
	    Refresh($self);	
	}
	elsif ($metadata_type eq "parameter_description") {
	    DBQueryWarn("update experiment_template_parameters set ".
			"   metadata_guid='$parent_guid', ".
			"   metadata_vers='$metadata_vers' ".
			"where parent_guid='$template_guid' and ".
			"      parent_vers='$template_vers' and ".
			"      name=$name")
		or return -1
	}
    }
    return 0;
}

#
# Add a formal parameter to a template.
#
sub NewFormalParameter($$$$$)
{
    my ($self, $name, $value, $description, $dbuid) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    my $pid = $self->pid();
    my $tid = $self->tid();

    if (defined($value)) {
      $value = DBQuoteSpecial($value);
    }
    else {
      $value = "NULL";
    }

    DBQueryWarn("insert into experiment_template_parameters set ".
		"  parent_guid='$template_guid', ".
		"  parent_vers='$template_vers', ".
		"  pid='$pid', tid='$tid', ".
		"  name='$name', value=$value")
	or return -1;

    if (defined($description) && $description ne "") {
	$self->NewMetadata($name,
			   $description, $dbuid, "parameter_description")
	    == 0 or return -1;
    }

    return 0;
}

#
# Get list of template formal parameters.
#
sub FormalParameterList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    my $query_result =
	DBQueryWarn("select name,value from experiment_template_parameters ".
		    "where parent_guid='$template_guid' and ".
		    "      parent_vers='$template_vers'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

#
# Get description for formal parameters; this needs to be its own object.
#
sub FormalParameterDescription($$)
{
    my ($self, $name, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $result = undef;
    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select m.value from experiment_template_parameters as p ".
		    "left join experiment_template_metadata_items as m on ".
		    "     m.guid=p.metadata_guid and m.vers=p.metadata_vers ".
		    "where p.parent_guid='$template_guid' and ".
		    "      p.parent_vers='$template_vers' and ".
		    "      p.name=$name");

    return -1
	if (!$query_result);

    if ($query_result->numrows) {
	($result) = $query_result->fetchrow_array();
    }
    $$prval = $result;
    return 0;
}

#
# Delete (all) template metadata
#
sub DeleteAllMetadata($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    my $query_result =
	DBQueryWarn("select metadata_guid ".
		    "    from experiment_template_metadata ".
		    "where parent_guid='$template_guid' and ".
		    "      parent_vers='$template_vers'");

    return -1
	if (!$query_result);

    while (my ($metadata_guid) = $query_result->fetchrow_array()) {
	my @versions = ();

	#
	# Delete all versions for each record. This is wrong if we ever
	# want to share entries between templates.
	#
	my $metadata_result =
	    DBQueryWarn("select vers from experiment_template_metadata_items ".
			"where guid='$metadata_guid'");

	return -1
	    if (!$metadata_result);

	next
	    if (!$metadata_result->numrows);

	while (my ($metadata_vers) = $metadata_result->fetchrow_array()) {
	    push(@versions, $metadata_vers);
	}

	my $clause = join(" or ", map("vers='$_'", @versions));

	DBQueryWarn("delete from experiment_template_metadata_items ".
		    "where guid='$metadata_guid' and ($clause)")
	    or return -1;
    }
    DBQueryWarn("delete from experiment_template_metadata ".
		"where parent_guid='$template_guid' and ".
		"      parent_vers='$template_vers'")
	or return -1;

    return 0;
}

#
# Delete a specific template metadata item from the template, but we leave
# actual items behind. 
#
sub DeleteMetadata($$)
{
    my ($self, $name) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    $name = DBQuoteSpecial($name);

    my $query_result =
	DBQueryWarn("select metadata_guid,metadata_vers ".
		    "   from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     m.metadata_guid=i.guid and m.metadata_vers=i.vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      i.name=$name");
    
    return -1
	if (!$query_result);
    return -1
	if (!$query_result->numrows);

    my ($metadata_guid, $metadata_vers) = $query_result->fetchrow_array();
    
    DBQueryWarn("update experiment_template_metadata set hidden=1 ".
		"where parent_guid='$template_guid' and ".
		"      parent_vers='$template_vers' and ".
		"      metadata_guid='$metadata_guid' and ".
		"      metadata_vers='$metadata_vers'")
	or return -1;

    return 0;
}

#
# Copy exiting template metadata to a child. This is likely to change
# since we probably want to share at some point.
#
sub CopyMetadata($$$)
{
    my ($self, $parent, $copier) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($parent)));

    my $from_guid = $parent->guid();
    my $from_vers = $parent->vers();
    my $to_vers   = $self->vers();

    #
    # Copy the toplevel items.
    #
    my $query_result =
	DBQueryWarn("select name,value,metadata_type,internal,i.parent_guid ".
		    "  from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     i.guid=m.metadata_guid and ".
		    "     i.vers=m.metadata_vers ".
		    "where m.parent_guid='$from_guid' and ".
		    "      m.parent_vers='$from_vers'")
	or return -1;

    while (my ($name,$value,$type,$internal,$hasparent) =
	   $query_result->fetchrow_array()) {

	my $guid;
	my $version = 1;
	my $metadata_type = "NULL";
	my $parent_guid;
	my $parent_vers;
	
	$name   = DBQuoteSpecial($name);
	$value  = DBQuoteSpecial($value);

	#
	# XXX Some metadata is special ...
	#
	if (defined($type)) {
	    # XXX Skip the tid and template descriptions.
	    next
		if ($type eq "tid" or $type eq "template_description");

	    #
	    # XXX Skip parameters that were deleted or whose description
	    # was modified after being created.
	    #
	    if ($type eq "parameter_description") {
		my $param_result = 
		    DBQueryWarn("select * ".
				"   from experiment_template_parameters ".
				"where parent_guid='$from_guid' and ".
				"      parent_vers='$to_vers' and ".
				"      name=$name");

		return -1
		    if (!$param_result);
		
		next
		    if (!$param_result->numrows);

		#
		# If the current parameter has a metadata description, it
		# came from the NS file parse. If the version we are
		# copying from has no parent, it has not been modified and
		# so we do not want to take that one; use the current one
		# from the NS file instead. If on the other hand the user
		# modified that description after its NS file parse, we take
		# that since we assume its a better description. Hmm, this
		# sounds awful when described.
		#
		my $param_row = $param_result->fetchrow_hashref();

		if (defined($param_row->{"metadata_guid"})) {
		    next
			if (! $hasparent);
		    
		    $parent_guid = $param_row->{"metadata_guid"};
		    $parent_vers = $param_row->{"metadata_vers"};

		    # and of course we need to use this guid/vers.
		    $guid = $parent_guid;
		    $version = $parent_vers + 1;
		}
	    }
	    $metadata_type = "'$type'";
	}

	return -1
	    if (!defined($guid) && NewGUID(\$guid) < 0);

	DBQueryWarn("insert into experiment_template_metadata set ".
		    "   parent_guid='$from_guid', ".
		    "   parent_vers='$to_vers', ".
		    "   metadata_guid='$guid', ".
		    "   metadata_vers='$version', ".
		    "   metadata_type=$metadata_type, ".
		    "   internal=$internal")
	    or return -1;

	DBQueryWarn("insert into experiment_template_metadata_items set ".
		    "   guid='$guid', vers='$version', uid='$copier', ".
		    "   template_guid='$from_guid', ".
		    (! defined($parent_guid) ? "" :
		     "  parent_guid='$parent_guid',".
		     "  parent_vers='$parent_vers',") .
		    "   name=$name, value=$value, created=now()")
	    or return -1;

	#
	# XXX Some metadata is special ...
	#
	if (defined($type)) {
	    if ($type eq "parameter_description") {
		DBQueryWarn("update experiment_template_parameters set ".
			    "   metadata_guid='$guid', ".
			    "   metadata_vers='$version' ".
			    "where parent_guid='$from_guid' and ".
			    "      parent_vers='$to_vers' and ".
			    "      name=$name")
		    or return -1
		}
	}
    }
    return 0;
}

#
# Return a list of metadata. This should be its own object.
#
sub MetadataList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();

    #
    # Copy the toplevel items.
    #
    my $query_result =
	DBQueryWarn("select i.* from experiment_template_metadata as m ".
		    "left join experiment_template_metadata_items as i on ".
		    "     i.guid=m.metadata_guid and ".
		    "     i.vers=m.metadata_vers ".
		    "where m.parent_guid='$template_guid' and ".
		    "      m.parent_vers='$template_vers' and ".
		    "      m.hidden=0 and m.metadata_type is null")
	or return -1;

    while (my $rowref = $query_result->fetchrow_hashref()) {
	my $name	= $rowref->{"name"};
	my $value       = $rowref->{"value"};
	my $guid	= $rowref->{"guid"};
	my $vers	= $rowref->{"vers"};

	my $ref = {'name'   => $name,
		   'value'  => $value,
		   'guid'   => "$guid/$vers"};

	$results{$name} = $ref;
    }
    %$prval = %results;
    return 0;
}

#
# Create a new Instance record, using the package below.
#
sub NewInstance($$$)
{
    my ($self, $eid, $creator) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    # We provide this stuff now.
    my %args = ();
    $args{'parent_guid'} = $self->guid();
    $args{'parent_vers'} = $self->vers();
    $args{'pid'}         = $self->pid();
    $args{'eid'}         = $eid;
    $args{'uid'}         = $creator;

    return Template::Instance->Create(\%args);
}

#
# Lookup specific instance by its exptidx. The point of this is to ensure
# that the instance is really associated with the template, since by itself,
# the exptidx is enough to find the instance record.
#
sub LookupInstance($$)
{
    my ($self, $exptidx) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $instance = Template::Instance->LookupByExptidx($exptidx);
    return undef
	if (!defined($instance));

    return undef
	if (! ($self->guid() == $instance->guid() &&
	       $self->vers() == $instance->vers()));

    return $instance;
}

#
# Generate a list of instances for a template and save in the template
# structure. The argument indicates whether you want just active, or all
# of them (historical).
#
sub InstanceList($$$)
{
    my ($self, $all, $resultp) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $query_result;
    my @instances = ();
    my $guid = $self->guid();
    my $vers = $self->vers();

    if ($all) {
	$query_result = 
	    DBQueryWarn("select idx from experiment_template_instances ".
			"where parent_guid='$guid' and ".
			"      parent_vers='$vers'");
    }
    else {
	$query_result =
	    DBQueryWarn("select i.idx ".
			"  from experiment_template_instances as i ".
			"left join experiments as e on e.idx=i.exptidx ".
			"where i.parent_guid='$guid' and ".
			"      i.parent_vers='$vers' and e.idx is not null");
    }
    return -1
	if (!$query_result);
    
    if (!$query_result->numrows) {
	@$resultp = ();
	return 0;
    }
	
    while (my ($idx) = $query_result->fetchrow_array()) {
	my $instance = Template::Instance->LookupByID($idx);
	return -1
	    if (!defined($instance));
	push(@instances, $instance);
    }

    @$resultp = @instances;
    return 0;
}

#
# Copy the datastore from parent template to child template.
#
sub CopyDataStore($$)
{
    my ($self, $parent) = @_;

    # Must be a real reference. 
    return -1
	if (! (ref($self) && ref($parent)));

    my $from_path = $parent->path();
    my $to_path   = $self->path();

    Template::mysystem("cd $from_path; ".
		       "   $RSYNC -rtgoDlz datastore $to_path") == 0
	or return -1;

    return 0;
}

#
# Import datastore from a directory back into the template. Currently
# used when creating a template from an instance.
#
sub ImportDataStore($$)
{
    my ($self, $from_path) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $to_path = $self->path();

    Template::mysystem("$RSYNC -rtgoDlz ${from_path}/ $to_path/datastore") == 0
	or return -1;

    return 0;
}

#
# Hide Template, optionally hiding all children.
#
sub Hide($$)
{
    my ($self, $recursive) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("update experiment_templates set hidden=1 ".
		"where guid='$guid' and ".
		"      vers='$vers'")
	or return -1;
    
    Refresh($self) == 0
	or return -1;

    if ($recursive) {
	$self->Recurse("hidden=1") == 0
	    or return -1;
    }
    # This can fail; it is not critical.
    Template::mysystem("$makegraph $guid");
    
    return 0;
}

#
# Show Template, optionally showing all children.
#
sub Show($$)
{
    my ($self, $recursive) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("update experiment_templates set hidden=0 ".
		"where guid='$guid' and ".
		"      vers='$vers'")
	or return -1;
    
    Refresh($self) == 0
	or return -1;

    if ($recursive) {
	$self->Recurse("hidden=0") == 0
	    or return -1;
    }
    # This can fail; it is not critical.
    Template::mysystem("$makegraph $guid");
    
    return 0;
}

#
# Activate/InActivate a template. What is an active template? Its one the
# user is futzing with and wants at the top of the list. Inactive templates
# are there but not considered important.
#
sub Activate($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("update experiment_templates set active=1 ".
		"where guid='$guid' and ".
		"      vers='$vers'")
	or return -1;
    
    Refresh($self) == 0
	or return -1;

    return 0;
}
sub InActivate($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    
    DBQueryWarn("update experiment_templates set active=0 ".
		"where guid='$guid' and ".
		"      vers='$vers'")
	or return -1;
    
    Refresh($self) == 0
	or return -1;

    return 0;
}

# Improve this at some point.
sub Recurse($$)
{
    my ($self, $string) = @_;
    my %children = ();

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $template_guid = $self->guid();
    my $template_vers = $self->vers();
    
    my $query_result =
	DBQueryWarn("select vers,parent_vers from experiment_templates ".
		    "where guid='$template_guid' ".
		    "order by vers");
    return -1
	if (!$query_result);

    # Build up lists of childen.
    while (my ($vers,$parent_vers) = $query_result->fetchrow_array()) {
	next
	    if (!defined($parent_vers));

	$children{$parent_vers} = []
	    if (!exists($children{$parent_vers}));
	push(@{ $children{$parent_vers} }, $vers);
    }

    # A leaf node ...
    return 0
	if (!exists($children{$template_vers}));

    # Recurse through all the children of this template.
    my @kids = @{ $children{$template_vers} };

    while (@kids) {
	my $kid     = shift(@kids);

	DBQueryWarn("update experiment_templates set $string ".
		    "where guid='$template_guid' and vers='$kid'")
	    or return -1;

	push(@kids, @{ $children{$kid} })
	    if (exists($children{$kid}));
    }
    return 0;
}

#
# Create directory for template.
#
sub CreateDirectory($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $pid  = $self->pid();
    my $eid  = $self->eid();
    my $gid  = $self->gid();
    my $rval = 0;
    
    my $projroot = PROJROOT();
    my $guiddir  = "$projroot/$pid/templates/$guid";
    my $versdir  = "$guiddir/$vers";

    DBQueryWarn("update experiment_templates set ".
		"  path='$versdir' ".
		"where guid='$guid' and vers='$vers'")
	or return -1;

    # Or else the caller does not see the above change!
    Refresh($self) == 0
	or return -1;

    my $unix_gid;
    my $unix_name;
    
    if (! TBGroupUnixInfo($pid, $gid, \$unix_gid, \$unix_name)) {
	print "*** No info for project/group $pid/$gid!\n";
	return -1;
    }
    if (! -e $guiddir) {
	if (! mkdir($guiddir, 0770) ||
	    ! chmod(0770, "$guiddir") ||
	    ! chown($UID, $unix_gid, "$guiddir")) {
	    $rval = $ERRNO;
	    print "*** Could not create directory $guiddir: $!\n";
	    mysystem("$RMDIR $guiddir")
		if (-e $guiddir);
	    return $rval;
	}
    }
    if (! mkdir($versdir, 0775) ||
	! chmod(0775, "$versdir") ||
	! chown($UID, $unix_gid, "$versdir")) {
	$rval = $ERRNO;
	print "*** Could not create directory $versdir: $!\n";
	return $rval;
    }
    foreach my $token ("tbdata", "archive", "datastore", "logs") {
	my $dir = "$versdir/$token";
	
	if (! mkdir($dir, 0770) ||
	    ! chmod(0770, "$dir")) {
	    $rval = $ERRNO;
	    print "*** Could not create directory $dir: $!\n";
	    return $rval;
	}
    }

    my $workdir = TBExptWorkDir($pid, $eid);

    #
    # We need this cause a template has an experiment sitting underneath it.
    #
    if (-e $workdir) {
	print "*** $workdir already exists!\n";
	return -1;
    }
    if (! mkdir($workdir, 0775) ||
	! chown($UID, $unix_gid, "$workdir")) {
	print "*** Could not create $workdir: $!\n";
	return -1;
    }
    
    return 0;
}

############################################################################

package Template::Instance;
use libdb;
use libtestbed;
use libtblog;
use English;
use libArchive;
use overload ('""' => 'Stringify');

# Flags for functions below.
sub STARTRUN_FLAGS_FIRSTRUN()	{ return Template::STARTRUN_FLAGS_FIRSTRUN(); }
sub STARTRUN_FLAGS_SWAPMOD()	{ return Template::STARTRUN_FLAGS_SWAPMOD(); }

#
# Lookup a template experiment and create a class instance to return.
#
sub LookupByID($$)
{
    my ($class, $idx) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_template_instances ".
		    "where idx='$idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the template.
    my $template_guid   = $self->{'DB'}->{'parent_guid'};
    my $template_vers   = $self->{'DB'}->{'parent_vers'};
    my $template        = Template->Lookup($template_guid, $template_vers);
    return undef
	if (!defined($template));
    $self->{'TEMPLATE'} = $template;

    bless($self, $class);
    return $self;
}
sub LookupByExptidx($$)
{
    my ($class, $exptidx) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_template_instances ".
		    "where exptidx='$exptidx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the template.
    my $template_guid   = $self->{'DB'}->{'parent_guid'};
    my $template_vers   = $self->{'DB'}->{'parent_vers'};
    my $template        = Template->Lookup($template_guid, $template_vers);
    return undef
	if (!defined($template));
    $self->{'TEMPLATE'} = $template;
    
    bless($self, $class);
    return $self;
}

#
# Create a new template instance record. This installs the new record
# in the DB, and returns a class instance. 
#
sub Create($$)
{
    my ($class, $argref) = @_;

    return undef
	if (ref($class));

    my $query = "insert into experiment_template_instances set ".
	join(",", map("$_='" . $argref->{$_} . "'", keys(%{$argref})));

    # Give it an initial start time; updated later.
    $query .= ", "
	if (defined($argref) && scalar(keys%{$argref}));
    $query .= "start_time=now(),continue_time=now() ";

    my $query_result = DBQueryWarn($query);
    return undef
	if (! $query_result);

    # Grab the insert record.
    my $idx = $query_result->insertid;

    return Template::Instance->LookupByID($idx);
}
# accessors
sub field($$) { return ((! ref($_[0])) ? -1 : $_[0]->{'DB'}->{$_[1]}); }
sub idx($)           { return field($_[0], 'idx'); }
sub exptidx($)       { return field($_[0], 'exptidx'); }
sub guid($)          { return field($_[0], 'parent_guid');}
sub vers($)          { return field($_[0], 'parent_vers');}
sub pid($)           { return field($_[0], 'pid'); }
sub eid($)           { return field($_[0], 'eid'); }
sub uid($)           { return field($_[0], 'uid'); }
sub runidx($)        { return field($_[0], 'runidx'); }
sub start_time($)    { return field($_[0], 'start_time'); }
sub stop_time($)     { return field($_[0], 'stop_time'); }
sub pause_time($)    { return field($_[0], 'pause_time'); }
sub continue_time($) { return field($_[0], 'continue_time'); }
sub runtime($)       { return field($_[0], 'runtime'); }
sub template($)      { return ((!ref($_[0])) ? -1 : $_[0]->{'TEMPLATE'}); }

# The path is the path of the experiment.
sub path($)    { return TBExptUserDir($_[0]->pid(), $_[0]->eid()); }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self)  = @_;
    my $guid    = $self->guid();
    my $vers    = $self->vers();
    my $idx     = $self->idx();
    my $exptidx = $self->exptidx();
    my $eid     = $self->eid();

    return "[Instance:$idx exptidx:$exptidx Template:$guid/$vers]";
}

#
# Refresh instance by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    my $query_result =
	DBQueryWarn("select * from experiment_template_instances ".
		    "where idx='$idx'");

    return -1
	if (!$query_result || !$query_result->numrows);
	
    $self->{'DB'} = $query_result->fetchrow_hashref();
    return 0;
}

#
# Update an instance record.
#
sub Update($$;$)
{
    my ($self, $start_time, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx   = $self->idx();
    my $query = "update experiment_template_instances set ";

    $query .= "start_time=now(),continue_time=now(),runtime=0 "
	if ($start_time);

    if (defined($argref) && scalar(keys%{$argref})) {
	$query .= ","
	    if ($start_time);
	
	$query .= join(",",
		       map("$_='" . $argref->{$_} . "'", keys(%{$argref})));
    }
    $query .= " where idx='$idx'";

    return -1
	if (! DBQueryWarn($query));

    return Refresh($self);
}
# Set the start time ...
sub Start($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    return $self->Update(1);
}
# Set the stop time ...
sub Stop($;$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    #
    # Do the Run record first
    #
    my $runidx = $self->runidx();

    return -1
	if (defined($runidx) && StopCurrentRun($self) < 0);

    # And then the instance.
    DBQueryWarn("update experiment_template_instances set stop_time=now() ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Finalize.
#
sub Finalize($;$)
{
    my ($self, $argref) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx = $self->idx();
    
    #
    # Do the Run record first
    #
    my $runidx = $self->runidx();

    return -1
	if (defined($runidx) && FinalizeCurrentRun($self) < 0);

    return Refresh($self);
}

#
# Is an instance currently instantiated (a current experiment).
#
sub Instantiated($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select pid,eid from experiments where idx='$exptidx'");

    return -1
	if (! $query_result);

    return $query_result->numrows;
}

#
# Return the underlying experiment object.
#
sub Experiment($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    return Experiment->LookupByIndex($self->exptidx());
}

#
# Delete a template instance record.
#
sub Delete($$$)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid    = $self->guid();
    my $vers    = $self->vers();
    my $idx     = $self->idx();
    my $exptidx = $self->exptidx();

    #
    # Delete the run records first since they will not mean much after
    # this record is gone.
    #
    DBQueryWarn("delete from experiment_run_bindings ".
		"where exptidx='$exptidx'")
	or return -1;

    DBQueryWarn("delete from experiment_runs ".
		"where exptidx='$exptidx'")
	or return -1;

    #
    # Also delete the binding records for the instance.
    #
    DeleteBindings($self) == 0
	or return -1;

    # And finally the instance record.
    DBQueryWarn("delete from experiment_template_instances ".
		"where idx='$idx'")
	or return -1;

    $self->{'DB'} = undef;
    return 0;
}

#
# Binding records are part of an instance, and we do not actually mess
# with them after we create them. Just need to be able to delete them,
# as when we have a failure.
#
sub NewBinding($$)
{
    my ($self, $name, $value) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $parent_guid  = $self->guid();
    my $parent_vers  = $self->vers();
    my $pid          = $self->pid();
    my $eid          = $self->eid();
    my $instance_idx = $self->idx();

    if (defined($value)) {
	$value = DBQuoteSpecial($value);
    }
    else {
	$value = "''";
    }

    DBQueryWarn("insert into experiment_template_instance_bindings set ".
		"    name='$name', value=$value, ".
		"    parent_guid='$parent_guid',parent_vers='$parent_vers', ".
		"    pid='$pid', eid='$eid', instance_idx='$instance_idx'")
	or return -1;
    
    return 0;
}

#
# Get list of bindings for the instance (the values at swapin time).
#
sub BindingList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $guid = $self->guid();
    my $vers = $self->vers();
    my $idx  = $self->idx();

    my $query_result =
	DBQueryWarn("select name,value ".
		    "   from experiment_template_instance_bindings ".
		    "where instance_idx='$idx' and ".
		    "      parent_guid='$guid' and ".
		    "      parent_vers='$vers'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

sub DeleteBindings($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $idx  = $self->idx();

    DBQueryWarn("delete from experiment_template_instance_bindings ".
		"where instance_idx='$idx'")
	or return -1;

    return 0;
}

#
# Run records are also integral to Template Instances. 
#
sub NewRun($$;$)
{
    my ($self, $runid, $description) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $run = Template::Instance::Run->Create($self, $runid, $description);
    return undef
	if (! defined($run));

    # Grab the run idx and store that back into the instance since it
    # is now the current run.
    my $runidx = $run->idx();
    my $idx    = $self->idx();

    if (! DBQueryWarn("update experiment_template_instances set ".
		      "  runidx='$runidx' ".
		      "where idx='$idx'")) {
	$run->Delete();
	return undef;
    }
    Refresh($self);
    return $run;
}

#
# Lookup a run by its runid.
#
sub LookupRun($$)
{
    my ($self, $runid) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();

    return Template::Instance::Run->LookupByRunID($exptidx, $runid);
}

#
# Delete the current run record.
#
sub DeleteCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();

    return 0
	if (!defined($runidx));

    DBQueryWarn("delete from experiment_run_bindings ".
		"where exptidx='$exptidx' and runidx='$runidx'")
	or return -1;

    DBQueryWarn("delete from experiment_runs ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;
    
    DBQueryWarn("delete from experiment_template_instance_deadnodes ".
		"where instance_idx='$idx' and runidx='$runidx'")
	or return -1;
    
    DBQueryWarn("update experiment_template_instances set runidx=NULL ".
		"where idx='$idx'")
	or return -1;

    return Refresh($self);
}

#
# Pause and Continue time, keeping track of running time. 
#
sub PauseTime($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    if ($self->pause_time()) {
	tbwarn("$self is already paused!\n");
	return -1;
    }
    if (!defined($self->continue_time())) {
	tbwarn("PauseTime: $self is in an inconsistent state!\n");
	return -1;
    }

    my $idx    = $self->idx();

    DBQueryWarn("update experiment_template_instances set ".
		"   runtime=runtime + ".
		"    (UNIX_TIMESTAMP(now())-UNIX_TIMESTAMP(continue_time)), ".
		"   continue_time=NULL, ".		
		"   pause_time=now() ".
		"where idx='$idx'")
	or return -1;

    return Refresh($self);
}
sub ContinueTime($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    if (! defined($self->pause_time())) {
	tbwarn("$self is not paused!\n");
	return -1;
    }
    if (defined($self->continue_time())) {
	tbwarn("PauseTime: $self is in an inconsistent state!\n");
	return -1;
    }

    my $idx = $self->idx();

    DBQueryWarn("update experiment_template_instances set ".
		"   continue_time=now(), ".
		"   pause_time=NULL ".
		"where idx='$idx'")
	or return -1;

    return Refresh($self);
}
sub AdjustTimeStamp($$$)
{
    my ($self, $timestamp, $peventtime) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx    = $self->idx();

    if ($self->pause_time()) {
	# If paused, the event runs at the difference between now() and the
	# timestamp provided.
	$$peventtime = $self->runtime() + (time() - $timestamp);
    }
    else {
	# Running. Need to calculate current runtime.
	
	my $query_result =
	    DBQueryWarn("select runtime + ".
			"         (UNIX_TIMESTAMP(now()) - ".
			"          UNIX_TIMESTAMP(continue_time)) ".
			"  from experiment_template_instances ".
			"where idx='$idx'");

	return -1
	    if (!$query_result || !$query_result->numrows);

	my ($t) = $query_result->fetchrow_array();

	$$peventtime = $t + (time() - $timestamp);
    }
    return 0;
}

#
# Start the (first) experiment run.
#
sub StartRun($;$)
{
    my ($self, $flags) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    $flags = 0
	if (!defined($flags));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();
    my $clause  = (($flags & STARTRUN_FLAGS_SWAPMOD()) ? ", swapmod=1 " : "");
    my $archive_tag;

    #
    # Grab the current archive tag.
    #
    return -1
	if (ArchiveTag($self, \$archive_tag) < 0);
    
    DBQueryWarn("update experiment_runs set start_time=now(), ".
		"       starting_archive_tag='$archive_tag' $clause ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    return $self->Start()
	if ($flags & STARTRUN_FLAGS_FIRSTRUN());
    
    return 0;
}

#
# Stop the current experiment run,
#
sub StopCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();

    return -1
	if (!defined($runidx));

    DBQueryWarn("update experiment_runs set stop_time=now() ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    return Refresh($self);
}

#
# Finalize the current experiment run record.
#
sub FinalizeCurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $runidx  = $self->runidx();
    my $exptidx = $self->exptidx();
    my $archive_tag;

    return -1
	if (!defined($runidx));

    #
    # Grab the current archive tag.
    #
    return -1
	if (ArchiveTag($self, \$archive_tag) < 0);
    
    DBQueryWarn("update experiment_runs set ".
		"  ending_archive_tag='$archive_tag' ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    DBQueryWarn("update experiment_template_instances set runidx=NULL ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Need to make "run" its own object ...
#
# Return an array of runs, indexed by its idx.
#
sub RunList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select * from experiment_runs ".
		    "where exptidx='$exptidx'");

    return -1
	if (!$query_result);

    while (my $rowref = $query_result->fetchrow_hashref()) {
	$results{$rowref->{'idx'}} = $rowref;
    }
    %$prval = %results;
    return 0;
}

#
# Return the last run for an instance, after the instance is gone.
#
sub LastRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select * from experiment_runs ".
		    "where exptidx='$exptidx' order by idx desc limit 1");

    return undef
	if (!$query_result);

    return $query_result->fetchrow_hashref();
}
sub FirstRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select * from experiment_runs ".
		    "where exptidx='$exptidx' order by idx asc limit 1");

    return undef
	if (!$query_result);

    return $query_result->fetchrow_hashref();
}

#
# Return current run.
#
sub CurrentRun($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return undef
	if (! ref($self));

    my $exptidx = $self->exptidx();
    my $runidx  = $self->runidx();

    return undef
	if (!defined($runidx));

    my $query_result =
	DBQueryWarn("select * from experiment_runs ".
		    "where exptidx='$exptidx' and idx='$runidx'");

    return undef
	if (!$query_result);

    return $query_result->fetchrow_hashref();
}

#
# Binding records for each Run.
#
sub NewRunBinding($$$)
{
    my ($self, $name, $value) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    # We provide this stuff now.
    my $exptidx = $self->exptidx();
    my $runidx  = $self->runidx();
    my $pid     = $self->pid();
    my $eid     = $self->eid();

    if (defined($value)) {
	$value = DBQuoteSpecial($value);
    }
    else {
	$value = "''";
    }

    DBQueryWarn("insert into experiment_run_bindings set ".
		"  exptidx='$exptidx', runidx='$runidx', ".
		"  name='$name', value=$value")
	or return -1;

    DBQueryWarn("replace into virt_user_environment set ".
		"   name='$name', value=$value, ".
		"   pid='$pid', eid='$eid'")
	or return -1;
    
    return 0;
}

#
# Get list of bindings for the current run.
#
sub RunBindingList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $exptidx = $self->exptidx();
    my $runidx  = $self->runidx();

    if (! defined($runidx)) {
	#
	# This happens when called during initial swapin.
	#
	%$prval = %results;
	return 0;
    }

    my $query_result =
	DBQueryWarn("select name,value ".
		    "   from experiment_run_bindings ".
		    "where exptidx='$exptidx' and runidx='$runidx'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

#
# Make up a new run name based on the previous run name.
#
sub NewRunID($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();
    my $lastname;
    my $newname;

    my $query_result =
	DBQueryWarn("select MAX(idx) from experiment_runs ".
		    "where exptidx='$exptidx'");

    return -1
	if (!$query_result || !$query_result->numrows);

    my ($maxidx) = $query_result->fetchrow_array();

    if (defined($self->runidx())) {
	my $this_run = $self->CurrentRun();

	$lastname = $this_run->{"runid"};
    }
    else {
	my $last_run = $self->LastRun();

	$lastname = $last_run->{"runid"};
    }

    #
    # Look for the typical "-RX" extension and increment X. Otherwise append
    # a -RX where X is the max run number plus one.
    #
    if ($lastname =~ /^([\w]*)\-R(\d*)$/) {
	$newname = $1 . "-R" . ($maxidx + 1);
    }
    else {
	$newname = $lastname . "-R" . ($maxidx + 1);
    }
    $$prval = $newname;
    return 0;
}

#
# Use tevc to tell loghole to sync. We have to send a bunch of extra args
# to get loghole to do what we want.
#
sub LogHole($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $pid        = $self->pid();
    my $eid        = $self->eid();
    my $userdir    = TBExptUserDir($pid, $eid);
    my $archivedir = libArchive::TBUserFileArchiveDirectory($pid, $eid);
    my $logdir     = "$archivedir/logs";

    if (! -e $logdir) {
	mkdir($logdir, 0775)
	    or return -1;
    }

    #
    # Do the loghole thing.
    #
    Template::mysystem("$TEVC -w -t 300 -e $pid/$eid now ns SNAPSHOT ".
		       "    LOGHOLE_ARGS='-s'") == 0
       or return -1;

    #
    # Copy the experiment logs directory into the archive. 
    # 
    Template::mysystem("cd $userdir; ".
		       "   $RSYNC -rtgoDlz --delete logs $archivedir") == 0
	or return -1;

    return 0;
}

#
# Use tevc to tell loghole to clean.
#
sub LogClean($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $pid        = $self->pid();
    my $eid        = $self->eid();

    #
    # Do the loghole thing.
    #
    Template::mysystem("$TEVC -w -t 300 -e $pid/$eid now ns RESET") == 0
	or return -1;

    return 0;
}

#
# Dump the instance DB into the archive directory.
#
sub DumpDB($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $pid     = $self->pid();
    my $eid     = $self->eid();

    my $archivedir = libArchive::TBUserFileArchiveDirectory($pid, $eid);
    # The file is a gzipped.
    my $dumpdir    = "$archivedir/dbdata";
    my $dumpfile   = "$dumpdir/dbdump.gz";

    if (! -e $dumpdir) {
	mkdir($dumpdir, 0775)
	    or return -1;
    }

    Template::mysystem("$DBCONTROL dumpexpdb $pid $eid $dumpfile") == 0
	or return -1;

    return 0;
}

#
# Clean the instance DB.
#
sub CleanDB($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $pid     = $self->pid();
    my $eid     = $self->eid();

    Template::mysystem("$DBCONTROL cleanexpdb $pid $eid") == 0
	or return -1;

    return 0;
}

#
# Grab the current archive tag. I think this info belongs in the instance
# record.
#
sub ArchiveTag($$)
{
    my ($self, $ptag) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();

    #
    # Grab the current archive tag. This will correspond to the commit
    # done at the end of the run.
    #
    my $query_result =
	DBQueryWarn("select r.archive_tag from experiment_stats as s ".
		    "left join experiment_resources as r on ".
		    "     r.idx=s.rsrcidx ".
		    "where s.exptidx='$exptidx'");
    return -1
	if (!$query_result || !$query_result->numrows);

    my ($archive_tag) = $query_result->fetchrow_array();

    return -1
	if (!defined($archive_tag));

    $$ptag = $archive_tag;

    return 0;
}

#
# Copy the datastore from the template down to the instance. Temporary ...
#
sub CopyDataStore($$$;$)
{
    my ($self, $archive_tag, $to_path, $replay_instance) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    # From the template itself. 
    my $exptidx;

    if (defined($replay_instance)) {
	$exptidx = $replay_instance->exptidx();
    }
    else {
	TBExptIDX($self->template()->pid(),
		  $self->template()->eid(), \$exptidx)
	    or return -1;
    }

    if (! -e $to_path) {
	Template::mysystem("mkdir -p $to_path") == 0
	    or return -1;
    }

    libArchive::setdebug(2);

    libArchive::TBCheckoutExperimentArchivebyExptIDX($exptidx,
						     $to_path,
						     $archive_tag,
						     "datastore")
	== 0 or return -1;
    
    return 0;
}

#
# Update the export time.
#
sub UpdateExportTime($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();

    DBQueryWarn("update experiment_template_instances set export_time=now() ".
		"where idx='$idx'")
	or return -1;
    
    return Refresh($self);
}

#
# Add a dynamic event. A total hack.
#
sub AddEvent($$$$)
{
    my ($self, $timestamp, $vnode, $commandline) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $pid  = $self->pid();
    my $eid  = $self->eid();
    my $cmd  = DBQuoteSpecial("COMMAND=$commandline");

    #
    # Need to adjust the timestamp to account for stopped time. This also
    # converts from absolute to relative event time.
    #
    my $firetime;
    
    $self->AdjustTimeStamp($timestamp, \$firetime) == 0
	or return -1;

    # We assume program agent events right now. Change later.
    my $query_result =
	DBQueryWarn("select idx from event_objecttypes ".
		    "where type='PROGRAM' or type='SEQUENCE' order by type");
    return -1
	if (!$query_result || $query_result->numrows != 2);

    my ($program_objecttype)  = $query_result->fetchrow_array();
    my ($sequence_objecttype) = $query_result->fetchrow_array();

    # And its a start event of course.
    $query_result =
	DBQueryWarn("select idx from event_eventtypes where type='START'");
    return -1
	if (!$query_result || ! $query_result->numrows);
    my ($event_eventtype) = $query_result->fetchrow_array();

    #
    # We need an event sequence to properly order sequential events. 
    #
    my $sequence_name = "${vnode}_record";

    $query_result =
	DBQueryWarn("select * from virt_agents ".
		    "where pid='$pid' and eid='$eid' and ".
		    "      vname='$sequence_name'");
    return -1
	if (!$query_result);

    if (! $query_result->numrows) {
	DBQueryWarn("replace into virt_agents set ".
		    "  pid='$pid', eid='$eid', ".
		    "  vnode='*', vname='$sequence_name', ".
		    "  objecttype='$sequence_objecttype'")
	    or return -1;
	
	if (! DBQueryWarn("insert into eventlist set ".
			  "  pid='$pid', eid='$eid', time='0', ".
			  "  vnode='$vnode', vname='$sequence_name', ".
			  "  objecttype='$sequence_objecttype', ".
			  "  eventtype='$event_eventtype', ".
			  "  atstring='', arguments=''")) {
	    
	    DBQueryWarn("delete from virt_agents ".
			"where pid='$pid' and eid='$eid' and ".
			"      vname='$sequence_name'");
	    return -1;
	}
    }

    # Make up a vname.
    my $vname = "dprog" . $firetime;

    #
    # Add the event to the static event stream for the instance experiment.
    #
    $query_result = 
	DBQueryWarn("insert into eventlist set ".
		    "  pid='$pid', eid='$eid', time='$firetime', ".
		    "  vnode='$vnode', vname='$vname', ".
		    "  objecttype='$program_objecttype', ".
		    "  eventtype='$event_eventtype', ".
		    "  atstring='', arguments=$cmd, ".
		    "  parent='$sequence_name'");
    return -1
	if (!$query_result || ! $query_result->numrows);

    # Grab the new idx just in case we need to delete.
    my $eventidx = $query_result->insertid;

    # Need a virt_agent entry.
    if (!DBQueryWarn("insert into virt_agents set ".
		     "  pid='$pid', eid='$eid', ".
		     "  vnode='$vnode', vname='$vname', ".
		     "  objecttype='$program_objecttype'")) {
	DBQueryWarn("delete from eventlist ".
		    "where pid='$pid' and eid='$eid' and idx='$eventidx'");
	return -1;
    }

    # Need a virt_programs entry.
    if (!DBQueryWarn("insert into virt_programs set ".
		     "  pid='$pid', eid='$eid', ".
		     "  vnode='$vnode', vname='$vname', ".
		     "  dir='', timeout=0, expected_exit_code=0, ".
		     "  command=$cmd")) {
	DBQueryWarn("delete from virt_programs ".
		    "where pid='$pid' and eid='$eid' and ".
		    "      vnode='$vnode' and vname='$vname'");
	DBQueryWarn("delete from eventlist ".
		    "where pid='$pid' and eid='$eid' and idx='$eventidx'");
	return -1;
    }

    # Add to template event list; we will need to hand copy these into
    # the eventlist for new instances as they are created.
    if (!DBQueryWarn("insert into experiment_template_events set ".
		     "  parent_guid='$guid', parent_vers='$vers', ".
		     "  time='$firetime', ".
		     "  vnode='$vnode', vname='$vname', ".
		     "  objecttype='$program_objecttype', ".
		     "  eventtype='$event_eventtype', ".
		     "  arguments=$cmd")) {
	DBQueryWarn("delete from eventlist ".
		    "where pid='$pid' and eid='$eid' and idx='$eventidx'");
	DBQueryWarn("delete from virt_agents ".
		    "where pid='$pid' and eid='$eid' and ".
		    "      vnode='$vnode' and vname='$vname'");
	DBQueryWarn("delete from virt_programs ".
		    "where pid='$pid' and eid='$eid' and ".
		    "      vnode='$vnode' and vname='$vname'");
	return -1;
    }

    return 0;
}

#
# Copy the events from the template to the instance.
#
sub CopyTemplateEvents($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $guid = $self->guid();
    my $vers = $self->vers();
    my $pid  = $self->pid();
    my $eid  = $self->eid();

    # Need to insert a sequence to wrap these.
    my $query_result =
	DBQueryWarn("select idx from event_objecttypes where type='SEQUENCE'");
    return -1
	if (!$query_result || !$query_result->numrows);
    my ($sequence_objecttype) = $query_result->fetchrow_array();

    # And its a start event of course.
    $query_result =
	DBQueryWarn("select idx from event_eventtypes where type='START'");
    return -1
	if (!$query_result || ! $query_result->numrows);
    my ($start_eventtype) = $query_result->fetchrow_array();

    # Now process the template events.
    $query_result =
	DBQueryWarn("select * from experiment_template_events ".
		    "where parent_guid='$guid' and parent_vers='$vers'");
    
    return -1
	if (!$query_result);

    while (my $rowref = $query_result->fetchrow_hashref()) {
	my $vnode            = $rowref->{"vnode"};
	my $firetime         = $rowref->{"time"};
	my $vname            = $rowref->{"vname"};
	my $event_objecttype = $rowref->{"objecttype"};
	my $event_eventtype  = $rowref->{"eventtype"};
	my $cmd              = DBQuoteSpecial($rowref->{"arguments"});
	my $sequence_name    = "${vnode}_record";

	my $agent_result =
	    DBQueryWarn("select * from virt_agents ".
			"where pid='$pid' and eid='$eid' and ".
			"      vname='$sequence_name'");
	return -1
	    if (!$agent_result);
	
	if (! $agent_result->numrows) {
	    DBQueryWarn("replace into virt_agents set ".
			"  pid='$pid', eid='$eid', ".
			"  vnode='*', vname='$sequence_name', ".
			"  objecttype='$sequence_objecttype'")
		or return -1;

	    DBQueryWarn("insert into eventlist set ".
			"  pid='$pid', eid='$eid', time='0', ".
			"  vnode='$vnode', vname='$sequence_name', ".
			"  objecttype='$sequence_objecttype', ".
			"  eventtype='$start_eventtype', ".
			"  atstring='', arguments=''")
		or return -1;
	}

	#
	# Any failure and and the instance will be killed by the
	# caller, so no need to clean up any mess created below.
	#
	DBQueryWarn("insert into eventlist set ".
		    "  pid='$pid', eid='$eid', time='$firetime', ".
		    "  vnode='$vnode', vname='$vname', ".
		    "  objecttype='$event_objecttype', ".
		    "  eventtype='$event_eventtype', ".
		    "  atstring='', arguments=$cmd, ".
		    "  parent='$sequence_name'")
	    or return -1;

	# Need a virt_agent entry.
	DBQueryWarn("insert into virt_agents set ".
		    "  pid='$pid', eid='$eid', ".
		    "  vnode='$vnode', vname='$vname', ".
		    "  objecttype='$event_objecttype'")
	    or return -1;
	    
	# Need a virt_programs entry.
	DBQueryWarn("insert into virt_programs set ".
		    "  pid='$pid', eid='$eid', ".
		    "  vnode='$vnode', vname='$vname', ".
		    "  dir='', timeout=0, expected_exit_code=0, ".
		    "  command=$cmd")
	    or return -1;
    }
    return 0;
}

#
# Create a log file for an instance, in the template directory.
#
sub CreateLogFile($$$)
{
    my($self, $token, $ppath) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $idx     = $self->idx();
    my $path    = $self->template()->path();
    my $logdir  = "$path/logs";
    my $logname = "$logdir/instance${idx}.${token}";

    return -1
	if (-e $logname);

    return -1
	if (! -d $logdir && !mkdir($logdir, 0775));

    Template::mysystem("touch $logname") == 0
	    or return -1;

    $$ppath = $logname;
    return 0;
}

sub WriteEnvVariables($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $experiment = $self->Experiment();

    return -1
	if (! defined($experiment));

    return $experiment->WriteEnvVariables();
}

sub WriteProgramAgents($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $experiment = $self->Experiment();

    return -1
	if (! defined($experiment));

    return $experiment->WriteProgramAgents();
}

#
# Setup the environment variables for a template swapin.
#
sub InitializeEnvVariables($;$)
{
    my ($self, $parameters) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $experiment    = $self->Experiment();
    my $instance_path = $self->path();
    my $pid           = $self->pid();
    my $eid           = $self->eid();
    my $dbuid         = $self->uid();

    return -1
	if (! defined($experiment));

    #
    # Ick, Ick, Ick. I want these to be at the beginning of the enviroment
    # strings so they are set in case the user has used any OPT variables
    # in the NS file (and they refer to $DATASTORE or $ARCHIVE).
    #
    my $query_result =
	DBQueryWarn("select MAX(idx) from virt_user_environment ".
		    "where pid='$pid' and eid='$eid'");
    return -1
	if (!$query_result);

    my ($maxenv) = $query_result->fetchrow_array();

    if ($maxenv) {
	for (my $idx = $maxenv; $idx > 0; $idx--) {
	    my $newidx = $idx + 2;
    
	    DBQueryFatal("update virt_user_environment set idx=$newidx ".
			 "where idx='$idx' and pid='$pid' and eid='$eid'");
	}
    }
    $experiment->AddEnvVariable("DATASTORE",
				"$instance_path/datastore", 1)
	== 0 or return -1;
				    
    $experiment->AddEnvVariable("ARCHIVE",
				"$instance_path/archive", 2)
	== 0 or return -1;

    # Now safe to do the rest.
    #
    # Before we actually swapin, copy the parameters to the environment
    # table so that they are available to the program agent when it starts up
    # on the nodes.
    #
    if (defined($parameters)) {
	foreach my $name (keys(%{ $parameters })) {
	    my $value = $parameters->{$name};

	    $experiment->AddEnvVariable($name, $value) == 0
		or return -1;
	}
    }
    return 0;
}

############################################################################

package Template::Instance::Run;
use libdb;
use libtestbed;
use libtblog;
use English;
use libArchive;
use overload ('""' => 'Stringify');

# Flags for functions below.
sub STARTRUN_FLAGS_FIRSTRUN()	{ return Template::STARTRUN_FLAGS_FIRSTRUN(); }
sub STARTRUN_FLAGS_SWAPMOD()	{ return Template::STARTRUN_FLAGS_SWAPMOD(); }

#
# Stringify for output.
#
sub Stringify($)
{
    my ($self)  = @_;
    my $guid    = $self->instance()->template()->guid();
    my $vers    = $self->instance()->template()->vers();
    my $exptidx = $self->exptidx();
    my $runid   = $self->runid();

    return "[Run:$runid exptidx:$exptidx Template:$guid/$vers]";
}

#
# Create a new run object.
#
sub Create($$$;$)
{
    my ($class, $instance, $runid, $description) = @_;

    return undef
	if (ref($class));

    my $exptidx = $instance->exptidx();
    my $dclause = "";

    if (defined($description) && $description ne "") {
	$description = DBQuoteSpecial($description);
	$dclause     = "description=$description , ";
    }

    my $query_result =
	DBQueryWarn("insert into experiment_runs set ".
		    "   $dclause exptidx='$exptidx', runid='$runid' ");

    return undef
	if (! $query_result);

    # Grab the insert record.
    my $runidx = $query_result->insertid;

    return Template::Instance::Run->LookupByID($exptidx, $runidx);
}

sub Delete($)
{
    my ($self) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $runidx  = $self->idx();
    my $exptidx = $self->exptidx();
    my $instance_idx = $self->instance()->idx();

    DBQueryWarn("delete from experiment_run_bindings ".
		"where exptidx='$exptidx' and runidx='$runidx'")
	or return -1;

    DBQueryWarn("delete from experiment_runs ".
		"where exptidx='$exptidx' and idx='$runidx'")
	or return -1;

    DBQueryWarn("delete from experiment_template_instance_deadnodes ".
		"where instance_idx='$instance_idx' and runidx='$runidx'")
	or return -1;
    
    return 0;
}

#
# Lookup a run by its experiment idx and run idx within the experiment.
#
sub LookupByID($$$)
{
    my ($class, $exptidx, $idx) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_runs ".
		    "where exptidx='$exptidx' and idx='$idx'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the instance
    my $instance        = Template::Instance->LookupByExptidx($exptidx);
    return undef
	if (!defined($instance));
    $self->{'INSTANCE'} = $instance;

    bless($self, $class);
    return $self;
}

#
# Lookup a run by its experiment idx and run ID.
#
sub LookupByRunID($$$)
{
    my ($class, $exptidx, $runid) = @_;

    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_runs ".
		    "where exptidx='$exptidx' and runid='$runid'");

    return undef
	if (!$query_result || !$query_result->numrows);

    my $self            = {};
    $self->{'DB'}       = $query_result->fetchrow_hashref();

    # Backlink to the instance
    my $instance        = Template::Instance->LookupByExptidx($exptidx);
    return undef
	if (!defined($instance));
    $self->{'INSTANCE'} = $instance;

    bless($self, $class);
    return $self;
}

# accessors
sub field($$)  { return ((! ref($_[0])) ? -1 : $_[0]->{'DB'}->{$_[1]}); }
sub idx($)     { return field($_[0], 'idx'); }
sub exptidx($) { return field($_[0], 'exptidx'); }
sub runid($)   { return field($_[0], 'runid'); }
sub start_time { return field($_[0], 'start_time'); }
sub stop_time  { return field($_[0], 'stop_time'); }
sub start_tag  { return field($_[0], 'starting_archive_tag'); }
sub stop_tag   { return field($_[0], 'ending_archive_tag'); }
sub instance($){ return ((!ref($_[0])) ? -1 : $_[0]->{'INSTANCE'}); }
sub template($){ return ((!ref($_[0])) ? -1 : instance($_[0])->template()); }

#
# Refresh by reloading from the DB.
#
sub Refresh($)
{
    my ($self) = @_;

    return -1
	if (! ref($self));

    my $exptidx = $self->exptidx();
    my $idx     = $self->idx();
    
    my $query_result =
	DBQueryWarn("select * ".
		    "  from experiment_runs ".
		    "where exptidx='$exptidx' and idx='$idx'");

    return -1
	if (!$query_result || !$query_result->numrows);
	
    $self->{'DB'} = $query_result->fetchrow_hashref();
    return 0;
}

#
# Get list of bindings for the run.
#
sub BindingList($$)
{
    my ($self, $prval) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my %results = ();
    my $runidx  = $self->idx();
    my $exptidx = $self->exptidx();

    my $query_result =
	DBQueryWarn("select name,value ".
		    "   from experiment_run_bindings ".
		    "where runidx='$runidx' and exptidx='$exptidx'");

    return -1
	if (!$query_result);

    while (my ($name,$value) = $query_result->fetchrow_array()) {
	$results{$name} = $value;
    }
    %$prval = %results;
    return 0;
}

#
# Mark a node as dead for this run; this is recorded in the DB.
#
sub MarkNodeDead($$)
{
    my ($self, $node_id) = @_;

    # Must be a real reference. 
    return -1
	if (! ref($self));

    my $runidx       = $self->idx();
    my $instance_idx = $self->instance()->idx();
    my $exptidx      = $self->exptidx();

    # Need the vname;
    my $query_result =
	DBQueryWarn("select vname from reserved ".
		    "where node_id='$node_id'");
    return -1
	if (!$query_result || !$query_result->numrows);

    my ($vname) = $query_result->fetchrow_array();

    return -1
	if (!defined($vname));

    DBQueryWarn("replace into experiment_template_instance_deadnodes set ".
		"  instance_idx='$instance_idx', exptidx='$exptidx', ".
		"  runidx='$runidx', node_id='$node_id', vname='$vname'")
	or return -1;

    return 0;
}

# _Always_ make sure that this 1 is at the end of the file...

1;

