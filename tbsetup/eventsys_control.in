#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;
use POSIX ":sys_wait_h";

#
# Start/Stop the event scheduler for an experiment. This script is
# setuid so that the stop function can send a signal regardless of
# who is running the script (must have appropriate permission of course).
# This is temporary; we eventually want to use the event system to control
# the event system, but lets see how well this event stuff works first.
#
sub usage()
{
    print STDOUT
	"Usage: eventsys_control [-f] <start|stop|replay> <pid> <eid>\n";
    exit(-1);
}
my  $optlist = "df";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $CONTROL     = "@USERNODE@";
my $EVENTSYS    = @EVENTSYS@;
my $TESTMODE    = @TESTMODE@;
my $UNIFIED     = @UNIFIED_BOSS_AND_OPS@;
my $DBIFACE     = 0;

#
# The event system is currently optional.
#
if (! $EVENTSYS) {
    exit(0);
}

#
# Do nothing when testing.
#
if ($TESTMODE) {
#    print "Testing run - no event system.\n";
#    exit(0);
}

if ($EUID != 0) {
    die("Must be root! Maybe its a development version?\n");
}

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
use libtblog;

#
# Turn off line buffering on output
#
$| = 1;

# un-taint path
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin:$TB/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

my $proxy	= "$TB/sbin/eventsys.proxy";
my $debug	= 1;
my $force       = 0;
my $expstate;
my $dbuid;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 3) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $force = 1;
}
my $action = $ARGV[0];
my $pid    = $ARGV[1];
my $eid    = $ARGV[2];

#
# Untaint args.
#
if ($action =~ /^(start|stop|replay)$/) {
    $action = $1;
}
else {
    usage();
}
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Bad data in eid: $eid.");
}

if (! ($expstate = ExpState($pid, $eid))) {
    tbdie("No such experiment $pid/$eid!");
}

if (! UNIX2DBUID($UID, \$dbuid)) {
    tbdie("You do not exist in the Emulab Database!");
}

#
# Check permission. Only people with permission to destroy the experiment
# can do this.
#
if (! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_DESTROY)) {
    tbdie("You do not have permission to control the event system!");
}

#
# Do not allow an event system to be controlled if the experiment is not
# active (or swapping).
#
if ($expstate ne EXPTSTATE_ACTIVE &&
    $expstate ne EXPTSTATE_ACTIVATING &&
    $expstate ne EXPTSTATE_MODIFY_RESWAP &&
    $expstate ne EXPTSTATE_SWAPPING) {
    tbdie("Experiment $pid/$eid must active (or swapping)!");
}

#
# If being asked to start the event system, but there are no nodes in
# the experiment, balk unless force mode is on.
#
if ($action eq "start" && !$force && !ExpNodes($pid, $eid)) {
    tbnotice("There are no nodes in $pid/$eid. ".
	     "Not starting a scheduler.");
    exit(0);
}

#
# Delete the TIME START event.
#
if ($action eq "replay" || $action eq "stop") {
    DBQueryFatal("DELETE FROM eventlist WHERE " .
		 "pid='$pid' and eid='$eid' and objecttype=3 and eventtype=1");
}

# Need the unix_gid info to pass to boss.
my $gid = ExpGroup($pid, $eid);
my ($unix_gid, $unix_gidname);

if (! TBGroupUnixInfo($pid, $gid, \$unix_gid, \$unix_gidname)) {
    tbdie("Could not get unix group info for $pid/$gid!");
}

#
# Pase the whole thing off to the proxy, which might be local when running
# in UNIFIED_BOSS_AND_OPS mode. Become real root either way; the proxy will
# flip back. 
#
my $cmd = $proxy;
$cmd .= " -d"
    if ($debug);
$cmd .= " -l " . TBExptUserDir($pid, $eid) . "/logs/event-sched.log";
$cmd .= " -k " . TBDB_EVENTKEY($pid, $eid);
$cmd .= " -g " . $unix_gidname;
$cmd .= " -e $pid/$eid";
$cmd .= " -u $dbuid";
$cmd .= " $action";

$UID=0;
if ($UNIFIED || $DBIFACE) {
    exec($cmd);
}
else {
    exec("sshtb -host $CONTROL $cmd");
}
tbdie("Could not exec '$cmd'");
