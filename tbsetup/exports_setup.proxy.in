#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2011 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Errno;
use Fcntl ':flock';
use Getopt::Std;

#
# Create and /etc/exports file based on current reserved table and project
# members.
#
# usage: exports_setup
#

my %opts = ();
getopts('S', \%opts);

#
# Configure variables
#
my $TBOPS       = "@TBOPSEMAIL@";

my $etcdir;
my $exports;
my $exportsnew;
my $exportsback;
my $exportshead;
my $exportstail;
my $pidfile;
my $daemon;

# Are we modifying the Samba config file or the NFS exports?
if (defined($opts{'S'})) {
    $etcdir      = "/usr/local/etc";
    $exports	 = "$etcdir/smb.conf";
    $exportsnew  = "$etcdir/smb.conf.new";
    $exportsback = "$etcdir/smb.conf.backup";
    $exportshead = "$etcdir/smb.conf.head";
    $exportstail = "$etcdir/smb.conf.tail";
    $pidfile     = "/var/run/smbd.pid";
    $daemon      = "smbd";
}
else {
    $etcdir      = "/etc";
    $exports	 = "$etcdir/exports";
    $exportsnew  = "$etcdir/exports.new";
    $exportsback = "$etcdir/exports.backup";
    $exportshead = "$etcdir/exports.head";
    $exportstail = "$etcdir/exports.tail";
    $pidfile     = "/var/run/mountd.pid";
    $daemon      = "mountd";
}

my $dbg		= 0;
my @row;

#
# We don't want to run this script unless its the real version.
#
if ($UID != 0) {
    die("Must be root!");
}

# un-taint path
$ENV{'PATH'} = '/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

$| = 1; #Turn off line buffering on output

#
# Testbed Support libraries
# 
use lib "@prefix@/lib";
use libtestbed;

#
# Take our input and write it to the tail file.
#
open(TAIL, ">$exportstail") || fatal("Couldn't open $exportstail\n");
while (<STDIN>) {
    print TAIL $_;
}
close(TAIL);
chmod(0444, $exportstail);

#
# Generate a warning so that no one tries to edit the file by hand
#
open(MAP, ">$exportsnew") || fatal("Couldn't open $exportsnew\n");
print MAP
    "#\n".
    "# ******************************************************************\n".
    "# DO NOT EDIT THIS FILE. IT IS A CREATION, A FIGMENT, A CONTRIVANCE!\n".
    "#\n".
    "# Edit $exportshead, then run exports_setup on boss.\n".
    "# ******************************************************************\n".
    "#\n";
close(MAP);
chmod(0644, $exportsnew);

#
# Now tack on the head part of the file.
#
system("cat $exportshead >> $exportsnew") == 0 or
    fatal("Failed to concat $exportshead to $exportsnew\n");

#
# Now the tail of the file.
# 
system("cat $exportstail >> $exportsnew") == 0 or
    fatal("Failed to concat $exportstail to $exportsnew\n");

#
# Do nothing if no change.
#
system("/usr/bin/diff -q $exports $exportsnew >/dev/null");
if (! $?) {
#    print "No changes to $exports; skipping ...\n";
    exit(0);
}

#
# Back up the existing exports, and then mv in the new one.
#
system("cp $exports $exportsback") == 0 or
    fatal("Could not back up $exports to $exportsback\n");

system("mv $exportsnew $exports") == 0 or
    fatal("Could not mv $exportsnew to $exports\n");

# Avoid accidental editing.
chmod(0444, $exports);

#
# I have little faith in HUPing mountd, but do it anyway.
#
my $daemonpid = `cat $pidfile`;
$daemonpid =~ s/\n//;
# untaint
if ($daemonpid =~ /^([-\@\w.]+)$/) {
    $daemonpid = $1;
}
if (kill('HUP', $daemonpid) == 0) {
    fatal("Could not kill(HUP) process $daemonpid ($daemon): $!");
}

#
# Allow time to react since HUP'ing mountd causes all mounts to briefly
# become invalid, and this causes problems for our scripts (and for users).
#
sleep(1);

exit(0);

sub fatal {
    local($msg) = $_[0];

    SENDMAIL($TBOPS, "Exports Setup Failed", $msg);    
    die($msg);
}

