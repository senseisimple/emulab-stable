#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2005 University of Utah and the Flux Group.
# All rights reserved.
#

#
# Hack to get assign error messages into the database correctly.  Will
# be removed once the API is ported to other languages besides perl
#

BEGIN {$FAKE_SCRIPTNAME = $ARGV[0];}

use lib "@prefix@/lib";
use libtblog qw(:DEFAULT dblog *SOUT *SERR);

use constant false => 0;
use constant true  => 1;

sub parse_error($);

tblog_set_default_cause('temp');

use strict;

open P, join(' ', @ARGV, ' |');

my @out;
my @err;
my $obvious_error = 0;

while (<P>) {
    print SOUT $_;
    push @out, $_;
}
close P;

my $exitcode = $? >> 8;

#
# Now parse out relevent info and echo it to stderr.  Also, pull out
# any obvious errors (prefixed with ***) and log them sepertly.  The
# rest will go in te database as one big error.
#
if ($exitcode) {
    my $violations = 0;
    
    # Pull out relevent info
    print SERR "ASSIGN FAILED:\n";
    while ((shift @out) !~ /^[\w\s]*precheck:$/) {}
    while (($_ = shift @out)) {
	/^[\w\s]*precheck:$/ && do {
	    next;
	};
	/^With ([0-9]+) violations$/ && do {
	    $violations = $1;
	    last;
	};
	print SERR  $_;
	push @err, $_;
    }
    if ($violations) {
	while ((shift @out) !~ /^Violations:/) {}
	while (($_ = shift @out)) {
	    if (/^Nodes:/) {
		last;
	    }
	    print SERR $_;
	    push @err, $_;
	}
    }

    # See if there are any obvious errors
    my $err = '';
    while (($_ = shift @err)) {
	$err .= $_;
	if (/^(\s*)\*\*\*+\s*(.+)/) {
	    $obvious_error = 1;
	    my $space = $1;
	    my $mesg = $2;
	    while (@err && $err[0] =~ /^$space    \s*(.+)/) {
		$mesg .= "\n$1";
		shift @err;
	    }
	    my $sublevel = length($space) > 0 ? 1 : 0;
	    if ($mesg =~ s/^warning:\s+//i) {
		dblog(TBLOG_WARNING, {sublevel=>$sublevel}, $mesg);
	    } else {
		parse_error($mesg);
		dblog(TBLOG_ERR, {sublevel=>$sublevel}, $mesg);
	    }
	}
    }

    # log all relevent output as one entry unless an obvious_error was
    # already found
    dblog(TBLOG_ERR, {}, $err) unless ($obvious_error);

    # create a log entry that assign failed

    dblog(TBLOG_ERR, {sublevel => -1}, "Assign Failed.");
    
    dblog(TBLOG_ERR, {sublevel => -1, type=>'extra'}, 
	  "Failed to find a set of physical testbed nodes to run your ".
          "experiment on. This might mean that there are not enough ".
          "nodes or switch resources free, or your experiment might ".
          "require certain hardware which is not available.  If you ".
          "believe this message is in error, contact @TBOPSEMAIL@.")
	unless $obvious_error;
}

exit $exitcode;

sub parse_error($) {
    my ($mesg) = @_;

    return if parse_type_precheck_error($mesg);
    return if parse_mapping_precheck_error($mesg);
    return if parse_violation_error($mesg);
    return if parse_fixed_node_error($mesg);

    return;
}

sub parse_type_precheck_error($) {
    my ($mesg) = @_;
    my ($vtype, $requested, $slots, $max, $round);

    if ($mesg =~ /^No (\w+) physical nodes of type (\S+) found \((\d+) requested\)$/) {
	($round, $vtype, $requested) = ($1, $2, $3);
	$slots = 0;
    } elsif ($mesg =~ /^(\d+) nodes of type (\S+) requested, but only (\d+) (\w+) nodes of type \w+ found$/) {
	($requested, $vtype, $slots, $round) = ($1, $2, $3, $4);
    } elsif ($mesg =~ /^(\d+) nodes of type (\S+) requested, but you are only allowed to use (\d+)$/) {
	($requested, $vtype, $max) = ($1, $2, $3);
    } else {
	return false;
    }

    tbreport(SEV_WARNING, 'assign_type_precheck',
             $vtype, $requested, $slots, $max, $round);

    return true;
}

sub parse_mapping_precheck_error($) {
    my ($mesg) = @_;

    if ($mesg =~ /^No possible mapping for (\S+)\n/) {
	my $vnode = $1;
	my (undef, @lines) = split("\n", $mesg);

	foreach my $line (@lines) {
	    my ($class, $type, $requested, $count);

	    if ($line =~ /^No links of type (\S+) found! \((\d+) requested\)$/) {
		($type, $requested) = ($1, $2);
		$class = 'link';
		$count = 0;
	    } elsif ($line =~ /^Too many links of type (\S+)! \((\d+) requested, (\d+) found\)$/) {
		($type, $requested, $count) = ($1, $2, $3);
		$class = 'link';
	    } elsif ($line =~ /^Too much bandwidth on emulated links!$/) {
		$class = 'bandwidth';
		$count = 1; # Necessary?
	    } elsif ($line =~ /^No physical nodes have feature (\S+)!$/) {
		$type  = $1;
		$class = 'feature';
		$count = 0; # Necessary?
	    } else {
		# Unknown?
		next;
	    }

	    tbreport(SEV_WARNING, 'assign_mapping_precheck',
		     $vnode, $class, $type, $requested, $count);
	}

	return true;
    }

    return false;
}

sub parse_violation_error($) {
    my ($mesg) = @_;

    if ($mesg =~ /^Type precheck passed\.\n/) {
	my ($unassigned, $pnode_load, $no_connect, $link_users, $bandwidth,
	    $desires, $vclass, $delay, $trivial_mix, $subnodes, $max_types,
	    $endpoints);

	my (undef, @lines) = split("\n", $mesg);

	foreach my $line (@lines) {
	    if    ($line =~ /^  unassigned: +(\d+)$/)  { $unassigned  = $1 }
	    elsif ($line =~ /^  pnode_load: +(\d+)$/)  { $pnode_load  = $1 }
	    elsif ($line =~ /^  no_connect: +(\d+)$/)  { $no_connect  = $1 }
	    elsif ($line =~ /^  link_users: +(\d+)$/)  { $link_users  = $1 }
	    elsif ($line =~ /^  bandwidth: +(\d+)$/)   { $bandwidth   = $1 }
	    elsif ($line =~ /^  desires: +(\d+)$/)     { $desires     = $1 }
	    elsif ($line =~ /^  vclass: +(\d+)$/)      { $vclass      = $1 }
	    elsif ($line =~ /^  delay: +(\d+)$/)       { $delay       = $1 }
	    elsif ($line =~ /^  trivial mix: +(\d+)$/) { $trivial_mix = $1 }
	    elsif ($line =~ /^  subnodes: +(\d+)$/)    { $subnodes    = $1 }
	    elsif ($line =~ /^  max_types: +(\d+)$/)   { $max_types   = $1 }
	    elsif ($line =~ /^  endpoints: +(\d+)$/)   { $endpoints   = $1 }
	}

	tbreport(SEV_WARNING, 'assign_violation',
		 $unassigned, $pnode_load, $no_connect, $link_users, $bandwidth,
		 $desires, $vclass, $delay, $trivial_mix, $subnodes, $max_types,
		 $endpoints);

	return true;
    }

    return false;
}

sub parse_fixed_node_error($) {
    my ($mesg) = @_;
    my ($class, $vnode, $pnode);

    if ($mesg =~ /^Fixed node: (\S+) does not exist\.$/) {
	$vnode = $1;
	$class = 'exist';
    } elsif ($mesg =~ /^Fixed node: (\S+) not available\.$/) {
	$pnode = $1;
	$class = 'available';
    } elsif ($mesg =~ /^Unable to find a type for fixed, vtyped, node (\S+)$/) {
	$vnode = $1;
	$class = 'type';
    } elsif ($mesg =~ /^Fixed node: Could not map (\S+) to (\S+)$/) {
	($vnode, $pnode) = ($1, $2);
	$class = 'map';
    } else {
	return false;
    }

    tbreport(SEV_WARNING, 'assign_fixed_node', $class, $vnode, $pnode);

    return true;
}
