#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Create a group on the control/ops nodes and any tipservers. This does
# not create accounts, or add users to groups; it just creates the group
# entries and the group directory. Runs in the foreground all the time;
# Its quick enough that the user can wait for it.
#
# XXX - control node wired in.
#
sub usage()
{
    print STDOUT "Usage: mkgroup <pid> <gid>\n";
    exit(-1);
}
sub fatal($);

my  $optlist = "";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $CONTROL     = "@USERNODE@";
my $BOSSNODE	= "@BOSSNODE@";
my $ELABINELAB  = @ELABINELAB@;
my $MAILMANSUPPORT= @MAILMANSUPPORT@;
my $BUGDBSUPPORT= @BUGDBSUPPORT@;
my $OPSDBSUPPORT= @OPSDBSUPPORT@;
my $SSH         = "$TB/bin/sshtb";
my $ADDMMLIST   = "$TB/sbin/addmmlist";
my $OPSDBCONTROL= "$TB/sbin/opsdb_control";
my $GROUPADD    = "/usr/sbin/pw groupadd";
my @DIRLIST     = ("exp", "images", "logs", "tarfiles", "rpms", "tiplogs");
my $SAVEUID     = $UID;

my $dbuid;
my @db_row;
my $query_result;
my $leader;
my $logname;
my $user_name;
my $user_email;
my $unix_gid;
my $unix_name;
my @tipservers;

#
# Note hardwired control node. 
# 
my $control_node = $CONTROL;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libaudit;
use libdb;
use libtestbed;

my $PROJROOT    = PROJROOT();
my $GRPROOT     = GROUPROOT();

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

#
# This script is setuid, so please do not run it as root. Hard to track
# what has happened.
# 
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root! Its already setuid!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV != 2) {
    usage();
}
my $pid = shift(@ARGV);
my $gid = shift(@ARGV);

#
# Untaint args.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($gid =~ /^([-\@\w]+)$/) {
    $gid = $1;
}
else {
    die("Bad data in gid: $gid.");
}

#
# Get user DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
        "    You do not exist in the Emulab Database!\n");
}

#
# Get email info for mail.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine email info for you!\n");
}

#
# This script is always audited. Mail is sent automatically upon exit.
#
if (AuditStart(0)) {
    #
    # Parent exits normally
    #
    exit(0);
}

#
# Need Proj leader for ownership.
# 
if (! ($leader = GroupLeader($pid, $gid))) {
    die("*** $0:\n".
	"    Could not determine group leader for $pid/$gid!\n");
}

#
# The group directory lives here.
# 
my $groupdir  = "$GRPROOT/$pid/$gid";
my $grouplink = "$PROJROOT/$pid/groups/$gid";

#
# Unix info for the group
#
if (! TBGroupUnixInfo($pid, $gid, \$unix_gid, \$unix_name)) {
    fatal("No info for project/group $pid/$gid!");
}

# 
# Create group locally if it does not exist. egrep returns 1 when
# no matches are found.
#
if (system("egrep -q -s '^${unix_name}:' /etc/group")) {
    print "Adding group $unix_name to local node ...\n";

    if (system("$GROUPADD $unix_name -g $unix_gid")) {
	fatal("Could not add $unix_gid ($unix_gid) to local node!\n");
    }
}

#
# Perl and ssh Sillyness!
#
$UID = $EUID;

#
# Create group on the control node if it does not exist.
#
if ($control_node ne $BOSSNODE) {
    if (system("$SSH -host $control_node ".
	       "egrep -q -s '^${unix_name}:' /etc/group")) {
	print "Adding group $unix_name to $control_node.\n";

	if (system("$SSH -host $control_node ".
		   "$GROUPADD $unix_name -g $unix_gid")) {
	    fatal("Could not add $unix_name ($unix_gid) to $control_node!\n");
	}
    }
}

#
# Create group on the tip servers. 
#
foreach my $tipserver ( TBTipServers() ) {
    if (system("$SSH -host $tipserver ".
	       "egrep -q -s '^${unix_name}:' /etc/group")) {
	print "Adding group $unix_name to $tipserver\n";

	if (system("$SSH -host $tipserver ".
		   "$GROUPADD $unix_name -g $unix_gid")) {
	    fatal("Could not add $unix_name ($unix_gid) to $tipserver!\n");
	}
    }
}

#
# Create the group directory if it does not already exist, but not for
# the default group of the project.
#
if ($pid ne $gid) {
    if (! -e $groupdir) {
	print "Creating group directory: $groupdir.\n";
    
	if (! mkdir("$groupdir", 0770)) {
	    fatal("Could not make directory $groupdir: $!");
	}
    }

    if (! chmod(0770, "$groupdir")) {
	fatal("Could not chmod directory $groupdir: $!");
    }

    $unix_uid = getpwnam($leader);

    if (! chown($unix_uid, $unix_gid, "$groupdir")) {
	fatal("Could not chown $groupdir to $leader/$gid: $!");
    }

    if (! -e $grouplink) {
	symlink($groupdir, $grouplink) or
	    fatal("Could not symlink($groupdir, $grouplink): $!");
    }

    #
    # Make group subdirs.
    #
    foreach my $dir (@DIRLIST) {
	if (! -e "$groupdir/$dir") {
	    if (! mkdir("$groupdir/$dir", 0770)) {
		fatal("Could not make directory $groupdir/$dir: $!");
	    }
	    if (! chmod(0770, "$groupdir/$dir")) {
		fatal("Could not chmod directory $groupdir/$dir: $!");
	    }
	    if (! chown($unix_uid, $unix_gid, "$groupdir/$dir")) {
		fatal("Could not chown $groupdir/$dir: $!");
	    }
	}
    }

    if (($MAILMANSUPPORT || $OPSDBSUPPORT) && !$ELABINELAB) {
	$UID  = $SAVEUID;
	$EUID = $UID;

	if ($MAILMANSUPPORT) {
	    system("$ADDMMLIST -a ${pid}-${gid}-users") == 0 or
		fatal("$ADDMMLIST -a ${pid}-${gid}-users failed!");
	}

	if ($OPSDBSUPPORT) {
	    system("$OPSDBCONTROL addgroup $pid $gid") == 0 or
		fatal("$OPSDBCONTROL addgroup $pid $gid failed!");
	}
	$EUID = 0;
    }
}
    
print "Group Creation Completed!\n";
exit(0);

sub fatal($)
{
    my($mesg) = $_[0];

    die("*** $0:\n".
	"    $mesg\n");
}
