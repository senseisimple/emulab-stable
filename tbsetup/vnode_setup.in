#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2004 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Set up the vnode state on a virtual (multiplexed) node.
#
# XXX - This script should only be run from os_setup!
#
# The output is all jumbled together since the updates are issued in parallel.
# Might be a pain when debugging. 
# 
sub usage()
{
    print STDOUT "Usage: vnode_setup [-f] [-k] [-n <numbatch>] [-w <wait_time>] <pid> <eid> [node ...]\n";
    exit(-1);
}
my  $optlist = "fdkn:w:";

#
# We don't want to run this script unless its the real version.
# That is, it must be setuid root. 
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

#
# Configure variables
#
my $TB		= "@prefix@";
my $TESTMODE    = @TESTMODE@;
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $CLIENT_BIN  = "@CLIENT_BINDIR@";

my $ssh		= "$TB/bin/sshtb -n";
my $debug       = 0;
my $force       = 0;
my $failed      = 0;
my $killmode    = 0;
my $numbatch    = 10;
my $childwait   = 120;
my $dbuid;

#
# Load the Testbed support stuff. 
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

# Turn off line buffering on output
$| = 1; 

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (@ARGV < 2) {
    usage();
}
if (defined($options{"f"})) {
    $force = 1;
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
if (defined($options{"n"})) {
    if ($options{"n"} =~ /^(\d+)$/) {
        $numbatch = $1;
    }
    else {
        die ("*** Bad data in numbatch: $options{'n'}");
    }
}
if (defined($options{"w"})) {
    if ($options{"w"} =~ /^(\d+)$/) {
        $childwait = $1;
    }
    else {
        die ("*** Bad data in wait_time: $options{'w'}");
    }
}

my $pid   = shift(@ARGV);
my $eid   = shift(@ARGV);

#
# Untaint the arguments.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("*** Bad data in pid: $pid\n");
}	
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("*** Bad data in eid: $eid\n");
}

#
# Verify permission to muck with this experiment. Note that this script
# is run as root from the plab monitor daemon.
#
if ($UID && !TBAdmin($UID) &&
    !TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_DESTROY)) {
    die("*** $0:\n".
	"    You do not have permission to mess with $pid/$eid!\n");
}

#
# Get the list of nodes in this experiment.
#
my @nodes = ExpNodes($pid, $eid);
if (! @nodes) {
    warn("*** $0:\n".
	 "    No allocated nodes in experiment $pid/$eid!\n");
    exit(0);
}

# Nodes on the command line. Operate only on this set.
if (@ARGV) {
    my %fulllist = ();

    # Temporary hash list for searching.
    foreach my $node ( @nodes ) {
	$fulllist{$node} = 1;
    }
    @nodes = ();

    foreach my $node ( @ARGV ) {
	if ($node =~ /^([-\@\w]+)$/) {
	    $node = $1;

	    if (!defined($fulllist{$node})) {
		die("*** $0:\n".
		     "   Node $node is not allocated to $pid/$eid!\n");
	    }
	}
	else {
	    die("Bad node name: $node.");
	}
	push(@nodes, $node);
    }
}
my $exptstate = ExpState($pid, $eid);

# Just the vnodes mam.
foreach my $node (@nodes) {
    my $pnode;
    my $jailed;
    my $plab;
    my $allocstate;
    my $mode = ($killmode ? "teardown" : "setup");

    if (! TBIsNodeVirtual($node, \$jailed, \$plab)) {
	next;
    }
    if (! TBPhysNodeID($node, \$pnode)) {
	die("*** $0:\n".
	    "    No physical node for $node!\n");
    }

    TBGetNodeAllocState($node, \$allocstate);

    #
    # On remote nodes, or when forcemode is on, always do the deed.
    # Otherwise, look at experiment state.
    #
    if (!$force) {
	if ($exptstate eq EXPTSTATE_SWAPPING) {
	    #
	    # When swapping, local vnodes go down with the physnode.
	    #
	    if (! TBIsNodeRemote($node)) {
		print "$node will $mode with local node $pnode.\n";
		next;
	    }
	    elsif ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
		if (!$plab) {
		    print "$node failed to boot; skipping $mode.\n";
		    next;
		}
		# Plab nodes need to be cleaned up.
		print "$node failed to boot; changing to cleanup.\n";
		$mode = "cleanup";
	    }
	}
	elsif ($exptstate eq EXPTSTATE_ACTIVATING ||
	       $exptstate eq EXPTSTATE_MODIFY_RESWAP) {
	    #
	    # The allocstate determines if the vnode actually needs to
	    # be setup or torndown. Note that a failed experiment will
	    # cause a bunch of vnodes to be torndown, while in the
	    # ACTIVATING state. See os_setup and assign_wrapper; the
	    # idea is to avoid doing setup/teardown up vnodes on
	    # machines that are rebooting anyway, or that failed.
	    # Complicated by modify which could add/subtract a vnode on
	    # an existing machine, but not reboot the machine. Note that
	    # free (now unused) vnodes will land in RES_TEARDOWN. It is
	    # assumed that these booted okay, and need to be torndown,
	    # even though they are not RES_READY.
	    #
	    if (! TBIsNodeRemote($node)) {
		if ($killmode) {
		    if ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
			print "$node failed to boot; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
			print "$node never booted; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
			print "$node will $mode with local node $pnode.\n";
			next;
		    }
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
		    print "$node is already setting up on local node $pnode\n";
		    next;
		}
	    }
	    else {
		if ($killmode) {
		    if ($allocstate eq TBDB_ALLOCSTATE_DEAD) {
			# plab only. See below.
			print "$node failed to initialize; skipping $mode.\n";
			next;
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_DOWN) {
			if (!$plab) {
			    print "$node failed to boot; skipping $mode.\n";
			    next;
			}
			# Plab nodes need to be cleaned up.
			print "$node failed to boot; changing to cleanup.\n";
			$mode = "cleanup";
		    }
		    elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_CLEAN()) {
			print "$node never booted; skipping $mode.\n";
			next;
		    }
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_READY()) {
		    print "$node is already set up on remote node $pnode\n";
		    next;
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_INIT_DIRTY()) {
		    print "$node needs a reboot on remote node $pnode\n";
		    $mode = "reboot";
		}
		elsif ($allocstate eq TBDB_ALLOCSTATE_RES_RECONFIG()) {
		    print "$node needs a reconfig on remote node $pnode\n";
		    # We do not actually reconfig virtual nodes; just
		    # reboot them. Might reconfig someday, in which case
		    # this would move up into os_setup.
		    $mode = "reboot";
		}
	    }
	}
    }

    #
    # When setting up a vnode, force its event state into SHUTDOWN since
    # no telling what its initial state is. 
    # 
    # XXX: Don't we always want to set this?
    #
    if ($mode eq "teardown" || $mode eq "reboot") {
	TBSetNodeEventState($node, TBDB_NODESTATE_SHUTDOWN);
    }

    #
    # Put this into the list of calls we have to make in the next loop
    #
    push @vnodes, [$node, $pnode, $mode, $jailed, $plab];

}


my $children = 0;
my %child_vnodes = ();
print "vnode_setup running at parallelization: $numbatch ". 
    "wait_time: $childwait\n";
while (1) {

    # Space out the invocation of child processes a little.
    sleep(1);

    #
    # We're done when we've hit the last vnode, and we've outlived all of our
    # children
    #
    if ((!@vnodes) && ($children == 0)) {
	last;
    }

    #
    # There are more free slots
    #
    if (($children < $numbatch) && @vnodes) {
	#
	# Look for a vnode that is not on a pnode we're already working on
	# 
	# XXX - do this!
	
	my ($vnode, $pnode, $mode, $jailed, $plab) = @{pop @vnodes};
    
	print STDOUT "Doing $mode of vnode $vnode on $pnode ...\n";

	#
	# Run an ssh command in a child process, protected by an alarm to
	# ensure that the ssh is not hung up forever if the machine is in some
	# funky state.
	# 
	my $syspid = fork();

	if ($syspid) {
	    #
	    # Just keep track of it, we'll wait for it finish down below
	    #
	    $child_vnodes{$syspid} =
		[$vnode, $pnode, $mode, $jailed, $plab, time()];
	    $children++;
	} else {
	    TBdbfork();	# So we get the event system fork too ...
	    
            my $exval = 0;
	    # Must change our real UID to root so that ssh will work.
	    $UID = 0;

	    if ($plab && $mode eq "setup") {
                # Make sure vnode is in the proper state before trying to
                # bring it up.
                # XXX: do this for all vnodes (see above)?
                TBSetNodeEventState($vnode, TBDB_NODESTATE_SHUTDOWN);
		if (TBForkCmd("$TB/sbin/plabnode ". 
                              ($force ? "-f" : "").
                              " alloc $pid $eid $vnode", 1)) {
		    print STDERR "*** $0:\n" .
                        "    Plab node allocation failed\n";
		    # Should check DB state instead.
		    exit(99);
		}
	    }

	    # Cleanup is used only on plab nodes.
	    if ($mode ne "cleanup") {
		my $args = (($mode eq "teardown") ? "-k " :
			    ($mode eq "reboot" ? "-r " : " "));
		$args   .= ($jailed   ? "-j " : " ");
		$args   .= ($plab     ? "-p " : " ");
		$args   .= "$vnode ";
                
		$exval = TBForkCmd("$ssh -host $vnode ".
                                 "$CLIENT_BIN/vnodesetup $args",1);
            }

            # Free the plab node lease if necessary.
            if ($plab && ($mode eq "teardown" || $mode eq "cleanup")) {
                exec("$TB/sbin/plabnode free $pid $eid $vnode");
                die("*** $0:\n".
                    "    exec failed!\n");
            }
	    exit($exval);
	}
    } else {
	#
	# We have too many of the little rugrats, wait for one to die
	#

	#
	# Set up a timer - we want to kill processes after they hit 120 seconds
	# old (not much of a life, is it?), so we find the first one marked for
	# death.
	#
	my $oldest;
	my $oldestpid = 0;
        my $oldestvnode = "";
	while (my ($pid, $aref) = each %child_vnodes) {
	    my ($vnode, $pnode, $mode, $jailed, $plab, $birthtime) = @$aref;
	    if ((!$oldestpid) || ($birthtime < $oldest)) {
		$oldest = $birthtime;
		$oldestpid = $pid;
                $oldestvnode = $vnode;
	    }
	}

	#
	# Sanity check
	#
	if (!$oldest) {
	    die "*** $0\n".
	    	"Uh oh, I have no children left, something is wrong!\n";
	}

	#
	# If the oldest has already expired, just kill it off right now, and go
	# back around the loop
	#
	my $now = time();
	my $waittime = ($oldest + $childwait) - time();

	#
	# Kill of the oldest if it gets too old while we're waiting.
	#
        my $alarmed = 0;
	local $SIG{ALRM} = sub { $alarmed = 1; };

	if ($waittime <= 0) {
            print "*** $0: timeout waiting for vnode: $oldestvnode\n";
	    kill("TERM",$oldestpid);
	} else {
	    alarm($waittime);
	}

      WAITCHILD: 
        my $childpid = wait();
	my $exitstatus = $?;
	alarm 0;

        if ($alarmed) {
            print "*** $0: timeout (alarm clock) waiting for ".
                "vnode: $oldestvnode\n";
            $alarmed = 0;
            kill("TERM", $oldestpid);
            goto WAITCHILD;
        }

	#
	# Another sanity check
	#
	if ($childpid < 0) {
	    die "*** $0\n".
	    	"wait() returned <0, something is wrong!\n";
	}

	#
	# Look up to see what vnode, etc. this was associated with - if we
	# don't know about this child, ignore it
	#
	my $aref = $child_vnodes{$childpid};
	next unless @$aref;
	my ($vnode, $pnode, $mode, $jailed, $plab, $birthtime) = @$aref;
	$children--;
	delete $child_vnodes{$childpid};

	#
	# Look for setup failure, reported back through ssh.
	# 
	if ($exitstatus) {
	    print STDERR "vnode $vnode $mode on $pnode returned $?.\n"
		if $debug;

	    if ($exitstatus == 256) {
		print STDERR "$vnode is not running sshd.\n" if $debug;
	    }
	    elsif ($exitstatus == 15) {
		print STDERR "$vnode is wedged.\n" if $debug;
	    }
	    elsif ($exitstatus >> 8 == 99) {
		print STDERR "$vnode did not allocate properly.\n" if $debug;
	    }

	    push @failed_nodes, [$vnode, $pnode, $mode, $exitstatus];
	    
	    warn("*** $0:\n".
		 "    Virtual node $vnode $mode failure!\n");
	}

	if ($plab) {
	    #
	    # If the node was in the setup process, then mark its allocstate
	    # as down so os_setup knows not to bother waiting for it. DEAD
	    # is a temp state, different then DOWN. It indicates the node
	    # was never instantiated (important distinction for plab). 
	    #
	    if ($exitstatus &&
		(($mode eq "setup") || ($mode eq "reboot"))) {
		TBSetNodeAllocState($vnode, TBDB_ALLOCSTATE_DEAD());
	    }
	}
    }
}

#
# In force node, do not bother with this other stuff. 
#
exit(scalar(@failed_nodes))
    if ($force);

#
# Send mail to testbed-ops about failed nodes
#
if (@failed_nodes) { 
    my $failed_lines = join("\n",map { join("\t",@{$_}) } @failed_nodes);
    SENDMAIL($TBOPS, "Virtual Node failure for $pid/$eid",
	     "The following virtual nodes failed: \n" .
	     "vnode\t\tpnode\tmode\texit status\n" .
	     $failed_lines);
}

if ($killmode) {
    print STDOUT "Vnode teardown finished.\n";
}
else {
    print STDOUT "Vnode setup initiated on all nodes ...\n";
}
exit(0);
