#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2004-2006 University of Utah and the Flux Group.
# All rights reserved.
#
# TODO: ntpinfo table.
#       Current source directory? From where?
#
use English;
use Getopt::Std;

# Load the Testbed support stuff.
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Do things necessary for setting up inner elab experiment. 
#
sub usage()
{
    print STDOUT "Usage: elabinelab [-d] [-g] [-u] pid eid\n";
    print STDOUT "       elabinelab [-d] [-k | -f] pid eid\n";
    print STDOUT "       elabinelab [-d] -r pid eid [node ...]\n";
 
    exit(-1);
}
my $optlist  = "dgkfur";
my $debug    = 1;
my $killmode = 0;
my $fwboot   = 0;
my $dbgooonly= 0;
my $update   = 0;
my $remove   = 0;

sub DumpDBGoo();

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $CONTROL	= "@USERNODE@";
my $TBOPSPID    = TBOPSPID();
my $SSH		= "$TB/bin/sshtb";
my $nodereboot  = "$TB/bin/node_reboot";
my $makeconf    = "$TB/sbin/dhcpd_makeconf";
my $nodewait    = "$TB/sbin/node_statewait";
my $snmpit      = "$TB/bin/snmpit";

# Locals
my $elabinelab;
my $elabinelab_eid;

# Protos
sub TearDownEmulab();
sub RemoveNodes();
sub UpdateEmulab();

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin:/usr/site/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

# Be careful not to exit on transient error
$libdb::DBQUERY_MAXTRIES = 30;

# Locals
my $PROJROOT	= PROJROOT();
my $SAVEUID     = $UID;
my $workdir;
my %noderoles	= ();
my $opsnode;
my $bossnode;
my $fsnode;
my $routernode;
my @expnodes    = ();
my $dbuid;
my $user_name;
my $user_email;
my $query_result;
my $exptinfo;

#
# Parse command arguments. Once we return from getopts, all that should
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"g"})) {
    $dbgooonly = 1;
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"k"})) {
    $killmode = 1;
}
if (defined($options{"f"})) {
    $fwboot = 1;
}
if (defined($options{"u"})) {
    $update = 1;
}
if (defined($options{"r"})) {
    $remove = 1;
}
if (! @ARGV) {
    usage();
}
my ($pid,$eid) = @ARGV;

#
# Untaint the arguments.
#
if ($pid =~ /^([-\w]+)$/) {
    $pid = $1;
}
else {
    die("Tainted argument $pid!\n");
}
if ($eid =~ /^([-\w]+)$/) {
    $eid = $1;
}
else {
    die("Tainted argument $eid!\n");
}
$workdir = TBExptWorkDir($pid, $eid);

#
# Verify user and get his DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    You do not exist in the Emulab Database.\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
	"    Cannot determine your name and email address.\n");
}
TBDebugTimeStampsOn();

#
# Get elabinelab status to make sure, and to see if we need to fire off
# an experiment inside once its setup.
#
if (! TBExptIsElabInElab($pid, $eid, \$elabinelab, \$elabinelab_eid)) {
    die("*** $0:\n".
	"    Could not get elabinelab status for experiment $pid/$eid\n");
}
exit(0)
    if (!$elabinelab);

#
# See if the experiment is firewalled
#
my $firewall;
my $firewalled = TBExptFirewall($pid, $eid, \$firewall);

#
# XXX NOSETUP option needs more work ...
#
$query_result =
    DBQueryFatal("select elabinelab_nosetup from experiments ".
		 "where pid='$pid' and eid='$eid'");
my ($nosetup) = $query_result->fetchrow_array();

#
# Presetup; turn off firewall.
#
if ($fwboot) {
    exit(0)
	if (!$firewalled);
    
    print "Turning off firewall rules on $firewall\n";
    $UID = 0;
    system("$SSH -host $firewall ipfw add 1 allow all from any to any");
    if ($?) {
	die("*** $0:\n".
	    "    Error turning off firewall rules ($firewall)!\n");
    }
    exit(0);
}

#
# If we are going to start an inner experiment, grab the stuff we need
# from the DB and save it. 
#
if (defined($elabinelab_eid)) {
    $query_result =
	DBQueryFatal("select nsfile from nsfiles ".
		     "where pid='$pid' and eid='$elabinelab_eid'");

    die("*** $0:\n".
	"    No such experiment in DB for $pid/$elabinelab_eid\n")
	if (!$query_result->numrows);

    my ($nsfile) = $query_result->fetchrow_array();
    
    die("*** $0:\n".
	"    No nsfile in DB for $pid/$elabinelab_eid\n")
	if (!defined($nsfile) || $nsfile eq "");

    $query_result =
	DBQueryFatal("select * from experiments ".
		     "where pid='$pid' and eid='$elabinelab_eid'");

    die("*** $0:\n".
	"    No such experiment in DB for $pid/$elabinelab_eid\n")
	if (!$query_result->numrows);

    $exptinfo = $query_result->fetchrow_hashref();
    $exptinfo->{"nsfile"} = $nsfile;
}

#
# Get the role for each node.
#
$query_result =
    DBQueryFatal("select r.node_id,r.inner_elab_role from reserved as r ".
		 "where r.pid='$pid' and r.eid='$eid'");
while (my ($node_id,$role) = $query_result->fetchrow_array()) {
    # Like, the firewall node.
    next
	if (!defined($role));
	
    $noderoles{$node_id} = $role;
    $bossnode = $node_id
	if ($role eq 'boss' || $role eq 'boss+router');
    $routernode = $node_id
	if ($role eq 'router');
    $opsnode = $node_id
	if ($role eq 'ops' || $role eq 'ops+fs');
    $fsnode = $node_id
	if ($role eq 'fs');
    push(@expnodes, $node_id)
	if ($role eq 'node');
}

#
# Tear down an inner emulab.
# 
if ($killmode) {
    exit(TearDownEmulab());
}
elsif ($remove) {
    exit(RemoveNodes());
}
elsif ($update) {
    exit(UpdateEmulab());
}

#
# Get elabinelab info. If this is a container for an actual experiment,
# then need to fire off the experiment once the inner emulab is ready to
# go.
# 
TBDebugTimeStamp("Dumping DB state");
DumpDBGoo();
exit(0)
    if ($dbgooonly);

#
# For SSH and SCP below
#
$UID = 0;

#
# The firewall should be off at this point; called from os_setup with -f.
# 

#
# This is temporary. I think I will switch this over to grabbing the latest
# version from the web server.
#
my $mkelab = "$TB/etc/rc.mkelab";

if (-e "/proj/$pid/exp/$eid/rc.mkelab") {
    $mkelab = "/proj/$pid/exp/$eid/rc.mkelab";
}
print "Copying $mkelab to ${bossnode}/${opsnode}";
print "/${fsnode}"
    if (defined($fsnode));
print "\n";
system("scp $mkelab ${bossnode}:/tmp");
system("scp $mkelab ${opsnode}:/tmp");
system("scp $mkelab ${fsnode}:/tmp")
    if (defined($fsnode));

if (defined($fsnode)) {
    TBDebugTimeStamp("Setting up fsnode");
    print "Setting up fsnode on $fsnode\n";
    system("$SSH -host $fsnode /tmp/rc.mkelab -s -d > /tmp/fsnode.$$ 2>&1");
    if ($?) {
	$UID = $SAVEUID;
	SENDMAIL("$user_name <$user_email>",
		 "ElabInElab Failure: $pid/$eid",
		 "Error building the fs node ($fsnode)",
		 $TBOPS,
		 "Cc: $TBOPS",
		 ("/tmp/fsnode.$$"));
	system("rm -f /tmp/fsnode.$$ /tmp/opsnode.$$ /tmp/bossnode.$$");
	print STDERR "*** $0:\n".
	    "    Error building the fsnode ($fsnode)!\n";
	exit(($debug ? 0 : -1));
    }
}
TBDebugTimeStamp("Setting up opsnode");
print "Setting up opsnode on $opsnode\n";
system("$SSH -host $opsnode /tmp/rc.mkelab -s -d > /tmp/opsnode.$$ 2>&1");
if ($?) {
    $UID = $SAVEUID;
    SENDMAIL("$user_name <$user_email>",
	     "ElabInElab Failure: $pid/$eid",
	     "Error building the ops node ($opsnode)",
	     $TBOPS,
	     "Cc: $TBOPS",
	     ("/tmp/opsnode.$$"));
    system("rm -f /tmp/fsnode.$$ /tmp/opsnode.$$ /tmp/bossnode.$$");
    print STDERR "*** $0:\n".
	         "    Error building the opsnode ($opsnode)!\n";
    exit(($debug ? 0 : -1));
}
TBDebugTimeStamp("Setting up bossnode");
print "Setting up bossnode on $bossnode\n";
system("$SSH -host $bossnode /tmp/rc.mkelab -s -d > /tmp/bossnode.$$ 2>&1");
if ($?) {
    $UID = $SAVEUID;
    SENDMAIL("$user_name <$user_email>",
	     "ElabInElab Failure: $pid/$eid",
	     "Error building the boss node ($bossnode)",
	     $TBOPS,
	     "Cc: $TBOPS",
	     ("/tmp/bossnode.$$"));
    system("rm -f /tmp/fsnode.$$ /tmp/opsnode.$$ /tmp/bossnode.$$");
    print STDERR "*** $0:\n".
	         "    Error building the bossnode ($bossnode)!\n";
    exit(($debug ? 0 : -1));
}

# Send these log files off now so that we can look at them.
if (defined($fsnode)) {
    SENDMAIL("$user_name <$user_email>",
	     "ElabInElab Setup Log: $pid/$eid",
	     "Logs for building fs/ops/boss ($fsnode/$opsnode/$bossnode)",
	     $TBOPS,
	     "Cc: $TBOPS",
	     ("/tmp/fsnode.$$", "/tmp/opsnode.$$", "/tmp/bossnode.$$"));
} else {
    SENDMAIL("$user_name <$user_email>",
	     "ElabInElab Setup Log: $pid/$eid",
	     "Logs for building ops/boss ($opsnode/$bossnode)",
	     $TBOPS,
	     "Cc: $TBOPS",
	     ("/tmp/opsnode.$$", "/tmp/bossnode.$$"));
}
system("rm -f /tmp/fsnode.$$ /tmp/opsnode.$$ /tmp/bossnode.$$");
$UID  = $SAVEUID;

# Run as real user for the next few scripts, which are setuid.
$EUID = $UID;

goto skipsetup
    if ($nosetup);

#
# Restart DHCPD, but first mark the nodes as being ready to boot inside
# the inner emulab, so that dhcpd_makeconf knows what nodes to change
# the entries for.
#
DBQueryFatal("update reserved set inner_elab_boot=1 ".
	     "where pid='$pid' and eid='$eid'");

print "Regenerating DHCPD config file and restarting daemon.\n";
system("$makeconf -i -r");
if ($?) {
    die("*** $0:\n".
	"    Failed to reconfig/restart DHCPD.\n");
}

if (defined($fsnode)) {
    # Reboot fs and wait for it to come back.
    print "Rebooting fsnode ($fsnode).\n";
    TBDebugTimeStamp("Rebooting fsnode");
    system("$nodereboot -w $fsnode");
    if ($?) {
	die("*** $0:\n".
	    "    Error rebooting the fsnode ($fsnode)!\n");
    }
}
# Reboot ops and wait for it to come back.
print "Rebooting opsnode ($opsnode).\n";
TBDebugTimeStamp("Rebooting opsnode");
system("$nodereboot -w $opsnode");
if ($?) {
    die("*** $0:\n".
	"    Error rebooting the opsnode ($opsnode)!\n");
}
# Reboot boss and wait for it to come back.
print "Rebooting bossnode ($bossnode).\n";
TBDebugTimeStamp("Rebooting bossnode");
system("$nodereboot -w $bossnode");
if ($?) {
    die("*** $0:\n".
	"    Error rebooting the bossnode ($bossnode)!\n");
}
$EUID = 0;

# Reboot the experimental nodes. They will come up inside the inner elab.
# DO NOT WAIT! They are not going to report ISUP from this point on. 
if (@expnodes) {
    print "Rebooting inner experimental nodes.\n";
    TBDebugTimeStamp("Rebooting experimental nodes");
    # Run as real user again.
    $EUID = $UID;
    system("$nodereboot @expnodes");
    if ($?) {
	die("*** $0:\n".
	    "    Error rebooting the expnodes (@expnodes)!\n");
    }
    $EUID = 0;

    #
    # Instead, we ssh into the node and use a utility script to determine
    # when the nodes have rebooted and are in PXEWAIT (part of the inner elab).
    #
    # Run as real root for ssh.
    $UID  = 0;

    print "Waiting for nodes to reboot and join the inner emulab.\n";
    TBDebugTimeStamp("Waiting for inner nodes to reboot");
    system("$SSH -host $bossnode /usr/testbed/sbin/node_statewait -t 180 -a");
    if ($?) {
	print STDERR "*** $0:\n".
	             "    Error waiting for inner nodes to join!\n";
	exit(($debug ? 0 : -1));
    }
    $UID  = $SAVEUID;

    #
    # To avoid confusion later (with swapmod, which wants them to be ISUP),
    # and so the web interface does not show the nodes as down, set the 
    # state to ISUP.
    #
    foreach my $node (@expnodes) {
	TBSetNodeEventState($node, TBDB_NODESTATE_ISUP());
    }
}

#
# Fire off inner elab experiment.
# 
if (defined($elabinelab_eid)) {
    # Formatted to make batchexp happy.
    my $nsfilename = "/tmp/$pid-$elabinelab_eid-$$.nsfile";
    
    #
    # Write NS file to temp file so we can send it over.
    #
    open(NS, "> /tmp/$$.ns")
	or die("*** $0:\n".
	       "    Could not write ns code to tmp file!\n");
    print NS $exptinfo->{"nsfile"};
    print NS "\n";
    close(NS);

    #
    # Copy the file over.
    #
    $UID = 0;
    print "Sending NS file to inner bossnode ($bossnode).\n";
    system("cat /tmp/$$.ns | $SSH -host $bossnode '(cat > $nsfilename)'");
    if ($?) {
	die("*** $0:\n".
	    "    Could not copy ns code to inner boss ($bossnode)!\n");
    }

    #
    # Now run batchexp on the node as the user. If firewalled, experiment
    # must start async (cause we have to turn the firewall back on). 
    #
    my $optarg = ($firewalled ? "" : "-w");
	
    print "Starting experiment $pid/$elabinelab_eid on inner emulab.\n";
    TBDebugTimeStamp("Starting inner experiment");
    system("$SSH -host $bossnode 'sudo -u $dbuid /usr/testbed/bin/batchexp ".
	   "  -q -i $optarg -S \"ElabInElab Experiment\" ".
	   "  -L \"ElabInElab ElabInElab\" -E \"ElabInElab Experiment\" ".
	   "  -p $pid -e $elabinelab_eid $nsfilename'");
    
    $UID = $SAVEUID;
    unlink("/tmp/$$.ns");
}
skipsetup:

#
# Turn the firewall back on.
#
# XXX If this fails, we have to do something much stronger! We do not want
# nodes coming up and starting something if the firewall is not active.
# Maybe hit the panic button from here (turning off the control network).
#
#
if ($firewalled) {
    print "Turning firewall back on\n";
    $UID = 0;
    system("$SSH -host $firewall ipfw delete 1");
    if ($?) {
	print STDERR "*** Error turning back on firewall rules ($firewall)!\n".
		     "    Will retry again.\n";
	system("$SSH -host $firewall ipfw delete 1");
	if ($?) {
	    die("*** $0:\n".
		"    Error turning back on firewall rules! Retry failed.\n");
	}
    }
    $UID = $SAVEUID;
}

TBDebugTimeStamp("ElabInElab setup done");
exit(0);

#
# Dump parts of the DB that are needed for inner elab to run. The idea
# is to create a set of files named by the table name. Note that mysqld
# cannot write to the project tree cause of directory permissions. Put the
# files into the workdir for now, and them copy them over. 
#
sub DumpDBGoo()
{
    my $statedir = "$workdir/elabinelab";

    if (-d $statedir) {
	system("rm -rf $statedir");
    }
    mkdir($statedir, 0777) or
	die("*** $0:\n".
	    "    Could not mkdir $statedir\n");
    
    chmod(0777, $statedir) or
	die("*** $0:\n".
	    "    Could not chmod $statedir\n");

    #
    # These tables are dumped completely.
    #
    my @FULLTABLES = ("node_types", "node_type_attributes", "interface_types",
		      "interface_capabilities",
		      "switch_paths", "switch_stack_types", "switch_stacks",
		      "node_type_features", "node_types_auxtypes", "osid_map",
		      "os_boot_cmd");

    #
    # These tables are dumped by role (node/ops). For each one dump the table
    # as is, unless its the fs or ops node. For those we want to change the
    # node_id to "fs" or "ops" and their type to ops.
    #
    my @NODETABLES = ("node_auxtypes", "node_status", "nodes",
		      "node_rusage", "node_hostkeys", "node_idlestats");

    #
    # These tables are dumped by project ID.
    #
    my @PROJTABLES = ("project_stats", "projects", "group_stats", "groups");

    #
    # These tables are dumped by user ID (for the project).
    #
    my @USERTABLES = ("users", "user_pubkeys", "user_stats");

    foreach my $table (@FULLTABLES) {
	unlink("$statedir/$table");
	DBQueryWarn("create temporary table temp_${table} ".
		    "select t.* from $table as t")
	    or die("*** $0:\n".
		   "    Could not dump table $table\n");

	if ($table eq "node_type_attributes") {
	    my $attributes_result =
		DBQueryFatal("select type,attrvalue from temp_${table} ".
			     "where attrkey='delay_capacity'");

	    while (my ($ntype,$value) = $attributes_result->fetchrow_array()) {
		my $newvalue = $value - 1;
		
		DBQueryFatal("update temp_${table} set ".
			     "   attrvalue='$newvalue' ".
			     "where type='$ntype'");
	    }
	}

	DBQueryWarn("select * from temp_$table ".
		    "into outfile '$statedir/$table'")
	    or die("*** $0:\n".
		   "    Could not dump table $table\n");
    }

    foreach my $table (@NODETABLES) {
	unlink("$statedir/$table");
	#
	# Create a temporary table.
	#
	DBQueryWarn("create temporary table temp_${table} ".
		    "select t.* from reserved as r ".
		    "left join $table as t on t.node_id=r.node_id ".
		    "left join virt_nodes as v on v.vname=r.vname and ".
		    "     v.pid=r.pid and v.eid=r.eid ".
		    "where r.pid='$pid' and r.eid='$eid' and ".
		    "      t.node_id is not null and ".
		    "      v.inner_elab_role in ('node','fs','ops','ops+fs')")
	    or die("*** $0:\n".
		   "    Could not create temporary table temp_$table\n");
	#
	# Rename the fs and ops node in each table. For the nodes table,
	# there is a bunch of other stuff to do.
	#
	DBQueryFatal("update temp_${table} set node_id='fs' ".
		     "where node_id='$fsnode'")
	    if (defined($fsnode));
	DBQueryFatal("update temp_${table} set node_id='ops' ".
		     "where node_id='$opsnode'");

	if ($table eq "nodes") {
	    DBQueryFatal("update temp_${table} set ".
			 " type='ops', ".
			 " phys_nodeid=node_id, ".
			 " role='ctrlnode', ".
			 " op_mode='OPSNODEBSD' ".
			 "where node_id in ('fs','ops')");

	    # Also add the nodes that correspond to the "trunk" wires.
	    DBQueryFatal("insert into temp_${table} ".
			 "select distinct n.* from wires as w ".
			 "left join nodes as n on w.node_id1=n.node_id or ".
			 "     w.node_id2=n.node_id ".
			 "where w.type='Trunk'");
	}
    
	DBQueryWarn("select * from temp_$table ".
		    "into outfile '$statedir/$table'")
	    or die("*** $0:\n".
		   "    Could not dump table $table\n");
    }

    foreach my $table (@PROJTABLES) {
	unlink("$statedir/$table");
	DBQueryWarn("select * from $table ".
		    "where pid='$pid' ".
		    "into outfile '$statedir/$table'")
	    or die("*** $0:\n".
		   "    Could not dump table $table\n");
    }

    #
    # Special case the group and user policy tables. Not sure what to
    # really do about this; should there be any restrictions inside the
    # inner elab?
    #
    unlink("$statedir/group_policies");
    DBQueryWarn("select * from group_policies ".
		"where pid='$pid' or pid='+' or pid='-' ".
		"into outfile '$statedir/group_policies'")
	or die("*** $0:\n".
	       "    Could not dump table group_policies\n");

    foreach my $table (@USERTABLES) {
	unlink("$statedir/$table");

	DBQueryWarn("create temporary table temp_$table ".
		    "select t.* from group_membership as gm ".
		    "left join users as u on u.uid=gm.uid ".
		    "left join $table as t on t.uid=u.uid ".
		    "where gm.pid='$pid' and gm.gid=gm.pid ".
		    " and t.uid is not NULL and ".
		    " u.status='" . USERSTATUS_ACTIVE() . "'")
	    or die("*** $0:\n".
		   "    Could not create table temp_$table\n");

	if ($table eq "users") {
	    $creator = ExpLeader($pid, $eid);
	    
	    DBQueryFatal("update temp_${table} set ".
			 " admin=1 ".
			 "where uid='$creator'");
	}

	DBQueryWarn("select * from temp_$table ".
		    "into outfile '$statedir/$table'")
	    or die("*** $0:\n".
		   "    Could not dump table temp_$table\n");
    }

    # The group_membership is also special.
    DBQueryWarn("select gm.* from group_membership as gm ".
		"left join users as u on u.uid=gm.uid ".
		"where (gm.pid='$pid' or ".
		"       gm.pid='" . TBOPSPID() . "') and ".
		" u.status='" . USERSTATUS_ACTIVE() . "' ".
		"into outfile '$statedir/group_membership'")
	or die("*** $0:\n".
	       "    Could not dump table group_membership\n");

    #
    # Initial images; not that these images are not going to exist inside!
    # 
    DBQueryWarn("select * from images ".
		"where pid='$pid' or (pid='$TBOPSPID' and global=1) ".
		"into outfile '$statedir/images'")
	or die("*** $0:\n".
	       "    Could not dump table images\n");
	    
    DBQueryWarn("create temporary table temp_os_info ".
		"select * from os_info ".
		"where pid='$pid' or (pid='$TBOPSPID' and shared=1)")
	or die("*** $0:\n".
	       "    Could not create table temp_os_info\n");

    # Ack. The MFS paths have a hardcoded "boss" in them, but that is going
    # to resolve incorrectly to an inner control IP, which will not work
    # from the pxeboot kernel since it uses the outer control network.
    # Just remove the host spec; pxeboot will do the right thing.
    my $query_result =
	DBQueryFatal("select osid,path from temp_os_info ".
		     "where path like '%:%'");
    
    while (my ($osid,$hostpath) = $query_result->fetchrow_array()) {
	my ($host,$path) = $hostpath =~ /^(.*):(.*)$/;

	DBQueryFatal("update temp_os_info set path='$path' where osid='$osid'");
    }

    DBQueryWarn("select * from temp_os_info ".
		"into outfile '$statedir/os_info'")
	or die("*** $0:\n".
	       "    Could not dump table os_info\n");
	    
    DBQueryWarn("select o.* from osidtoimageid as o ".
		"left join images as i on i.imageid=o.imageid ".
		"where i.pid='$pid' or (i.pid='$TBOPSPID' and i.global=1) ".
		"into outfile '$statedir/osidtoimageid'")
	or die("*** $0:\n".
	       "    Could not dump table osidtoimageid\n");

    #
    # interfaces table. Need to tag the interfaces being used as the control
    # network, with the proper tag so they do not say they experimental
    # interfaces in the inner emulab. Use a temp table again.
    #
    DBQueryWarn("create temporary table temp_interfaces ".
		"select t.* from reserved as r ".
		"left join interfaces as t on t.node_id=r.node_id ".
		"left join virt_nodes as v on v.vname=r.vname and ".
		"     v.pid=r.pid and v.eid=r.eid ".
		"where r.pid='$pid' and r.eid='$eid' and ".
		"      v.inner_elab_role in ('node','ops','fs','ops+fs')")
	or die("*** $0:\n".
	       "    Could not create temporary table temp_interfaces\n");

    # First, mark the real control network as "other" to avoid it being
    # thought of as the control network!.
    DBQueryWarn("update temp_interfaces ".
		"set role='" . TBDB_IFACEROLE_OUTER_CONTROL() . "' " .
		"where role='" . TBDB_IFACEROLE_CONTROL() . "'")
	or die("*** $0:\n".
	       "    Could not delete control ifaces from temp_interfaces\n");

    DBQueryWarn("update temp_interfaces set ".
		" role='" . TBDB_IFACEROLE_CONTROL() . "' " .
		"where IP!='' and role='" . TBDB_IFACEROLE_EXPERIMENT() . "'")
	or die("*** $0:\n".
	       "    Could not update roles in temp_interfaces\n");

    # And rename the fs/ops nodes as above.
    if (defined($fsnode)) {
	DBQueryWarn("update temp_interfaces set node_id='fs' ".
		    "where node_id='$fsnode'")
	    or die("*** $0:\n".
		   "    Could not fs node_id in temp_interfaces\n");
    }
    DBQueryWarn("update temp_interfaces set node_id='ops' ".
		"where node_id='$opsnode'")
	or die("*** $0:\n".
	       "    Could not ops node_id in temp_interfaces\n");

    # Also add the interfaces that correspond to the "trunk" wires.
    DBQueryFatal("insert into temp_interfaces ".
		 "select distinct i.* from wires as w ".
		 "left join interfaces as i on w.node_id1=i.node_id or ".
		 "     w.node_id2=i.node_id ".
		 "where w.type='Trunk'");

    DBQueryWarn("select * from temp_interfaces ".
		"into outfile '$statedir/interfaces'")
	or die("*** $0:\n".
	       "    Could not dump table interfaces\n");

    # And the wires table. Strip out the control wires; not needed.
    DBQueryWarn("create temporary table temp_wires ".
		"select t.* from reserved as r ".
		"left join virt_nodes as v on v.vname=r.vname and ".
		"     v.pid=r.pid and v.eid=r.eid ".
		"left join wires as t on t.node_id1=r.node_id and ".
		"     t.type='Node' ".
		"where r.pid='$pid' and r.eid='$eid' and ".
		"      v.inner_elab_role in ('node','ops','fs','ops+fs') ")
	or die("*** $0:\n".
	       "    Could not create temporary table temp_wires\n");

    # And rename the fs/ops node as above.
    if (defined($fsnode)) {
	DBQueryWarn("update temp_wires set node_id1='fs' ".
		    "where node_id1='$fsnode'")
	    or die("*** $0:\n".
		   "    Could not fs node_id in temp_wires\n");
    }
    DBQueryWarn("update temp_wires set node_id1='ops' ".
		"where node_id1='$opsnode'")
	or die("*** $0:\n".
	       "    Could not ops node_id in temp_wires\n");

    # But we need to take out the wires that are being used as the
    # inner control network, or at least mark them as Control.
    $query_result =
	DBQueryWarn("select node_id,card,port from temp_interfaces ".
		    "where role='" . TBDB_IFACEROLE_CONTROL() . "' ");

    while (my ($node_id,$card,$port) = $query_result->fetchrow_array()) {
	DBQueryWarn("update temp_wires set type='Control' ".
		    "where node_id1='$node_id' and card1=$card and ".
		    "      port1=$port");
    }
    # Okay, now add the "trunk" wires in without any alteration.
    DBQueryWarn("insert into temp_wires ".
		"select * from wires where type='Trunk'") 
	or die("*** $0:\n".
	       "    Could not add trunk lines to temp_wires\n");

    DBQueryWarn("select * from temp_wires ".
		"into outfile '$statedir/wires'")
	or die("*** $0:\n".
	       "    Could not dump table wires\n");

    #
    # Ack, we need to create a reservation for the fs and ops nodes,
    # or else they will look free and it will not be able to check in.
    #
    DBQueryWarn("create temporary table temp_reserved ".
		"select r.* from reserved as r ".
		"left join virt_nodes as v on v.vname=r.vname and ".
		"     v.pid=r.pid and v.eid=r.eid ".
		"where r.pid='$pid' and r.eid='$eid' ".
		"      and v.inner_elab_role in ('fs','ops','ops+fs')")
	or die("*** $0:\n".
	       "    Could not create temporary table temp_reserved\n");
    if (defined($fsnode)) {
	DBQueryWarn("update temp_reserved set ".
		    "   node_id='fs', ".
		    "   pid='$TBOPSPID', ".
		    "   eid='opsnodes' ".
		    "where node_id='$fsnode'")
	    or die("*** $0:\n".
		   "    Could not update temporary table temp_reserved\n");
    }
    DBQueryWarn("update temp_reserved set ".
		"   node_id='ops', ".
		"   pid='$TBOPSPID', ".
		"   eid='opsnodes' ".
		"where node_id='$opsnode'")
	or die("*** $0:\n".
	       "    Could not update temporary table temp_reserved\n");
    DBQueryWarn("select * from temp_reserved ".
		"into outfile '$statedir/reserved'")
	or die("*** $0:\n".
	       "    Could not dump table reserved\n");

    # Copy tiplines table for all nodes so web form gives us a console icon!
    DBQueryWarn("select t.tipname,t.node_id,'',0,0,NULL ".
		"from reserved as r ".
		"left join virt_nodes as v on v.vname=r.vname and ".
		"     v.pid=r.pid and v.eid=r.eid ".
		"left join tiplines as t on t.node_id=r.node_id ".
		"where r.pid='$pid' and r.eid='$eid' and ".
		"      v.inner_elab_role='node' ".
		"into outfile '$statedir/tiplines'")
	or die("*** $0:\n".
	       "    Could not dump table tiplines\n");

    #
    # Tar up the directory and send it over to (real) ops.
    #
    $UID = 0;
    system("tar cf - -C $statedir . | ".
	   "   gzip | $SSH -F /dev/null -host $CONTROL ".
	   "   '(cat > /$PROJROOT/$pid/exp/$eid/dbstate.tar.gz)'");
    if ($?) {
	die("*** $0:\n".
	    "    Could not create dbstate.tar.gz\n");
    }
    $UID = $SAVEUID;
    return 0;
}

#
# Tear down an inner Emulab as cleanly as possible to avoid power cycling
# nodes.
# 
sub TearDownEmulab()
{
    my $tbdir      = "/usr/testbed";
    my $wap        = "$tbdir/sbin/withadminprivs";
    my $nodereboot = "$tbdir/bin/node_reboot";

    #
    # We want to rebuild the DHCPD file so that when we reboot the inner nodes
    # they come back to the outer emulab. We cannot just free the nodes, cause
    # then the reload daemon might beat us to it, and end up power cycling the
    # nodes, and that would be bad. So, munge the DB and clear the "role" slot
    # for inner nodes. 
    #
    DBQueryFatal("update reserved set inner_elab_role=NULL,inner_elab_boot=0 ".
		 "where pid='$pid' and eid='$eid'");

    #
    # XXX Failure at this point will leave things in an inconsistent state
    # cause we have just munged the reserved table. Since we were trying
    # to swap out the experiment, I think this will be okay. Wait and see.
    #
    return 0
	if (!defined($bossnode));

    #
    # Now regen the DHCPD file.
    #
    # Run as real user since script is setuid.
    $EUID = $UID;
    
    print "Regenerating DHCPD config file and restarting daemon.\n";
    system("$makeconf -i -r");
    if ($?) {
	die("*** $0:\n".
	    "    Failed to reconfig/restart DHCPD.\n");
    }
    $EUID = 0;

    #
    # Kill inner vlans table entries; this is the table that maps
    # inner to outer vlans. We do not care about that anymore since
    # all of the vlans are going to be torn down (using the outer
    # ids).
    #
    DBQueryFatal("delete from elabinelab_vlans ".
		 "where pid='$pid' and eid='$eid'");

    #
    # If firewalled, just return now since all nodes will be powered
    # off anyway.
    #
    if ($firewalled) {
	print "Skipping clean shutdown since experiment is firewalled.\n";
	return 0;
    }

    #
    # When the nodes reboot, we want them to do something reasonable. We
    # have no idea what is loaded on the disk, so they should go into an
    # MFS and wait, but then a bunch of nodes will all try to load the big
    # MFS at once, and that could wreak havoc. So, clear the boot osids
    # so they go into PXEWAIT. I could use os_select, but clearing all the
    # OSIDs for a node is apparently a bad thing and generates warnings and
    # emails. Why is that? So just clear the DB state until I figure out
    # why that is.
    #
    DBQueryFatal("update nodes set ".
		 "  def_boot_osid='',next_boot_osid='',temp_boot_osid='' ".
		 "where " .
		    join(" or ", map("node_id='$_'",
				     ($bossnode, $opsnode,
				      defined($fsnode) ? $fsnode : (),
				      @expnodes))));
    
    #
    # SSH in and kill the inner DHCPD daemon so that it does not reply
    # to rebooting nodes along the inner control network.
    #
    $UID = 0;

    print "Killing DHCPD on inner boss ($bossnode)\n";
    system("$SSH -host $bossnode /usr/local/etc/rc.d/2.dhcpd.sh stop");
    if ($?) {
	#
	# This error is non-fatal. If DHCPD cannot be killed, then the inner
	# boss is scrogged or never set up properly. Just return and let
	# the nodes get power cycled (if need be). At some point we need a
	# state machine to control this setup stuff. 
	# 
	print STDERR "*** $0:\n".
	             "    Could not stop DHCPD on inner bossnode ($bossnode)!\n".
		     "    Continuing anyway; outer boss will use power cycle.\n";
	return 0;
    }

    #
    # Now we ask inner boss to reboot all of the testnodes. Maybe need an
    # option to node_reboot, but for now just pass them on the command line.
    #
    if (! @expnodes) {
	$UID = $SAVEUID;
	return 0;
    }
    
    print "Asking inner boss ($bossnode) to reboot inner nodes\n";
    system("$SSH -host $bossnode $wap $nodereboot -b @expnodes");
    if ($?) {
	#
	# This error is non-fatal; Outer boss will just resort to power cycle.
	#
	print STDERR "*** $0:\n".
	             "    Could not reboot some inner nodes!\n".
		     "    Continuing anyway; outer boss will use power cycle.\n";
    }
    $UID = $SAVEUID;

    #
    # Now we wait for them to reach PXEWAIT. Again, use our utility script
    # instead of stated stuff.
    #
    $EUID = $UID;
    print "Waiting for inner nodes to reach PXEWAIT\n";
    system("$nodewait @expnodes");
    if ($?) {
	#
	# This error is non-fatal; Outer boss will just resort to power cycle.
	#
	print STDERR "*** $0:\n".
	             "    Some machines did not reboot properly!\n".
		     "    Continuing anyway; outer boss will use power cycle.\n";
    }
    return 0;
}

#
# Remove nodes from an inner Emulab.
# 
sub RemoveNodes()
{
    my $tbdir      = "/usr/testbed";
    my $wap        = "$tbdir/sbin/withadminprivs";
    my $nodereboot = "$tbdir/bin/node_reboot";
    my $deletenode = "$tbdir/sbin/deletenode";
    my @nodes	   = ();
    my $paniced    = 0;

    #
    # If firewalled, check to see if paniced. Right now that means the nodes
    # are going to be powered off, so need to do the clean shutdown dance.
    # 
    if ($firewalled) {
	TBExptGetPanicBit($pid, $eid, \$paniced);
    }

    #
    # Actually, this should not even happen; a paniced experiment cannot be
    # modified at all.
    #
    if ($paniced) {
	print "A paniced experiment cannot be modified! What happened?\n";
	return -1;
    }

    #
    # Grab the list of nodes. We want to clear the reserved table bits so
    # that we can regen the DHCPD file. 
    #
    shift(@ARGV);	# pid
    shift(@ARGV);	# eid

    foreach my $node (@ARGV) {
	# Untaint the nodes.
	if ($node =~ /^([-\w]+)$/) {
	    $node = $1;
	}
	else {
	    die("*** Tainted node name: $node\n");
	}
	push(@nodes, $node);
    }
    return 0
	if (!@nodes);

    #
    # Grab the vlans table. We need to find any ports used by the nodes
    # getting deleted, and move them back to the default vlan. 
    #
    my %newvlans = ();
    my @todelete = ();
    
    my $query_result =
	DBQueryWarn("select v.*,e.inner_id from vlans as v ".
		    "left join elabinelab_vlans as e on ".
		    "   e.outer_id=v.id ".
		    "where v.pid='$pid' and v.eid='$eid'");
    return -1
	if (!$query_result);

    while (my (%row) = $query_result->fetchhash()) {
	my $members  = $row{"members"};
	my $id       = $row{"id"};
	my $inner_id = $row{"inner_id"};
	my @newports = ();
	my $changed  = 0;

	foreach my $port (split(/\s+/, $members)) {
	    my ($node,$eth) = split(":", $port);

	    # If this node is not in the list of nodes to be deleted,
	    # the node:port stays in the port list.
	    if (! grep {$_ eq $node} @nodes) {
		push(@newports, $port);
	    }
	    else {
		push(@todelete, $port);
		$changed = 1;
	    }
	}
	$newvlans{$id} = [ @newports ]
	    if ($changed);
    }

    # Remove ports from the vlans.
    if (@todelete) {
	print "Removing ports from deleted nodes: @todelete\n";
	system("$snmpit -m default @todelete");
	if ($?) {
	    return -1;
	}
    }

    # Only if the above succeeds, do we update the vlans table.
    foreach $id (keys(%newvlans)) {
	my $members = join(" ", @{ $newvlans{$id} });

	DBQueryWarn("update vlans set members='$members' ".
		    "where id=$id")
	    or return -1;
    }
    
    #
    # We want to rebuild the DHCPD file so that when we reboot the inner nodes
    # they come back to the outer emulab. We cannot just free the nodes, cause
    # then the reload daemon might beat us to it, and end up power cycling the
    # nodes, and that would be bad. So, munge the DB and clear the "role" and
    # boot slots for nodes about to be released (by tbswap).
    #
    DBQueryWarn("update reserved set inner_elab_role=NULL,inner_elab_boot=0 ".
		"where pid='$pid' and eid='$eid' and (".
		join(" or ", map("node_id='$_'", @nodes)) . ")")
	or return -1;

    #
    # Now regen the DHCPD file.
    #
    # Run as real user since script is setuid.
    $EUID = $UID;
    
    print "Regenerating DHCPD config file and restarting daemon.\n";
    system("$makeconf -i -r");
    if ($?) {
	die("*** $0:\n".
	    "    Failed to reconfig/restart DHCPD.\n");
    }
    $EUID = 0;

    #
    # When the nodes reboot, we want them to do something reasonable. We
    # have no idea what is loaded on the disk, so they should go into an
    # MFS and wait, but then a bunch of nodes will all try to load the big
    # MFS at once, and that could wreak havoc. So, clear the boot osids
    # so they go into PXEWAIT. I could use os_select, but clearing all the
    # OSIDs for a node is apparently a bad thing and generates warnings and
    # emails. Why is that? So just clear the DB state until I figure out
    # why that is.
    #
    DBQueryFatal("update nodes set ".
		 "  def_boot_osid='',next_boot_osid='',temp_boot_osid='' ".
		 "where " .
		   join(" or ", map("node_id='$_'", @nodes)));
    
    #
    # SSH in and kill the inner DHCPD daemon so that it does not reply
    # to rebooting nodes along the inner control network.
    #
    $UID = 0;

    #
    # We are going to do this in a loop, one node at a time. I do not like
    # doing it this way, but its the only reasonable thing to do until we
    # can reboot the inner nodes ourselves (via the outer control network).
    # The reason for doing it one node at a time, is that I cannot delete the
    # node from the inner testbed until its been rebooted. Note that the
    # delete node script regens the dhcpd.conf file, so no need to do that
    # explicitly.
    #
    foreach my $node (@nodes) {
	print "Asking inner boss ($bossnode) to reboot $node\n";
	system("$SSH -host $bossnode $wap $nodereboot -b $node");
	if ($?) {
	    #
	    # This error is non-fatal;
	    # Outer boss will just resort to power cycle.
	    #
	    print STDERR "*** $0:\n".
		         "    Could not reboot $node! Continuing anyway.\n".
			 "    Outer boss will use power cycle.\n";
	}
	print "Asking inner boss ($bossnode) to delete $node\n";
	system("$SSH -host $bossnode sudo -u elabman ".
	       "     $wap $deletenode -b -q -f $node");
	if ($?) {
	    #
	    # This error is bad. 
	    #
	    print STDERR "*** $0:\n".
		         "    Could not delete $node! Modify will fail!\n";
	    return -1;
	}
    }
    $UID = $SAVEUID;

    #
    # Now we wait for them to reach PXEWAIT. Again, use our utility script
    # instead of stated stuff.
    #
    $EUID = $UID;
    print "Waiting for inner nodes to reach PXEWAIT\n";
    system("$nodewait @nodes");
    if ($?) {
	#
	# This error is non-fatal; Outer boss will just resort to power cycle.
	#
	print STDERR "*** $0:\n".
	             "    Some machines did not reboot properly!\n".
		     "    Continuing anyway; outer boss will use power cycle.\n";
    }
    return 0;
}

#
# Update an Emulab (add nodes).
# 
sub UpdateEmulab()
{
    my $tbdir      = "/usr/testbed";
    my $wap        = "$tbdir/sbin/withadminprivs";
    my $nodereboot = "$tbdir/bin/node_reboot";
    my $nodewait   = "$tbdir/sbin/node_statewait";
    my @nodes      = ();
    my $paniced    = 0;

    #
    # If firewalled, check to see if paniced. Right now that means the nodes
    # are going to be powered off, so need to do the clean shutdown dance.
    # 
    if ($firewalled) {
	TBExptGetPanicBit($pid, $eid, \$paniced);
    }

    #
    # Actually, this should not even happen; a paniced experiment cannot be
    # modified at all.
    #
    if ($paniced) {
	print "A paniced experiment cannot be modified! What happened?\n";
	return -1;
    }

    #
    # Grab the list of nodes that have been added to the inner elab.
    #
    my $query_result =
	DBQueryFatal("select node_id from reserved ".
		     "where pid='$pid' and eid='$eid' and ".
		     "      inner_elab_boot=0 and inner_elab_role='node'");
    
    while (my ($node) = $query_result->fetchrow_array()) {
	push(@nodes, $node);	
    }
    return 0
	if (!@nodes);

    # Run as real user for the next few scripts, which are setuid.
    $EUID = $UID;

    #
    # Restart DHCPD, but first mark the nodes as being ready to boot inside
    # the inner emulab, so that dhcpd_makeconf knows what nodes to change
    # the entries for.
    #
    DBQueryFatal("update reserved set inner_elab_boot=1 ".
		 "where pid='$pid' and eid='$eid' and ".
		 "      inner_elab_boot=0 and inner_elab_role='node'");

    print "Regenerating DHCPD config file and restarting daemon.\n";
    system("$makeconf -i -r");
    if ($?) {
	die("*** $0:\n".
	    "    Failed to reconfig/restart DHCPD.\n");
    }

    # Reboot the experimental nodes. They will come up inside the inner elab.
    # DO NOT WAIT! They are not going to report ISUP from this point on. 
    print "Rebooting inner new experimental nodes.\n";
    TBDebugTimeStamp("Rebooting experimental nodes");
    system("$nodereboot @nodes");
    if ($?) {
	die("*** $0:\n".
	    "    Error rebooting the nodes (@nodes)!\n");
    }
    $EUID = 0;

    #
    # At this point, not much I can think of do. The nodes will reboot and
    # enter the newnode MFS. I could add a script to wait for that in the
    # inner elab, but not going to bother yet. 
    #
    # To avoid confusion later (with swapmod, which wants them to be ISUP),
    # and so the web interface does not show the nodes as down, set the 
    # state to ISUP.
    #
    foreach my $node (@nodes) {
	TBSetNodeEventState($node, TBDB_NODESTATE_ISUP());
    }
    return 0;
}
