#!/usr/bin/perl -w
#
# EMULAB-COPYRIGHT
# Copyright (c) 2005-2011 University of Utah and the Flux Group.
# All rights reserved.
#
package libvtop_stable;

use strict;
use Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK
	    $VTOP_FLAGS_UPDATE $VTOP_FLAGS_VERBOSE $VTOP_FLAGS_QUIET
	    $VTOP_FLAGS_FIXNODES $VTOP_FLAGS_IMPOTENT $VTOP_FLAGS_ALLOCONLY
	    $VTOP_FLAGS_REGRESSION);

@ISA    = "Exporter";
@EXPORT = qw( );

use libdb;
use libtblog_simple;
use libtestbed;
use Experiment;
use VirtExperiment;
use Node;
use NodeType;
use Lan;
use OSinfo;
use Port;
use English;
use Data::Dumper;
use Carp;
use POSIX;
use XML::LibXML;
use XML::Simple;

# Configure variables
my $TB		  = "@prefix@";
my $BOSSNODE      = "@BOSSNODE@";
my $AVAIL         = "$TB/bin/avail";
my $NALLOC        = "$TB/bin/nalloc";
my $NFREE         = "$TB/bin/nfree";
my $OS_SELECT     = "$TB/bin/os_select";
my $DELAYCAPACITY = @DELAYCAPACITY@;	# Can be overridden by user.
my $DELAYTHRESH   = @DELAYTHRESH@;
my $PGENISUPPORT  = @PROTOGENI_SUPPORT@;
my $OURDOMAIN     = "@OURDOMAIN@";
my $mycmurn;

if ($PGENISUPPORT) {
    require GeniHRN;
    $mycmurn = GeniHRN::Generate("@OURDOMAIN@", "authority", "cm");
}

# Flags.
$VTOP_FLAGS_VERBOSE	= 0x01;
$VTOP_FLAGS_UPDATE	= 0x02;
$VTOP_FLAGS_FIXNODES	= 0x04;
$VTOP_FLAGS_IMPOTENT	= 0x08;
$VTOP_FLAGS_REGRESSION  = 0x10;
$VTOP_FLAGS_QUIET       = 0x20;
$VTOP_FLAGS_ALLOCONLY	= 0x40;

@EXPORT_OK = qw($VTOP_FLAGS_UPDATE $VTOP_FLAGS_VERBOSE $VTOP_FLAGS_FIXNODES
		$VTOP_FLAGS_IMPOTENT $VTOP_FLAGS_REGRESSION $VTOP_FLAGS_QUIET
		$VTOP_FLAGS_ALLOCONLY);

#
# Create an object representing the stuff we need to create the vtop file.
#
sub Create($$$$)
{
    my ($class, $experiment, $user, $flags) = @_;

    my $virtexperiment = VirtExperiment->Lookup($experiment);
    if (!defined($virtexperiment)) {
	tberror("Could not load virtual experiment object for $experiment\n");
	return undef;
    }

    my $self              = {};
    $self->{'EXPERIMENT'} = $experiment;
    $self->{'USER'}       = $user;
    $self->{'VIRTEXPT'}   = $virtexperiment;
    $self->{'FLAGS'}      = $flags;
    $self->{'VNODES'}     = {};
    $self->{'DELAYNODES'} = {};
    $self->{'LANNODES'}   = {};
    $self->{'BRIDGES'}    = {};
    $self->{'VLANS'}      = {};
    $self->{'VPATHS'}     = {};
    $self->{'MEMBEROF'}   = {};
    $self->{'COUNTERS'}   = {};
    $self->{'EXPTSTATS'}  = {};
    $self->{'DELAYLINKS'} = {};
    $self->{'VLINKS'}     = {};
    $self->{'OPTIONS'}    = {};
    $self->{'DELAYID'}    = 0;
    $self->{'PHOSTID'}    = 0;
    $self->{'IFACEID'}    = 32768;
    $self->{'PORTBW'}     = {};
    $self->{'RESULTS'}    = { "nodes"  => [],
			      "links"  => [],
			      "class"  => [],
			      "fixed"  => [] };
    $self->{'RSPEC'}      = {};
    $self->{'GENIRSPEC'}  = undef;

    # Mostly for update mode.
    $self->{'FIXEDNODES'}  = {};
    $self->{'CURRENT_V2P'} = {};
    $self->{'CURRENT_P2V'} = {};
    $self->{'CURRENT_V2V'} = {};
    $self->{'OLDRSRVCLEAN_FLAG'}  = 0;
    $self->{'OLDRSRVCLEAN_NODES'} = {};

    # Below is for interpretation of assign results.
    $self->{'PNODES'}      = {};
    $self->{'SOLUTION'}    = {};
    $self->{'NEWRESERVED'} = {};	# Newly reserved nodes.
    $self->{'NORECOVER'}   = 0;	
    
    bless($self, $class);
    $virtexperiment->Dump()
	if (0 && $self->verbose());

    return $self;
}
# accessors
sub experiment($)       { return $_[0]->{'EXPERIMENT'}; }
sub user($)             { return $_[0]->{'USER'}; }
sub virtexperiment($)   { return $_[0]->{'VIRTEXPT'}; }
sub flags($)            { return $_[0]->{'FLAGS'}; }
sub vnodes($)           { return $_[0]->{'VNODES'}; }
sub delaynodes($)       { return $_[0]->{'DELAYNODES'}; }
sub bridges($)          { return $_[0]->{'BRIDGES'}; }
sub lannodes($)         { return $_[0]->{'LANNODES'}; }
sub vlans($)            { return $_[0]->{'VLANS'}; }
sub memberof($)         { return $_[0]->{'MEMBEROF'}; }
sub vpaths($)           { return $_[0]->{'VPATHS'}; }
sub counters($)         { return $_[0]->{'COUNTERS'}; }
sub counter($$)         { return $_[0]->{'COUNTERS'}->{$_[1]}; }
sub options($)          { return $_[0]->{'OPTIONS'}; }
sub option($$)          { return (exists($_[0]->{'OPTIONS'}->{$_[1]}) ?
				  $_[0]->{'OPTIONS'}->{$_[1]} : undef); }
sub exptstats($)        { return $_[0]->{'EXPTSTATS'}; }
sub vlinks($)           { return $_[0]->{'VLINKS'}; }
sub delaylinks($)       { return $_[0]->{'DELAYLINKS'}; }
sub delaynodecount()    { return scalar(keys(%{ $_[0]->delaynodes() })); }
sub portbw($)           { return $_[0]->{'PORTBW'}; }
sub results($)          { return $_[0]->{'RESULTS'}; }
sub current_v2p($)      { return $_[0]->{'CURRENT_V2P'}; }
sub current_p2v($)      { return $_[0]->{'CURRENT_P2V'}; }
sub current_v2v($)      { return $_[0]->{'CURRENT_V2V'}; }
sub pnodes($)           { return $_[0]->{'PNODES'}; }
sub fixednodes($)       { return $_[0]->{'FIXEDNODES'}; }
sub newreserved($)      { return $_[0]->{'NEWRESERVED'}; }
sub rspec($)            { return $_[0]->{'RSPEC'}; }
sub genirspec($)        { return $_[0]->{'GENIRSPEC'}; }
sub newreservednodes($) { return keys(%{ $_[0]->{'NEWRESERVED'} }); }
sub oldreservednodes($) { return $_[0]->{'OLDRSRVCLEAN_NODES'}; }
sub norecover($)        { return $_[0]->{'norecover'}; }
sub pid($)		{ return $_[0]->experiment()->pid(); }
sub pid_idx($)		{ return $_[0]->experiment()->pid_idx(); }
sub eid($)		{ return $_[0]->experiment()->eid(); }
sub exptidx($)		{ return $_[0]->experiment()->idx(); }

# The virtual tables from the DB.
sub virt_table($$)      { return $_[0]->virtexperiment()->Table($_[1]); }
sub virt_vtypes($)	{ return $_[0]->virt_table("virt_vtypes"); }
sub virt_nodes($)       { return $_[0]->virt_table("virt_nodes"); }
sub virt_lans($)        { return $_[0]->virt_table("virt_lans"); }
sub virt_lan_lans($)    { return $_[0]->virt_table("virt_lan_lans"); }
sub virt_paths($)       { return $_[0]->virt_table("virt_paths"); }
sub virt_bridges($)     { return $_[0]->virt_table("virt_bridges"); }
sub virt_desires($)	{ return $_[0]->virt_table("virt_node_desires"); }
sub virt_startloc($)	{ return $_[0]->virt_table("virt_node_startloc"); }
sub virt_trafgens($)	{ return $_[0]->virt_table("virt_trafgens"); }
sub virt_lan_settings($){ return $_[0]->virt_table("virt_lan_settings"); }
sub virt_lan_member_settings($)	{
    return $_[0]->virt_table("virt_lan_member_settings"); }

# Given a vname, is it a node in the topo (or something else like a delay).
sub isatoponode($$)     { return exists($_[0]->vnodes()->{$_[1]}); }
sub isadelaynode($$)    { return exists($_[0]->delaynodes()->{$_[1]}); }

# Debug output.
sub verbose($)		{ return $_[0]->flags() & $VTOP_FLAGS_VERBOSE; }
sub quiet($)		{ return $_[0]->flags() & $VTOP_FLAGS_QUIET; }
sub updating($)		{ return $_[0]->flags() & $VTOP_FLAGS_UPDATE; }
sub fixcurrent($)	{ return $_[0]->flags() & $VTOP_FLAGS_FIXNODES; }
sub impotent($)		{ return $_[0]->flags() & $VTOP_FLAGS_IMPOTENT; }
sub alloconly($)	{ return $_[0]->flags() & $VTOP_FLAGS_ALLOCONLY; }
sub regression($)	{ return $_[0]->flags() & $VTOP_FLAGS_REGRESSION; }
sub printdb($$)		{ print $_[1] if ($_[0]->verbose()); return 1; }

# We name delay nodes internally as they are needed.
sub nextdelayname($)    { return "tbdelay" . $_[0]->{'DELAYID'}++; }
# For when the user wants a specific delay os. Use a desire.
# sub delay_desire($)	{ return $_[0]->option("delay_desire_string"); }
sub delay_desire_type($)	{ return $_[0]->option("delay_desire_type"); }
sub delay_desire_name($)	{ return $_[0]->option("delay_desire_name"); }
sub delay_desire_penalty($)	{ return $_[0]->option("delay_desire_penalty"); }
# For XML
sub nextifacenumber($)  { return $_[0]->{'IFACEID'}++; }
sub nextphostnumber($)  { return $_[0]->{'PHOSTID'}++; }

# Virtual Types. 
sub virttypeisvtype($$) { return $_[0]->virt_vtypes()->Find($_[1]); }
sub VirtTypes($)        { return $_[0]->virt_vtypes()->Rows(); }

# Caller will want these.
sub minimum_nodes($)    { return $_[0]->counter("minimum_nodes"); }
sub maximum_nodes($)    { return $_[0]->counter("maximum_nodes"); }
sub nodecount($)	{ return $_[0]->counter("nodecount"); }
sub plabcount($)	{ return $_[0]->counter("plabcount"); }
sub genicount($)	{ return $_[0]->counter("genicount"); }
sub virtnodecount($)	{ return $_[0]->counter("virtcount"); }
sub simnodecount($)	{ return $_[0]->counter("simcount"); }
sub remotenodecount($)	{ return $_[0]->counter("remotecount"); }
sub sharednodecount($)	{ return $_[0]->counter("sharedcount"); }

sub createLink($$$$$$$$$)
{
    # $others here will be a hashtable for the link flags.  The table
    # could also contain non-default values for latency and
    # packet_loss
    my ($self, $name, $plink, $cm, $src, $dst, $bw, $type, $others) = @_;
    my $ref = {
	'virtual_id'     => $name,
	'plink'		 => $plink,
	'manager_urn'    => $cm,
	'link_type'      => $type,
	'interface_ref'  => [$src, $dst],
	'capacity'       => $bw,
	'packet_loss'    => "0",
	'latency'        => "0"
    };
    
    if ($others) {
	while ( my ($key, $value) = each %{$others} ) {
	    $ref->{$key} = $value;
	}
    }
    if (!exists($self->rspec()->{'link'})) {
	$self->rspec()->{'link'} = [];
    }
    push(@{ $self->rspec()->{'link'} }, $ref);
}

sub createNode ($$$$$$$;$)
{
    # $others here will be a hashtable for the desires
    # The key will be the desire name and the value will be a pair
    # of the desire type and the penalty
    my ($self, $name, $cm, $type, $typecount, $desires, $others, $ifaces) = @_;
    my $ref = {
	'virtual_id'    => $name,
	'manager_urn'   => $cm,
    };
    
    my $typename = $type;
    my $typeslots = $typecount;
    my $isstatic = 0;
    if ($typename =~ /^\*([-\w]*)$/) {
	$typename = $1;
	$isstatic = 1;
    }
    if ($typecount eq '*') {
	$typeslots = 'unlimited';
    }

    # We will need this to generate interface names later
    $ref->{'interface_count'} = 0;
    $ref->{'interfaces'} = $ifaces;

    $ref->{'node_type'} = $typename;
    $ref->{'type_slots'} = $typecount;
    $ref->{'node_static'} = $isstatic;

    my $desiretable = {};
    if ($desires) {
	while ( my ($key, $value) = each %{$desires} ) {
	    $desiretable->{$key} = $value;
	}
    }
    $ref->{'desires'} = $desiretable;
    
    if ($others) {
	while ( my ($key, $value) = each %{$others} ) {
	    $ref->{$key} = $value;
	}
    }
    
    if (!exists($self->rspec()->{'node'})) {
	$self->rspec()->{'node'} = [];
    }
    push(@{ $self->rspec()->{'node'} }, $ref);
}

sub createVClass ($$$$)
{
    my ($self, $name, $weight, $members) = @_;
    my $ref = {
	'name'    => $name,
	'weight'  => $weight,
	'members' => $members
    };
    if (!exists($self->rspec()->{'vclass'})) {
	$self->rspec()->{'vclass'} = [];
    }
    push(@{ $self->rspec()->{'vclass'} }, $ref);
}

sub createFixedNode ($$$)
{
    my ($self, $vnode, $pnode) = @_;
    my $ref = { 'vnode' => $vnode,
		# XXX Going to need a URN in rspec output ...
		'pnode' => $pnode,
    };
    if (!exists($self->rspec()->{'fixed'})) {
	$self->rspec()->{'fixed'} = [];
    }
    push(@{ $self->rspec()->{'fixed'} }, $ref);
}

###############################################################################
# Virtual Nodes. A separate package so we can create objects for each one
# and then add local stuff to them.
#
package libvtop::virt_node;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_node()->$name();
    }
}

#
# Wrap up a virt node.
#
sub Create($$$)
{
    my ($class, $vtop, $virt_node) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTNODE'}   = $virt_node;
    $self->{'VTOP'}       = $vtop;
    $self->{'HASH'}       = {};
    # The virtlans this virtnode is a member of. 
    $self->{'MEMBERSHIP'} = {};
    
    return $self;
}
# accessors
sub virt_node($)	{ return $_[0]->{'VIRTNODE'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub membership($)       { return $_[0]->{'MEMBERSHIP'}; }
sub memberlist($)       { return values(%{ $_[0]->{'MEMBERSHIP'} }); }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTNODE'}   = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
    $self->{'MEMBERSHIP'} = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->vname();

    return "[vnode:$vname]";
}

###############################################################################
# Virtual Lans. This wraps up the virt_lan_lan table, and allows storing
# the members (virt_lans table entries).
#
package libvtop::virt_lan;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_lanlan()->$name();
    }
}

#
# Wrap up a virt lan.
#
sub Create($$$$)
{
    my ($class, $vtop, $virt_lanlan) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTLANLAN'}    = $virt_lanlan;
    $self->{'VTOP'}          = $vtop;
    $self->{'MEMBERHASH'}    = {};
    $self->{'MEMBERLIST'}    = [];
    $self->{'SHAPEDMEMBERS'} = {};
    $self->{'HASH'}          = {};

    return $self;
}
# accessors
sub virt_lanlan($)	{ return $_[0]->{'VIRTLANLAN'}; }
sub members($)		{ return $_[0]->{'MEMBERHASH'}; }
sub memberlist($)       { return @{ $_[0]->{'MEMBERLIST'} }; }
sub member($$)          { return @{ $_[0]->{'MEMBERLIST'} }[$_[1]]; }
sub shapedmembers($)	{ return $_[0]->{'SHAPEDMEMBERS'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub islink($)           { return (@{ $_[0]->{'MEMBERLIST'} } == 2 ? 1 : 0); }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTLANLAN'} = undef;
    $self->{'MEMBERHASH'} = undef;
    $self->{'MEMBERLIST'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->vname();

    return "[vlan:$vname]";
}

sub addmember($$)
{
    my ($self, $vlanmember) = @_;
    
    $self->members()->{$vlanmember->member()} = $vlanmember;

    @{ $self->{'MEMBERLIST'} }[$vlanmember->vindex()] = $vlanmember;

    return 0;
}

#
# Other support functions.
#
sub usevirtiface($)
{
    my ($self) = @_;
    my $encap  = $self->_encapstyle();

    return ($encap eq "veth-ne" || $encap eq "vlan");
}
sub membershaped($$) {
    my ($self, $member) = @_;
    return $self->shapedmembers()->{"$member"};
}
sub setmembershaped($$) {
    my ($self, $member) = @_;
    $self->shapedmembers()->{"$member"} = 1;
    $member->_shaped(1);
}

###############################################################################
# Virtual Lans Member. A separate package so we can create objects for
# each one and then add local stuff to them.
#
package libvtop::virt_lan_member;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify', 'eq' => 'StringEQ');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_member()->$name();
    }
}

#
# Wrap up a virt lan member.
#
sub Create($$$$)
{
    my ($class, $vtop, $virt_member, $virt_lan) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'VIRTMEMBER'} = $virt_member;
    $self->{'VIRTLAN'}    = $virt_lan;
    $self->{'VIRTNODE'}   = $vtop->vnodes()->{$virt_member->vnode()};
    $self->{'VTOP'}       = $vtop;
    $self->{'HASH'}       = {};

    return $self;
}
# accessors
sub virt_member($)	{ return $_[0]->{'VIRTMEMBER'}; }
sub virt_lan($)		{ return $_[0]->{'VIRTLAN'}; }
sub virt_node($)	{ return $_[0]->{'VIRTNODE'}; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'VIRTLAN'}    = undef;
    $self->{'VIRTNODE'}   = undef;
    $self->{'VIRTMEMBER'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vnode  = $self->vnode();
    my $vport  = $self->vport();

    return "$vnode:$vport";
}

sub StringEQ($$)
{
    my ($self, $other) = @_;

    return ($self->Stringify() eq "$other" ? 1 : 0);
}

sub usevirtiface($)
{
    my ($self) = @_;
    my $encap  = $self->_encapstyle();

    return ($encap eq "veth-ne" || $encap eq "vlan");
}

###############################################################################
# Virtual Paths This wraps up the virt_paths table
#
package libvtop::virt_path;
use Carp;
use vars qw($AUTOLOAD);
use overload ('""' => 'Stringify');

# To avoid wrtting out all the methods.
sub AUTOLOAD {
    my $self = shift;
    my $type = ref($self) or croak "$self is not an object";

    my $name = $AUTOLOAD;
    $name =~ s/.*://;   # strip fully-qualified portion

    if (@_) {
	return $self->{'HASH'}->{$name} = shift;
    }
    elsif (exists($self->{'HASH'}->{$name})) {
	return $self->{'HASH'}->{$name};
    }
    else {
	return $self->virt_path()->$name();
    }
}

#
# Wrap up a virt path
#
sub Create($$$$)
{
    my ($class, $vtop, $pathname, $layer) = @_;

    my $self = {};
    bless($self, $class);

    $self->{'PATHNAME'}      = $pathname;
    $self->{'LAYER'}         = $layer;
    $self->{'VTOP'}          = $vtop;
    $self->{'MEMBERHASH'}    = {};
    $self->{'MEMBERLIST'}    = [];
    $self->{'VIRTLANHASH'}   = {};
    $self->{'VIRTLANLIST'}   = [];
    $self->{'IMPLEMENTS'}    = {};
    $self->{'HASH'}          = {};

    return $self;
}
# accessors
sub pathname($)		{ return $_[0]->{'PATHNAME'}; }
sub layer($)		{ return $_[0]->{'LAYER'}; }
sub members($)		{ return $_[0]->{'MEMBERHASH'}; }
sub memberlist($)       { return @{ $_[0]->{'MEMBERLIST'} }; }
sub virtlanlist($)      { return @{ $_[0]->{'VIRTLANLIST'} }; }
sub member($$)		{ return $_[0]->{'MEMBERLIST'}->[$_[1]]; }
sub lanlink($$)		{ return $_[0]->{'VIRTLANLIST'}->[$_[1]]; }
sub vtop($)		{ return $_[0]->{'VTOP'}; }
sub hash($)		{ return $_[0]->{'HASH'}; }
sub implements($)	{ return $_[0]->{'IMPLEMENTS'}; }

# Break circular reference someplace to avoid exit errors.
sub DESTROY {
    my $self = shift;

    $self->{'LAYER'}      = undef;
    $self->{'PATHNAME'}   = undef;
    $self->{'MEMBERHASH'} = undef;
    $self->{'MEMBERLIST'} = undef;
    $self->{'VIRTLANHASH'} = undef;
    $self->{'VIRTLANLIST'} = undef;
    $self->{'VTOP'}       = undef;
    $self->{'IMPLEMENTS'} = undef;
    $self->{'HASH'}       = undef;
}

sub Stringify($)
{
    my ($self) = @_;
    my $vname  = $self->pathname();
    my $layer  = $self->layer();

    return "[vpath:$vname:$layer]";
}

sub addmember($$$)
{
    my ($self, $vpath, $virtlan) = @_;
    
    $self->members()->{$vpath->segmentname()} = $vpath;
    $self->{'VIRTLANHASH'}->{$vpath->segmentname()} = $virtlan;
    # We care about this ordering.
    $self->{'MEMBERLIST'}->[$vpath->segmentindex()]  = $vpath;
    $self->{'VIRTLANLIST'}->[$vpath->segmentindex()] = $virtlan;
    return 0;
}

sub firstmember($)
{
    my ($self) = @_;

    # The lanlink for the first segment.
    my $virtlan = $self->lanlink(0);

    # Both members of a link.
    my ($member0,$member1) = $virtlan->memberlist();

    # The first member.
    return $member0;
}

sub lastmember($)
{
    my ($self) = @_;

    # The lanlink for the last segment.
    my $virtlan = $self->lanlink(scalar($self->memberlist()) - 1);

    # Both members of a link.
    my ($member0,$member1) = $virtlan->memberlist();

    # The last member.
    return $member1;
}

sub addimplements($$)
{
    my ($self, $virtlan) = @_;

    $self->implements()->{$virtlan->vname()} = $virtlan;
}
sub doesimplement($$)
{
    my ($self, $virtlan) = @_;

    return exists($self->implements()->{$virtlan->vname()});
}

#############################################################################
# Back to the main package.
#
package libvtop_stable;

#
# Load some physical info (for types, interfaces, speeds).
#
sub LoadPhysInfo($)
{
    my ($self) = @_;

    $self->printdb("Loading physical info\n");

    #
    # Interface capabilities, for getting speeds.
    #
    my %interface_capabilities = ();

    my $query_result =
	DBQueryWarn("select * from interface_capabilities");
    return -1
	if (!$query_result);

    while (my ($type, $capkey, $capval) = $query_result->fetchrow()) {
	$interface_capabilities{$type} = {}
  	    if (!defined($interface_capabilities{$type}));
	$interface_capabilities{$type}->{$capkey} = $capval;
    }

    #
    # Now get interface speeds for each type/class. We use this for
    # determining if a delay node is required. Very hacky, quite
    # wrong.
    #
    my %node_type_linkbw = ();
    
    # XXX: PlanetLab hack - PlanetLab 'control' interfaces are also
    # 'experimental' interfaces! We probably need a way to express
    # this in the interfaces table or interface_types
    #
    $query_result =
	DBQueryWarn("select distinct i.interface_type,n.type ".
		    "  from interfaces as i ".
		    "left join nodes as n on n.node_id=i.node_id ".
		    "where i.role='" . TBDB_IFACEROLE_EXPERIMENT . "' ".
		    "      or (n.type='pcplabphys' and i.role='" .
		                 TBDB_IFACEROLE_CONTROL . "')");
    return -1
	if (!$query_result);

    # XXX Special hack for sim nodes.
    $node_type_linkbw{"sim"} = {};

    while (my ($iface_type, $node_type) = $query_result->fetchrow()) {
	my $typeinfo = NodeType->Lookup($node_type);
	if (!defined($typeinfo)) {
	    warn("No type info for node type $node_type\n");
	    return -1;
	}
	my $node_class = $typeinfo->class();

	$node_type_linkbw{$node_type} = {}
	    if (!defined($node_type_linkbw{$node_type}));
	$node_type_linkbw{$node_class} = {}
	    if (!defined($node_type_linkbw{$node_class}));

	if (!defined($interface_capabilities{$iface_type}->{"protocols"})) {
	    warn("No protocols listed in capabilities for $iface_type!\n");
	    return -1;
	}
	my @protolist =
	    split(",", $interface_capabilities{$iface_type}->{"protocols"});

	foreach my $proto (@protolist) {
	    my $def_speed =
		$interface_capabilities{$iface_type}->{"${proto}_defspeed"};

	    if (!defined($def_speed)) {
		warn("No default speed in capabilites for $iface_type!\n");
		return -1;
	    }

	    my $auxspeeds =
		$interface_capabilities{$iface_type}->{"${proto}_auxspeeds"};
	    my @auxspeedlist = ();
	    if ($auxspeeds) {
		@auxspeedlist = split(",", $auxspeeds);
	    }

	    foreach my $speed ($def_speed, @auxspeedlist) {
		$node_type_linkbw{$node_type}{$proto}->{$speed} = 1;
		$node_type_linkbw{$node_class}{$proto}->{$speed} = 1;

		#
		# If the type/class has a non-zero simnode capacity, then add
		# entries for the interface speed so that requires_delay can
		# figure out interface speeds the underlying node type
		# supports.
		#
		if ($typeinfo->simnode_capacity()) {
		    $node_type_linkbw{"sim"}{$proto}->{$speed} = 1;
		}
	    }
	}
    }

    #
    # Ug, it just gets worse and worse. We also need to map between the
    # auxtypes that a node (its physical type) can take on. For example,
    # a link between two pcvm nodes is really a link between a pc600 and
    # pc850.
    #
    $query_result =
	DBQueryFatal("select distinct n.type,at.type from node_auxtypes as at ".
		     "left join nodes as n on n.node_id=at.node_id");

    while (my ($phystype, $auxtype) = $query_result->fetchrow()) {
	next
	    if (!exists($node_type_linkbw{$phystype}));
	
	$node_type_linkbw{$auxtype} = $node_type_linkbw{$phystype};
    }

    #
    # Here it goes getting even worse - we have to do a similar thing for
    # vtypes.
    #
    foreach my $ref ($self->VirtTypes()) {
	my $vtype   = $ref->name();
	my @members = split(" ", $ref->members());

	foreach my $phystype (@members) {
	    next
		if (!exists($node_type_linkbw{$phystype}));

	    $node_type_linkbw{$vtype} = {}
	        if (!defined($node_type_linkbw{$vtype}));

	    foreach my $protocol (keys(%{ $node_type_linkbw{$phystype} })) {
		my @list = keys(%{ $node_type_linkbw{$phystype}{$protocol} });
		foreach my $speed (@list) {
		    $node_type_linkbw{$vtype}{$protocol}->{$speed} = 1;
		}
	    }
	}
    }

    if ($self->verbose()) {
	$self->printdb("Interface Speeds:\n");
	foreach my $type (keys(%node_type_linkbw)) {
	    foreach my $protocol (keys(%{ $node_type_linkbw{$type} })) {
		my @list = keys(%{ $node_type_linkbw{$type}{$protocol} });

		$self->printdb(" $type:$protocol - @list\n");
	    }
	}
    }
    
    $self->{'IFACECAPS'}  = \%interface_capabilities;
    $self->{'TYPELINKBW'} = \%node_type_linkbw;
    
    return 0;
}
sub interfacespeedmbps($$$)
{
    my ($self, $type, $which) = @_;
        
    return $self->{'IFACECAPS'}->{$type}->{"${which}_defspeed"}/1000.0;
}

#
# When updating with fixednodes turned on, we need the current set
# of nodes that need to be fixed.
#
sub LoadCurrentResources($)
{
    my ($self) = @_;

    $self->counters()->{'reserved_simcount'}  = 0;
    $self->counters()->{'reserved_virtcount'} = 0;
    $self->counters()->{'reserved_physcount'} = 0;

    $self->printdb("Loading current resources" .
		   ($self->regression() ? " in regression mode" : "") . "\n");

    my @nodelist = $self->experiment()->NodeList(0, 1);
    return 0
	if (!@nodelist);

    if ($self->regression()) {
	#
	# In regression mode, we just store the p2v mapping for fixnode.
	#
	foreach my $pnode (@nodelist) {
	    my $vname   = $pnode->vname();
	    my $node_id = $pnode->node_id();

	    if ($pnode->isvirtnode()) {
		$node_id = $pnode->phys_nodeid();
	    }
	    $self->fixednodes()->{$vname} = $node_id;
	    $self->printdb("  fixing $vname -> $node_id\n");
	}
	return 0;
    }

    foreach my $pnode (@nodelist) {
	my $vname   = $pnode->vname();
	my $node_id = $pnode->node_id();
	my $rsrv    = $pnode->ReservedTableEntry();

	# A list of vnodes on this pnode.
	$self->current_p2v()->{$pnode->phys_nodeid()} = []
	    if (! exists($self->current_p2v()->{$pnode->phys_nodeid()}));
	$self->pnodes()->{$node_id} = $pnode;

	#
	# WIDEAREA nodes are going to break.
	#
	if ($pnode->isremotenode() &&
	    !($pnode->isplabdslice() || $pnode->isfednode() ||
	      $pnode->isdedicatedremote())) {
	    tberror("Cannot update widearea nodes yet!\n");
	    return -1;
	}
	if ($pnode->isvirtnode()) {
	    $self->counters()->{'reserved_virtcount'}++;

	    # Get the underlying physical node.
	    my $ppnode = Node->Lookup($pnode->phys_nodeid());
	    if (!defined($ppnode)) {
		tberror("Cannot map $pnode to its real physnode");
		return -1;
	    }
	    my $ppnode_id = $ppnode->node_id();

	    $self->fixednodes()->{$vname} = $ppnode_id
		if ($self->fixcurrent());
	    
	    #
	    # Record the mappings. 
	    #
	    $self->current_v2v()->{$vname} = $pnode->node_id();
	    $self->current_v2p()->{$vname} = $ppnode->node_id();
	    push(@{ $self->current_p2v()->{$ppnode->node_id()} }, $vname);
	    
	    # Mark the node as unused until later.
	    $pnode->_reuse("unused");
	    $ppnode->_reuse("unused");

	    #
	    # Add the pnode node to the oldreserved list for nfree.
	    # See the comment below. We cannot use p2v because we
	    # might not own all those nodes, if on a shared node.
	    # We do not add the ppnode. It will get added in the
	    # next clause if we actually own it.
	    #
	    $self->oldreservednodes()->{$pnode->node_id()} = $pnode;
	    
	    $self->printdb("current v2p: $node_id ($ppnode_id) -> $vname\n");
	}
	else {
	    #
	    # All the sim stuff is bit rotting cause no one understands it.
	    #
	    if ($rsrv->{'erole'} eq TBDB_RSRVROLE_SIMHOST) {
		tberror("Cannot update sim nodes yet!\n");
		return -1;
	    }
	    else {
		$self->fixednodes()->{$vname} = $pnode->node_id()
		    if ($self->fixcurrent());
		
		$self->counters()->{'reserved_physcount'}++;

		#
		# Record the mapping. 
		#
		$self->current_v2p()->{$vname} = $pnode->node_id();
		push(@{ $self->current_p2v()->{$node_id} }, $vname);
		# Mark the node as unused until later.
		$pnode->_reuse("unused");

		#
		# Add the pnode node to the oldreserved list for nfree.
		# See the comment below. We cannot use p2v because we
		# might not own all those nodes, if on a shared node.
		#
		$self->oldreservednodes()->{$pnode->node_id()} = $pnode;

		$self->printdb("current v2p: $node_id -> $vname\n");
	    }
	}
    }
    return 0;
}

sub LoadVirtNodes($)
{
    my ($self) = @_;
    my $gotgeninodes = 0;

    $self->printdb("Loading virtual nodes\n");

    my $pid    = $self->pid();
    my $eid    = $self->eid();
    my $table  = $self->virt_nodes();

    foreach my $virt_node ($table->Rows()) {
	my $vnode    = libvtop::virt_node->Create($self, $virt_node);
	my $vname    = $vnode->vname();
	my $desires  = {};
	my $startloc = undef;

	# Other fields we need.
	my $ips     = $vnode->ips() || "";
	my $type    = $vnode->type();
	my $fixed   = $vnode->fixed();
	my $osname  = $vnode->osname();
	my $parent_osname  = $vnode->parent_osname();

	# XXX
	# If its a vtype, there will not be any node_type data. This
	# can break things, if one were to mix a virt/remote type with
	# a nonvirt/local type! Need to actually verify the vtypes
	# for consistency. 
	#
	my $isremote= 0;
	my $isvirt  = 0;
	my $issub   = 0;
	my $isplab  = 0;
	my $issim   = 0;
	my $isdyn   = 0;	# Only virtnodes are dynamic.
	my $isvtyped= 0;
	my $isded   = 0;
	my $isgeni  = 0;

	# If we have a real type or auxtype ...
	my $nodetype = NodeType->LookupAny($type);
	if (!defined($nodetype)) {
	    my $vtype = $self->virttypeisvtype($type);
	    if (!defined($vtype)) {
		warn("Improper type $type for node $vnode!\n");
		return -1;
	    }
	    #
	    # For now, just pick the first member type.
	    #
	    my @memberlist = split(" ", $vtype->members());
	    my $vtypename  = $memberlist[0];

	    $nodetype = NodeType->LookupAny($vtypename);
	    if (!defined($nodetype)) {
		warn("Improper type $vtypename in vtypes for node $vnode!\n");
		return -1;
	    }
	    $isvtyped = 1;
	}
	$vnode->_typeinfo($nodetype);
	
	$isremote = $nodetype->isremotenode();
	$isvirt   = $nodetype->isvirtnode();
	$issub    = $nodetype->issubnode();
	$isplab   = $nodetype->isplabdslice();
	$isgeni   = $nodetype->isfednode();
	$issim    = $nodetype->issimnode();
	$isdyn    = $nodetype->isdynamic();
	$isded    = $nodetype->isdedicatedremote();

	# Mark this as being a virtual typed node.
	$vnode->_isvtyped($isvtyped);

	# dynamic inclusion below.
	$gotgeninodes++ if ($isgeni);

	# All this info is stashed in our local object.
	$vnode->_nodeweight(undef);
	$vnode->_isremotenode($isremote);
	$vnode->_isvirtnode($isvirt);
	$vnode->_issubnode($issub);
	$vnode->_isplabnode($isplab);
	$vnode->_isgeninode($isgeni);
	$vnode->_issimnode($issim);
	$vnode->_isdynamic($isdyn);
	$vnode->_isdedremote($isded);
	# Set below from a desire.
	$vnode->_sharedokay(0);
	$vnode->_fixedvm(undef);
	$vnode->_isbridge(($vnode->role() eq "bridge" ? 1 : 0));

	# For a list of interfaces on this node, as for rspec generation
	$vnode->_virtifaces([]);

	# dynamic inclusion below.
	$gotgeninodes++ if ($isgeni);

	# The mapped osname to actual osinfo structure.
	$vnode->_osinfo(undef);
	# If the virtnode tries to specify its parent os in addition
	# to its own, store that osinfo here.
	$vnode->_parent_osinfo(undef);
	# Eventual physical mapping. 
	$vnode->_physnode(undef);
	# Handy to combine these.
	$vnode->_settings([ $vnode->cmd_line(),
			    $vnode->rpms(),
			    $vnode->startupcmd(),
			    $vnode->tarfiles(),
			    $vnode->loadlist(),
			    $vnode->failureaction(),
			    $vnode->routertype() ]);

	#
	# If a subnode, kill the fixed mapping. That was just to
	# tell us the connection. We do not want to overload "fixed"
	# within assign wrapper since its already overloaded.
	#
	if ($issub) {
	    # Must be a parent. Set in the parser, either explicitly, or else
	    # one is created if the user leaves it out.
	    if (!defined($fixed) || $fixed eq "") {
		warn("Subnode $vname must be fixed to its parent!\n");
		return -1;
	    }
	    $vnode->_parent($fixed);
	    $vnode->fixed(undef);
	    undef($fixed);
	}

	# Can fixed really get set to ""?
	if (defined($fixed) && $fixed ne "") {
	    # Store the name since we use FIXED_NODES for delay nodes too.
	    $self->fixednodes()->{$vname} = $fixed;

	    # We do not know until all the nodes are loaded, if fixing
	    # to a physical node or another node in the topology. See
	    # the post pass loop below.
	    $vnode->_fixedvm($fixed)
		if ($isvirt && !$isgeni);
	}
	else {
	    $vnode->fixed(undef);
	    undef($fixed);
	}

	# For the moment, geni nodes must be bound to a CM.
	if ($isgeni) {
	    if (!defined($fixed) || $fixed eq "") {
		tberror("Geninode $vnode must be fixed to a CM.");
		return -1;
	    }
	    my ($authority,$gtype,undef) = GeniHRN::Parse($fixed);
	    #
	    # We allow an authority instead of a node urn. This is just a
	    # kludge so I can test against the AM interface. 
	    #
	    if ($gtype eq "node") {
		$vnode->_cmurn(GeniHRN::Generate($authority,
						 "authority", "cm"));
	    }
	    elsif ($gtype eq "authority") {
		$vnode->_cmurn($fixed);
		$fixed = GeniHRN::Generate($authority, "node", "*");
		$vnode->fixed($fixed);
	    }
	}
	else {
	    $vnode->_cmurn($mycmurn);
	}

	$self->printdb("  $vname type:$type ips:$ips\n");
	$self->printdb("         isrem:$isremote isvirt:$isvirt");
	$self->printdb(" fixed:$fixed")
	    if (defined($fixed) && $fixed ne "");
	$self->printdb("\n");
	
	# We need to check the names to make sure they do not clash with
	# our internal delay node names.
	if (($vname =~ /^tbdelay\d+/) ||
	    ($vname =~ /^tbsdelay\d+/)) {
	    print "Warning: $vname is a reserved name. Working around it.\n";
	    my ($num) = ($vname =~ /(\d+)/);
	    $self->delayid($num + 1);
	}

	# Take apart the IP list.
	my @iplist  = split(" ", $ips);
	foreach my $ipinfo (@iplist) {
	    my ($port,$ip) = split(":",$ipinfo);
	    
	    $self->{'IPS'}->{"$vname:$port"} = $ip;
	}

	#
	# Map the osname to an OSID now so that we can check max_concurrent.
	# This also avoids the work and *check* later after we have done 90%
	# of assign_wrapper. If no osname was specified, we have to wait and
	# use the default for the type of phys node that assign picks.
	#
	if (defined($osname) && $osname ne "") {
	    my $ospid = $pid;
	    
	    if ($osname =~ /^(.*)\/(.*)$/) {
		$ospid  = $1;
		$osname = $2;
	    }
	    my $osinfo = OSinfo->Lookup("$ospid,$osname");
	    if (!defined($osinfo)) {
		$osinfo = OSinfo->LookupByName($osname);

		if (!defined($osinfo)) {
		    tberror({cause => 'user', type => 'primary',
			     severity => SEV_ERROR,
			     error => ['invalid_os', undef, $osname, $ospid]},
			    "Invalid OS $osname in project $ospid!");
		    return -1;
		}
	    }
	    $vnode->_osinfo($osinfo);
	}
	elsif ($isvirt) {
	    my $osinfo;
	    if ($nodetype->type() eq "pcvm") {
		# Silly default.
		$osinfo = OSinfo->LookupByName("OPENVZ-STD");
	    }
	    else {
		# Grab it from the typeinfo.
		$osinfo = OSinfo->Lookup($nodetype->default_osid());
	    }
	    $vnode->_osinfo($osinfo);
	}

	#
	# Map the parent_osname to an OSID now.
	#
	if (defined($parent_osname) && $parent_osname ne "") {
	    my $ospid = $pid;
	    
	    if ($parent_osname =~ /^(.*)\/(.*)$/) {
		$ospid  = $1;
		$parent_osname = $2;
	    }
	    my $osinfo = OSinfo->Lookup("$ospid,$parent_osname");
	    if (!defined($osinfo)) {
		$osinfo = OSinfo->LookupByName($parent_osname);

		if (!defined($osinfo)) {
		    tberror({cause => 'user', type => 'primary',
			     severity => SEV_ERROR,
			     error => ['invalid_os',
				       undef, $parent_osname, $ospid]},
		    "Invalid parent OS $parent_osname in project $ospid!");
		    return -1;
		}
	    }
	    $vnode->_parent_osinfo($osinfo);
	}

	#
	# Add in desires.
	#
	foreach my $desire ($self->virt_desires()->Rows()) {
	    next
		if ($desire->vname() ne $vname);
	    
	    $desires->{$desire->desire()} = $desire->weight();

	    # User says a shared node is okay. We need this info later
	    # when generating links/lans for the vtop.
	    $vnode->_sharedokay(1)
		if ($isvirt && $desire->desire() eq "pcshared");
	}
	$vnode->_desires($desires);

	#
	# And the startloc, but doubt this is used anymore.
	#
	foreach my $startloc ($self->virt_startloc()->Rows()) {
	    if ($startloc->vname() eq $vname) {
		$startloc = $startloc->building();
		last;
	    }
	}
	$vnode->_startloc($startloc);

	# Counters
	$self->{'COUNTERS'}->{'nodecount'}++;
	$self->{'COUNTERS'}->{'simcount'}++
	    if ($issim);
	$self->{'COUNTERS'}->{'remotecount'}++
	    if ($isremote);
	$self->{'COUNTERS'}->{'virtcount'}++
	    if ($isvirt);
	$self->{'COUNTERS'}->{'plabcount'}++
	    if ($isplab);
	$self->{'COUNTERS'}->{'genicount'}++
	    if ($isgeni);
	$self->{'COUNTERS'}->{'physcount'}++
	    if (!$issim && !$isvirt);
	$self->{'COUNTERS'}->{'sharedcount'}++
	    if ($isvirt && $vnode->_sharedokay());
	# stats
	my $ipcount = scalar(@iplist);

	$self->exptstats()->{"maxlinks"} = $ipcount
	    if ($ipcount > $self->exptstats()->{"maxlinks"});
	$self->exptstats()->{"minlinks"} = $ipcount
	    if ($ipcount < $self->exptstats()->{"minlinks"});

	# Add to the list.
	$self->vnodes()->{$vname} = $vnode;
    }
    if ($gotgeninodes) {
	if ($PGENISUPPORT) {
	    require libGeni;
	    require GeniXML;
	    import GeniXML;
	}
	else {
	    tberror("Using geni nodes but PROTOGENI_SUPPORT is not defined\n");
	    return -1;
	}
    }

    #
    # Go back and look for any VMs that were fixed to nodes. Need to make
    # the OS consistent.
    #
    foreach my $vname (sort(keys(%{ $self->{'VNODES'} }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $osid;

	next
	    if ($vnode->_isgeninode());

	next
	    if (! ($vnode->_isvirtnode() && $vnode->_fixedvm()));
	
	my $fixnode = $self->vnodes()->{$vnode->_fixedvm()};
	#
	# If the node is fixed to a physical node, skip. This is a
	# plain old fixnode operation, not our new support for fixing
	# a VM to a real node in the topology.
	#
	if (!defined($fixnode)) {
	    # Lets make sure its a real node.
	    my $fixvname = $vnode->_fixedvm();
	    
	    if (!defined(Node->Lookup($fixvname))) {
		tberror("Cannot fix $vnode to $fixvname; No such node\n");
		return -1;
	    }
	    $vnode->_fixedvm(undef);
	    next;
	}

	if (defined($vnode->_parent_osinfo())) {
	    $osid = $vnode->_parent_osinfo()->osid();
	}
	else {
	    $osid  = ($self->option("jail_osid") ||
		      $self->nodejailosid($vnode));
	}
	return -1
	    if (!defined($osid));
	my $osinfo = OSinfo->Lookup($osid);
	return -1
	    if (!defined($osinfo));
	
	$fixnode->_osinfo($osinfo);
	# Convert from the name to the local object.
	$vnode->_fixedvm($fixnode);

	$self->printdb("Fixing VM $vname to $fixnode, $osinfo\n");
    }
    
    return 0;
}

sub LoadVirtLans($)
{
    my ($self) = @_;

    $self->printdb("Loading virtual lans\n");

    my $pid    = $self->pid();
    my $eid    = $self->eid();
    my $table  = $self->virt_lans();

    foreach my $virt_lan_member ($table->Rows()) {
	my $vlanname = $virt_lan_member->vname();

	# Local wrapper for virt_lan_lan table entry (the "lan").
	my $virtlan = $self->vlans()->{$vlanname};
	if (!defined($virtlan)) {
	    my $virt_lan_lan = $self->virt_lan_lans()->Find($vlanname);
	    $virtlan = libvtop::virt_lan->Create($self, $virt_lan_lan);
	    # Add it to the toplevel list of lans.
	    $self->vlans()->{$vlanname} = $virtlan;
	    $virtlan->_accesspoint(undef);
	}

	# Now the local wrapper for the virt_lan table entry (the "member").
	my $vlanmember = libvtop::virt_lan_member->Create($self,
							  $virt_lan_member,
							  $virtlan);

	# Which we add to the member hash for the lan by vnode:vport
	# Note that $vlanmember->member() returns vnode:port.
	$virtlan->addmember($vlanmember);

	# Global map from vnode:port back to the lan object
	$self->memberof()->{$vlanmember->member()} = $virtlan;

	# Each virt_node has a list of all virt_lans it belongs to.
	$vlanmember->virt_node()->membership()->{"$virtlan"} = $virtlan;

	# Other fields we need below
	my $delay          = $vlanmember->delay();
	my $bandwidth      = $vlanmember->bandwidth();
	my $est_bandwidth  = $vlanmember->est_bandwidth();
	my $backfill       = $vlanmember->backfill();
	my $lossrate       = $vlanmember->lossrate();
	my $rdelay         = $vlanmember->rdelay();
	my $rbandwidth     = $vlanmember->rbandwidth();
	my $rest_bandwidth = $vlanmember->rest_bandwidth();
	my $rbackfill      = $vlanmember->rbackfill();
	my $rlossrate      = $vlanmember->rlossrate();
	my $widearea       = $vlanmember->widearea();
	my $isemulated     = $vlanmember->emulated();
	my $uselinkdelay   = $vlanmember->uselinkdelay();
	my $nobwshaping    = $vlanmember->nobwshaping();
	my $trivial_ok     = $vlanmember->trivial_ok();
	my $protocol       = $vlanmember->protocol();
	my $mustdelay      = $vlanmember->mustdelay();
	my $encap          = $vlanmember->encap_style();
	my $mask           = $vlanmember->mask();
	my $ip             = $vlanmember->ip();
	my $layer          = $vlanmember->layer();
	my $implemented_by = $vlanmember->implemented_by_path();
	my $fixed_iface    = $vlanmember->fixed_iface();
	my ($vname,$vport) = split(":", $vlanmember->member());

	# virt_nodes:ips is actually deprecated; this overrides it.
	$self->{'IPS'}->{"$vname:$vport"} = $ip;

	#
	# So all this stuff is really per-lan state, but an artifact of
	# the original implementation is that it is duplicated in every
	# single member row. So, push the info up a level to make it easy
	# to figure out how each lan is set up.
	#

	# If RED, must insert traffic shapping.
	$virtlan->_mustdelay($mustdelay);
	# User has requested the link/lan be emulated. Not typical.
	$virtlan->_emulated($isemulated);
	# User has requested "endnodeshaping" (dummynet on end nodes).
	$virtlan->_uselinkdelay($uselinkdelay);
        # The nobwshaping flag is used in conjunction with emulated
        # links to turn off actual bw traffic shaping on an emulated
        # link. This allows assign to match the specified bws, but not
        # force them to be such with delay nodes (leaves it up to the
        # user to moderate the bw).
	$virtlan->_nobwshaping($nobwshaping);
	$virtlan->_encapstyle($encap);
	# User has said that colocating is okay. Not typical.
	$virtlan->_trivial_ok($trivial_ok);
	# Link is connected to a remote node, and gets a tunnel.
	$virtlan->_tunnel(0);
	# Netmask for the entire lan.
	$virtlan->_mask($mask);
	$virtlan->_widearea($widearea);
	# Whether all member nodes are simulated
	$virtlan->_allsim(0);
	$virtlan->_protocol($protocol);
	$virtlan->_layer($layer);
	$virtlan->_accesspoint($vlanmember)
	    if ($vlanmember->is_accesspoint());
	$virtlan->_sharednodes(0);
	$virtlan->_geninodes(0);
	$virtlan->_implemented_by($implemented_by);
	$virtlan->_vpath(undef);
	$virtlan->_bridged(0);
	
	if (defined($encap) &&
	    ($encap eq "vtun" || $encap eq "gre" || $encap eq "egre")) {
	    $virtlan->_tunnel(1);
	}

	# Store this stuff as a unit to make it easier to grab later.
	$vlanmember->_delayinfo([ $delay,
				  $bandwidth,
				  $est_bandwidth,
				  $backfill,
				  $lossrate,
				  $rdelay,
				  $rbandwidth,
				  $rest_bandwidth,
				  $rbackfill,
				  $rlossrate ]);

	#
	# Ditto for the Q stuff, which is not needed until the delay
	# links are created. There are no "r" params either; Queue
	# stuff is handled in just the to-switch direction.
	#
	$vlanmember->_queueinfo([$vlanmember->q_limit(),
				 $vlanmember->q_maxthresh(),
				 $vlanmember->q_minthresh(),
				 $vlanmember->q_weight(),
				 $vlanmember->q_linterm(),
				 $vlanmember->q_qinbytes(),
				 $vlanmember->q_bytes(),
				 $vlanmember->q_meanpsize(),
				 $vlanmember->q_wait(),
				 $vlanmember->q_setbit(),
				 $vlanmember->q_droptail(),
				 $vlanmember->q_red(),
				 $vlanmember->q_gentle() ]);

	#
	# The trace info is stored along with the QUEUEINFO, but its
	# easier if I split it out.
	#
	$vlanmember->_traceinfo([$vlanmember->traced(),
				 $vlanmember->trace_endnode(),
				 $vlanmember->trace_type(),
				 $vlanmember->trace_expr(),
				 $vlanmember->trace_snaplen(),
				 $vlanmember->trace_db() ]);

	#
	# This will get set on a per-member basis when it is determined
	# that the link is getting a delaynode cause its really being
	# shaped, or because it is being traced or monitored.
	#
	$virtlan->shapedmembers()->{"$vlanmember"} = 0;
	$vlanmember->_shaped(0);
	$virtlan->_delayed(0);
	$vlanmember->_bridged(0);

	#
	# XXX - Whenever a delay node is inserted, port speeds are set to
	#       the next fastest interface type we have, even if they requested
	#       exactly some speed that can be done without a delay node such
	#       as 10Mbs or 100Mbs. This is a simplification. At some point we
	#       might want to force all the ports along the way to 10Mbs, and
	#       have the delay node worry about delay only, and not bandwidth.
	#       That will be harder to to do in this mess. See companion XXX
	#       below where the delays table is initialized. Initially, we set
	#       the speed to 10Mbs, if a delay node is insterted below, it
	#       resets this to 100Mbs.
	#
	my $portbw = $self->getbandwidth($vlanmember, $virtlan, $bandwidth);
	$self->portbw()->{"$vlanmember"} = $portbw;
	
	$self->printdb("  $vlanname $vlanmember portbw:$portbw - ".
		       "$delay $bandwidth $lossrate ".
		       "$rdelay $rbandwidth $rlossrate\n");

	# Temporary, for generating rspecs.
	push(@{ $vlanmember->virt_node()->_virtifaces() }, $vlanmember);

	# Terrible.
	$vlanmember->_reservebw(0);
	$vlanmember->_needtrunk(0);
	if ($vlanmember->virt_node()->type() eq "sppvm" ||
	    $vlanmember->virt_node()->type() eq "bbgenivm") {
	    $vlanmember->_reservebw($bandwidth);
	    $vlanmember->_needtrunk(1);
	    $vlanmember->_nobwshaping(1);
	    $self->printdb("  Forcing $vlanmember to reserve shared bandwidth\n");
	}
    }

    #
    # Load up the virt_bridges.
    #
    foreach my $virt_bridge ($self->virt_bridges()->Rows()) {
	my $bridgename = $virt_bridge->vname();
	my $bridgevlan = $virt_bridge->vlink();
	my $bridgeport = $virt_bridge->vport();

	if (!exists($self->vlans()->{$bridgevlan})) {
	    tberror("virt_bridge: no such vlan $bridgevlan\n");
	    return -1;
	}
	if (!exists($self->vnodes()->{$bridgename})) {
	    tberror("virt_bridge: no such node $bridgename\n");
	    return -1;
	}
	my $memberof = $self->memberof()->{"$bridgename:$bridgeport"};
	if (!defined($memberof)) {
	    tberror("virt_bridge: ".
		    "$bridgename:$bridgeport is not in $bridgevlan\n");
	    return -1;
	}
	my $vlan = $self->vlans()->{$bridgevlan};
	my $member = $vlan->members()->{"$bridgename:$bridgeport"};

	$self->bridges()->{$bridgename} = {}
	    if (!exists($self->bridges()->{$bridgename}));

	# Store the list of members of this bridge. We assume that
	# a lan is not in a bridge more then once.
	$self->bridges()->{$bridgename}->{"$member"} = $member;
    }

    #
    # Check the bridge requests and set the cross links.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	foreach my $member ($virtlan->memberlist()) {
	    next
		if (!defined($member->bridge_vname()));

	    my $bridge_vname = $member->bridge_vname();
	    if (!exists($self->bridges()->{$bridge_vname})) {
		tberror("$virtlan: no such bridge $bridge_vname\n");
		return -1;
	    }
	    if (!$member->virt_node()->_isbridge()) {
		tberror("$member is bridged but is not a bridge\n");
		return -1;
	    }
	    my $bridged_member = $self->bridges()->{$bridge_vname}->{"$member"};
	    if (!defined($bridged_member)) {
		tberror("$member is bridged to nonexistent member\n");
		return -1;
	    }
	    $member->_bridged(1);
	    $virtlan->_bridged(1);
	    $self->printdb("$virtlan bridge: $member to $bridged_member\n");

	    #
	    # Check tracing. Only on links attached to the bridge.
	    # One side might be a lan, but tracing is allowed on the
	    # link side only. This mirrors the delay node impl, where
	    # tracing is done only at ingress to the lan.
	    #
	    if ($member->traced() && !$virtlan->islink()) {
		tberror("$member is traced, but $virtlan is not a link\n");
		return -1;
	    }
	}
    }
    
    #
    # Load the virt paths.
    #
    foreach my $vpath ($self->virt_paths()->Rows()) {
	my $pathname     = $vpath->pathname();
	my $segmentname  = $vpath->segmentname();
	my $segmentindex = $vpath->segmentindex();
	my $layer        = $vpath->layer();

	# Local wrapper for virt_path table entry;
	my $virtpath = $self->vpaths()->{$pathname};
	if (!defined($virtpath)) {
	    $virtpath = libvtop::virt_path->Create($self, $pathname,$layer);
	    # Add it to the toplevel list of paths.
	    $self->vpaths()->{$pathname} = $virtpath;
	}

	# Find the link this path segment refers to.
	my $virtlan = $self->vlans()->{$vpath->segmentname()};
	if (!defined($virtlan)) {
	    tberror("Cannot virtlan $segmentname in $virtpath\n");
	    return -1;
	}
	# All the segments in the path must be the same layer.
	if ("$layer" ne $virtpath->layer()) {
	    tberror("Path layer mismatch: $segmentname in $virtpath\n");
	    return -1;
	}
	# MLE Constraint:
	#  * A link cannot be in two paths at once. 
	#
	if (defined($virtlan->_vpath())) {
	    my $ovpath = $virtlan->_vpath();
	    tberror("$vpath: $virtlan is already in path $ovpath\n")
	}
	$virtlan->_vpath($virtpath);
	$virtpath->addmember($vpath, $virtlan);

	$self->printdb("$virtpath segment: $virtlan\n");
    }
    #
    # Now sanity check the implemented_by relationships to make sure they
    # are layered properly.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $implemented_by = $virtlan->_implemented_by();

	next
	    if (!defined($implemented_by));

	my $vpath = $self->vpaths()->{$implemented_by};
	if (!defined($vpath)) {
	    tberror("Could not find path $implemented_by for $virtlan");
	    return -1;
	}
	if ($vpath->layer() == $virtlan->_layer() && $vpath->layer() != 2) {
	    tberror("Path $vpath at the same layer as $virtlan");
	    return -1;
	}
	if ($vpath->layer() > $virtlan->_layer()) {
	    tberror("Path $vpath at a higher layer then $virtlan");
	    return -1;
	}
	#
	# MLE Constraints;
	#  * Any link that is implemented by something can have only
	#    two members (a duplex link).
	#  * Endpoint equivalence: The first and last nodes of the link
	#    must be the same as the first and last nodes of the path.
	#    This constraint is very important; it means we have to solve
	#    *just* the lowest layer with assign, and everything is plopped
	#    down on top of that.
	#
	if (scalar($virtlan->memberlist()) != 2) {
	    tberror("$virtlan is implemented by $vpath, but is not a link");
	    return -1;
	}
	my ($member0,$member1) = $virtlan->memberlist();
	my $virtnode0 = $member0->virt_node();
	my $virtnode1 = $member1->virt_node();
	# Look for VMs that have been "fixed" to another node.
	if ($virtnode0->fixed()) {
	    $virtnode0 = $self->vnodes()->{$virtnode0->fixed()};
	}
	if ($virtnode1->fixed()) {
	    $virtnode1 = $self->vnodes()->{$virtnode1->fixed()};
	}
	my $firstnode = $vpath->firstmember()->virt_node();
	my $lastnode  = $vpath->lastmember()->virt_node();

	if ("$virtnode0" ne "$firstnode") {
	    tberror("First node of $vpath is not the same as $virtlan ".
		    "$virtnode0, $firstnode, $member0, $member1\n");
	    return -1;
	}
	if ("$virtnode1" ne "$lastnode") {
	    tberror("Last node of $vpath is not the same as $virtlan ".
		    "$virtnode1, $lastnode, $member0, $member1\n");
	    return -1;
	}
	
	$self->printdb("$virtlan is implemented by $vpath\n");
	$virtlan->_implemented_by($vpath);
	$vpath->addimplements($virtlan);
    }
    return 0;
}

#
# Dump the vtype list.
#
sub GenVirtTypes($)
{
    my ($self) = @_;
    my @types  = $self->VirtTypes();
    
    foreach my $vtype (@types) {
	my $name    = $vtype->name();
	my $weight  = $vtype->weight();
	my @members = split(" ", $vtype->members());

	$self->createVClass ($name, $weight, \@members);
    }
    return 0;
}

#
# Dump the virt nodes.
#
sub GenVirtNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid    = $experiment->pid();
    my $eid    = $experiment->eid();
    
    foreach my $vname (sort(keys(%{ $self->{'VNODES'} }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $type  = $vnode->type();

	#
	# If the user specifed that a VM is fixed to a particular
	# node in the topo, do not insert that into the top file.
	# These are handled later in a post pass after assign runs.
	#
	next
	    if ($vnode->_isvirtnode() && $vnode->_fixedvm());

	my $desires = {};
	my $others = {};
	if ($vnode->_issubnode()) {
	    $others->{'subnode'} = $vnode->_parent();
	}
	foreach my $desirename (keys(%{ $vnode->_desires() })) {
	    my $weight = $vnode->_desires()->{$desirename};
	    $desires->{$desirename} = ['', $weight];
	}
	if ($vnode->_isplabnode() && $experiment->cpu_usage()) {
	    # Yuck
	    $desires->{'load'} = ['+', (($experiment->cpu_usage() - 1) / 5.0)];
	}
	if ($self->updating()) {
	    $desires->{'already_reserved'} = ['', 0.2];
	}
	if (defined($vnode->_startloc())) {
	    $desires->{"area-" . $vnode->_startloc()} = ['', 1.000000];
	}
	# Require that this vnode be placed onto a pnode that supports
	# the OS it is going to run. However, if the OS is one with a
	# 'path' (like an OSKit kernel), we don't have an entry in
	# osidtoimageid for it, and thus we leave it off of the desire list
	if (defined($vnode->_osinfo())) {
	    my $osinfo = $vnode->_osinfo();
	    #
	    # Support subOSes with a multi-OS desire.  Since the pnodes
	    # will have features like OS-parent and OS-parent-subos, we 
	    # generate desire to match.  Parent is major since then this 
	    # all works seamlessly with non-subos stuff.
	    # 
	    my $posinfo = $vnode->_parent_osinfo();
	    
	    if ($vnode->_sharedokay()) {
		if (!defined($posinfo)) {
		    my $jailosid = $self->nodejailosid($vnode);
		    $desires->{"OS-" . $jailosid} = ['', 1.000000];
		    
		}
		else {
		    $desires->{"OS-" . $posinfo->osid()} = ['', 1.000000];
		    $desires->{"OS-" . $posinfo->osid() . "-" . $osinfo->osid()} =
			['', 1.000000];
		}
	    }
	    elsif (!defined($osinfo->path()) || $osinfo->path() eq "") {
		if (!defined($posinfo)) {
		    $desires->{"OS-" . $osinfo->osid()} = ['', 1.000000];
		}
		else {
		    $desires->{"OS-" . $posinfo->osid()} = ['', 1.000000];
		    $desires->{"OS-" . $posinfo->osid() . "-" . $osinfo->osid()} =
			['', 1.000000];
		}
	    }
	}
	#
	# Some stuff for geni. 
	#
	if ($vnode->_isgeninode()) {
	    $others->{'isgeninode'}  = 1;
	    $others->{'request_urn'} = $vnode->fixed();

	    #
	    # Gack; no features and desires in 0.2, so have to use a fixnode.
	    #
	    if (exists($self->current_v2p()->{$vname})) {
		my $pnode_id = $self->current_v2p()->{$vname};
		my $pnode = $self->oldreservednodes()->{$pnode_id};
		$others->{'request_urn'} = $pnode->WideAreaInfo("external_node_id");
	    }
	    
	    if ($vnode->_isvirtnode()) {
		$others->{'virtualization_type'}    = 'emulab-vnode';
		$others->{'virtualization_subtype'} = 'emulab-openvz';
		$others->{'exclusive'} = 0
		    if ($vnode->_sharedokay());
		$type = "pcvm";
	    }
	    else {
		$others->{'virtualization_type'} = 'raw';
		$others->{'exclusive'} = 1;
		$type = "pc";

		if (defined($vnode->_osinfo())) {
		    my $osname = $vnode->_osinfo()->osname();

		    #
		    # If this is the default image, then do not put
		    # this in; let the other side do what it wants.
		    #
		    my $default_osinfo =
			OSinfo->Lookup($vnode->_typeinfo()->default_osid());
		    if (!defined($default_osinfo)) {
			tberror("Could not find default osinfo for $vnode\n");
			return -1;
		    }
		    if ($osname ne $default_osinfo->osname()) {
			$others->{'disk_image'} = {"name" => $osname};
		    }
		}
	    }
	}
	my @interfaces = ();
	my @ifaces     = @{ $vnode->_virtifaces() };
	if (@ifaces) {
	    my @refs = ();
	    foreach my $vlanmember (@ifaces) {
		my $virtlan = $vlanmember->virt_lan();
		my $iface   = {'virtual_id'   => "$vlanmember"};
		    
		if ($vlanmember->fixed_iface() ne "") {
		    $iface->{'component_id'}  = $vlanmember->fixed_iface();
		}
		push(@interfaces, $iface);
	    }
	}
	
	#
	# Now the type string, which might include some stuff for
	# simnodes that I do not understand. 
	#
	my $typestr = $type;
	my $nodeweight = '1';
	if ($vnode->_issimnode()) {
	    my $query_result =
		DBQueryWarn("select nodeweight from virt_simnode_attributes ".
			    "where pid='$pid' and eid='$eid' and ".
			    "      vname='$vname'");
	    if ($query_result && $query_result->numrows) {
		($nodeweight) = $query_result->fetchrow_array();
	    }
	}
	elsif ($vnode->_isbridge()) {
	    $type = ($type eq "pc" ? "delay" : "delay-" . $type);
	}
	
	$self->createNode($vname, $vnode->_cmurn(),
			  $type, $nodeweight, $desires, $others, \@interfaces);
    }
    
    #
    # Now that the node list is out, set OSID for nodes
    #
    # Huh?
    #
    foreach my $vnode (values(%{ $self->{'VNODES'} })) {
	my $vname  = $vnode->vname();
	my $type   = $vnode->type();
	my $osinfo = $vnode->_osinfo();

	if ($vnode->_issubnode() && $type eq "ixp-bveil" && !defined($osinfo)){
	    my $osinfo = OSinfo->LookupByName("RHL73-IXPHOST");
	    $vnode->_osinfo($osinfo);
	}
    }
    return 0;
}

#
# Print out the fix nodes.
#
sub GenFixNodes($)
{
    my ($self) = @_;

    #
    # Be sure NOT to print out nodes which are no longer in the experiment.
    #
    # XXX This must be done last since we create internal nodes above.
    #
    foreach my $vname (sort(keys(%{ $self->fixednodes() }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $fixed = $self->fixednodes()->{$vname};

	if (!defined($fixed)) {
	    tbwarn("GenFixNodes: No fixed node for $vname\n");
	}

	# Normal nodes have a vnode but delay nodes do not.
	if (!defined($vnode) && !$self->isadelaynode($vname)) {
	    tbinfo("GenFixNodes: No vnode for $vname\n");
	}

	#
	# Temporary rspec generation.
	#
	next
	    if (defined($vnode) && $vnode->_isgeninode());

	#
	# When fixing a vnode to a particular physnode, ignore the 
	# fix specification here; we do this as a post pass, and
	# assume the user knows what she is doing (the number of
	# nodes is okay for the machine).
	#
	next
	    if (defined($vnode) && 
		$vnode->_isvirtnode() && defined($vnode->_fixedvm()));

	if ($self->isatoponode($vname) || $self->isadelaynode($vname)) {
	    $self->createFixedNode($vname, $fixed);
	}
    }
    return 0;
}

#
# Print out some summary stats.
#
sub PrintSummaryStats($)
{
    my ($self) = @_;

    # Set estimations
    my $minimum_nodes = $self->counters()->{'physcount'} +
	$self->delaynodecount() / $self->options()->{'delay_capacity'};
    my $maximum_nodes = $self->counters()->{'physcount'} +
	$self->delaynodecount();
    $minimum_nodes = POSIX::ceil($minimum_nodes);

    # For the caller.
    $self->counters()->{'minimum_nodes'}  = $minimum_nodes;
    $self->counters()->{'maximum_nodes'}  = $maximum_nodes;

    my $virtnode_count = $self->counters()->{'virtcount'};
    my $simnode_count  = $self->counters()->{'simcount'};
    my $reserved_virtcount = $self->counters()->{'reserved_virtcount'};
    my $reserved_physcount = $self->counters()->{'reserved_physcount'};

    if (!$self->quiet()) {
	print "Minimum nodes   = $minimum_nodes\n";
	print "Maximum nodes   = $maximum_nodes\n";
	if ($virtnode_count) {
	    print "Virtual nodes     = $virtnode_count\n";
	}
	if ($simnode_count) {
	    print "Simulated nodes   = $simnode_count\n";
	}
	if ($reserved_virtcount) {
	    print "Reserved vnodes   = $reserved_virtcount\n";
	}
	if ($reserved_physcount) {
	    print "Reserved pnodes   = $reserved_physcount\n";
	}
    }
    return 0;
}

#
# Dump the virt lans
#
sub GenVirtLans($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid    = $experiment->pid();
    my $eid    = $experiment->eid();

    #
    # It would be nice if "tunnels" could be handled as a case in the
    # logic below, but there are too many special things about
    # tunnels, primary being that they are assumed to be connected
    # over the control interfaces of the nodes. There should really be
    # no reason why we cannot build a tunnel on top of an experimental
    # link since it is just another form of encapsulation. 
    #
    foreach my $vname (sort(keys(%{ $self->{'VLANS'} }))) {
	my $vlan = $self->vlans()->{$vname};
	
	next
	    if (!$vlan->_tunnel());
	
	my @members = $vlan->memberlist();
	$self->printdb("$vname (tunnel): " . join(" ",@members) . "\n");
	
	if (scalar(@members) != 2) {
	    tberror("Too many members in tunnel $vname\n");
	    return -1;
	}
	
	my ($member0,$member1) = @members;
	my $virtnode0 = $member0->virt_node();
	my $virtnode1 = $member1->virt_node();
	my $vname0    = $virtnode0->vname();
	my $vname1    = $virtnode1->vname();
	my $ip0       = $member0->ip();
	my $ip1       = $member1->ip();
	
	$vlan->_geninodes(1)
	    if ($virtnode0->_isgeninode() || $virtnode1->_isgeninode());
		
	my ($delay0,$bw0,$ebw0,$backfill0,$loss0,
	    $rdelay0,$rbw0,$rebw0,$rbackfill0,$rloss0) =
		@{$member0->_delayinfo()};
	my ($delay1,$bw1,$ebw1,$backfill1,$loss1,
	    $rdelay1,$rbw1,$rebw1,$rbackfill1,$rloss1) =
		@{$member1->_delayinfo()};
	
	my $bw = min($bw0,$rbw1);
	
	#
	# Tunnels go into the geni rspec, but not locally since assign
	# does not really know what to do with tunnels. Special case
	# handling below. 
	#
	if ($vlan->_geninodes()) {
	    #
	    # We eventually want to support tunnels between a local cluster node
	    # and a protogeni node.
	    #
	    # Enforce tunnel between two geni nodes. It would be nice to support
	    # this, but it requires that the cluster node go into the rspec, and
	    # that complicates things.
	    #
	    if (! ($virtnode0->_isgeninode() && $virtnode1->_isgeninode())) {
		tberror("Tunnel $vname: ".
			"Unsupported tunnel between cluster and protogeni node!\n");
		return -1;
	    }
	    $self->createLink($vname, $vname,
			      [ $virtnode0->_cmurn(),
				$virtnode1->_cmurn() ],
			      {'virtual_node_id' => $vname0,
			       'virtual_interface_id' => "$member0",
			       'tunnel_ip' => $ip0 },
			      {'virtual_node_id' => $vname1,
			       'virtual_interface_id' => "$member1",
			       'tunnel_ip' => $ip1 },
			      $bw, "tunnel", {'isgeninode' => 1});
	}
    }

    my $errors	         = 0;
    my %osdoesveth       = ();
    my %osdoesvethEN     = ();	# Encapsulated veth
    my %osdoesvethNE     = ();  # Non-Encapsulated veth
    my %osdoesvlan       = ();
    my %osdoesmlink      = ();
    my %osdoeslinkdelays = ();

    foreach my $vname (sort(keys(%{ $self->{'VLANS'} }))) {
	my $vlan = $self->vlans()->{$vname};

	# Tunnels are handled elsewhere.
	next
	    if ($vlan->_tunnel());

	my @members = $vlan->memberlist();
	$self->printdb("$vname: " . join(" ",@members) . "\n");

	my $simnodes     = 0;
	my $realnodes    = 0;
	my $virtnodes    = 0;
	my $nonvirtnodes = 0;
	my $sharednodes  = 0;
	my $geninodes    = 0;
	my %nodesdo      = ("alias"=>0, "veth"=>0, "vlan"=>0, "ldelay"=>0,
			    "veth-ne"=>0, "veth-en"=>0);
	my $trivial_ok   = 0;
	my $emulated     = $vlan->_emulated();
        my $uselinkdelay = $vlan->_uselinkdelay();
	my $mustdelay    = $vlan->_mustdelay();
	my $nobwshaping  = $vlan->_nobwshaping();
	my $protocol     = $vlan->_protocol();
	my $linkencap    = $vlan->_encapstyle();
	my $layer        = $vlan->_layer();

	# For mixing pnodes and vnodes.
	$vlan->_mixedencap(0);

	#
	# Count the types of nodes (simulated, virtual, real, etc.) in this
	# LAN
	#
	foreach my $member (@members) {
	    my $osid;
	    my $virtnode = $member->virt_node();

	    if ($virtnode->_sharedokay()) {
		$sharednodes++;
		$vlan->_sharednodes($sharednodes);
	    }
	    if ($virtnode->_isgeninode()) {
		$geninodes++;
		$vlan->_geninodes($geninodes);
	    }

	    if ($virtnode->_issimnode()) {
		$simnodes++;

		if (defined($virtnode->_osinfo())) {
		    $osid = $virtnode->_osinfo()->osid();
		} else {
		    $osid = "<SIM>";
		}
		# XXX apparently all simnodes can do veths
		if (!exists($osdoesmlink{$osid})) {
		    $osdoesmlink{$osid} = 0;
		    $osdoesveth{$osid} = 1;
		    $osdoesvethNE{$osid} = 1;
		    $osdoesvethEN{$osid} = 1;
		    $osdoesvlan{$osid} = 0;
		    $osdoeslinkdelays{$osid} = 1;
		}
	    }
	    else {
		my $osinfo;
		
		if ($virtnode->_isvirtnode()) {
		    $virtnodes++;

		    # For virtnodes, we have to map the osid of the vnode
		    # to the osid of the physical machine it will reside on.
		    # Doing this before assign chooses the node, is silly
		    # but no choice right now.
		    #
		    # And now, we only map in this way IF the parent_osid
		    # is not set (it gets set if the user chooses a subOS and
		    # a parent is assigned by default in the parser, or
		    # if they choose both a subOS and a specific parent OS).
		    #
		    if (defined($virtnode->_parent_osinfo())) {
			$osinfo = $virtnode->_parent_osinfo();
			$osid = $osinfo->osid();
		    }
		    elsif (defined($virtnode->_osinfo())) {
			$osid = $self->nodejailosid($virtnode);
			if (!defined($osid)) {
			    tberror("No jailosid for $virtnode\n");
			    return -1;
			}
			$osinfo = OSinfo->Lookup($osid);
			if (!defined($osinfo)) {
			    tberror("No mapping for osid $osid\n");
			    return -1;
			}
		    }
		}
		else {
		    $nonvirtnodes++;

		    $osinfo = $virtnode->_osinfo()
			if (defined($virtnode->_osinfo()));
		}
		
		#
		# Check os feature list emulated/veth/vlan support.
		#
		if (defined($osinfo)) {
		    $osid = $osinfo->osid();
		    
		    if (!exists($osdoesmlink{$osid})) {
			$osdoesmlink{$osid} =
			    $osinfo->FeatureSupported('mlinks');
			$osdoesveth{$osid} =
			    $osinfo->FeatureSupported('veths');
			$osdoesvethNE{$osid} =
			    $osinfo->FeatureSupported('veth-ne');
			$osdoesvethEN{$osid} =
			    $osinfo->FeatureSupported('veth-en');
			$osdoesvlan{$osid} =
			    $osinfo->FeatureSupported('vlans');
			# Need this for phys nodes requesting lindelays.
			$osdoeslinkdelays{$osid} =
			    $osinfo->FeatureSupported('linkdelays');
		    }
		} else {
		    # XXX If the user doesn't explicitly set an OS on a PC.
		    # Be conservative and assume minimum features.
		    $osid = "<DEFAULT>";
		    if (!exists($osdoesmlink{$osid})) {
			$osdoesmlink{$osid} = 0;
			$osdoesveth{$osid} = 0;
			$osdoesvethNE{$osid} = 0;
			$osdoesvethEN{$osid} = 0;
			$osdoesvlan{$osid} = 0;
			$osdoeslinkdelays{$osid} = 0;
		    }
		}
		$realnodes++;
	    }
	    # Figure out how many nodes support a feature
	    $nodesdo{"alias"}++
		if ($osdoesmlink{$osid});
	    $nodesdo{"veth"}++
		if ($osdoesveth{$osid});
	    $nodesdo{"veth-ne"}++
		if ($osdoesvethNE{$osid});
	    $nodesdo{"veth-en"}++
		if ($osdoesvethEN{$osid});
	    $nodesdo{"vlan"}++
		if ($osdoesvlan{$osid});
	    $nodesdo{"ldelay"}++
		if ($osdoeslinkdelays{$osid});

	    # Remember since we went to the trouble of determining the osid.
	    $member->_osdoesvethNE($osdoesvethNE{$osid});
	    $member->_osdoesvlan($osdoesvlan{$osid});
	}

	#
	# Layer 1 links cannot be any of these things right now.
	# Just a wire.
	#
	if ($layer == 1 &&
	    ($trivial_ok || $emulated || $uselinkdelay ||
	     $mustdelay || $nobwshaping || $sharednodes || $simnodes)) {
	    tberror("$vname is a layer 1 link, no options please.\n");
	    return -1;
	}

	$self->printdb("$vname: members = ".
		       scalar(@members) .
		       " real/virt/sim = ".
		       "$nonvirtnodes/$virtnodes/$simnodes ".
		       "mlink/veth-ne/veth-en/vlan/ldelay = ".
		       $nodesdo{"alias"} . "/".
		       $nodesdo{"veth-en"} . "/".
		       $nodesdo{"veth-ne"} . "/".
		       $nodesdo{"vlan"} . "/".
		       $nodesdo{"ldelay"} . "\n");

	#
	# Determine the emulation/encapsulation style for the link.
	# The goal is to come up with a compatible emulation style
	# for all members of the virt_lan.  Note that it is not stictly
	# necessary for all members of the virt_lan to emulate in the
	# same way; e.g., one node could be doing an 802.1q tagged VLAN
	# while another could just be doing IP aliasing or veths without
	# encapsulation.  In fact, it is not even necesary in some cases
	# for all vlinks on a physical link to use the same style!
	# But we don't want to go there right now, so for simplicity,
	# we require that the user specify identical values for all
	# members of a virt_lan.  For now, we do this by ignoring per-link
	# settings ($encap) and using only the global setting ($encapstyle)
	# except for backward compat (see next paragraph).
	#
	# XXX this is made hideous by having both global and per-link
	# encapsulation values that were previously used for two
	# different purposes.  The per-link value was used to
	# specify using "veth" devices for non-vnode emulated links
	# (as opposed to using IP aliases).  The global value
	# was used to specify using veth devices without encapsulation
	# for vnode emulated links.
	#
	# So the simplified semantics look like:
	#
	# global  per-link  in vnode?  meaning
	#
	# default default   no         alias; non-vnode mpx links (historic)
	# default alias     no         alias; non-vnode mpx links (historic)
	# default veth      no         veth; non-vnode mpx links (historic)
	#
	# default default   yes        veth; vnode vlinks (historic)
	# veth    default   yes        veth; vnode vlinks (historic)
	# veth-ne default   yes        veth-noencap; vnode vlinks (historic)
	#
	# default *         yes        veth
	# default *         no         alias
	# alias   *         yes        ERROR; we could support this
	# alias   *         no         alias
	# veth    *         *          veth
	# veth-ne *         *          veth-noencap
	# vlan    *         *          vlan
	#
	my $encapval;

        #
	# Notes on virtual interfaces.
	#
	# If a link is EMULATED (virtlanemulated) then it will have an
	# "encapsulation style" (virtlanencapstyle).  That value is
	# one of:
	#
	# "veth-ne"	emulation is done with "veth" devices;
	#		no encapsulation is used (uses made-up MAC addresses
	#		instead).
	#		Works on FreeBSD only and OpenVZ. 
	#
	# "vlan"	emulation is done with "vlan" devices;
	#		uses 802.1q VLAN tagging.
	#		Works on FreeBSD or Linux.
	#
	# "default"	emulation style was not explicitly set by the users;
	#		encap style depends on context ("veth-ne" for vnode)
	#
	# Note that the encapsulation style for "default" depends on
	# the node type.  For non-vnodes the default is "vlan".  For
	# vnodes the default is "veth-ne" since they must always have
	# some pseudo-device on which to hang a route table ID; i.e:
	# we cannot just do IP aliasing.
	#
	#
        # Encapsulation can be specified per link.  The default link
        # encapsulation can also be specified by a per-experiment
        # setting.  At the moment, only the latter (global) is
        # implemented.
        #
	my $globalencap = $experiment->encap_style();

	#
	# No longer support veth or alias encap; catch it now. 
	#
	if (! ($globalencap =~ /^(default|veth-ne|vlan)$/)) {
	    tberror("unknown global encapsulation style '$globalencap'\n");
	    $errors++;
	    next;
	}
	if (! ($linkencap =~ /^(default|veth-ne|vlan)$/)) {
	    tberror("$vname: unknown link encapsulation style '$linkencap'\n");
	    $errors++;
	    next;
	}
	if ($linkencap ne "default" && $linkencap ne $globalencap) {
	    tbwarn("$vname: per-link encapsulation type not supported\n");
	    $errors++;
	    next;
	}

	if ($virtnodes) {
	    #
	    # At the present time, links with virtnodes require that we 
	    # multiplex (and use encapsulation). If emulated is not set,
	    # just turn it on (we can do this silently since there is no
	    # other choice for the user). 
	    #
	    $emulated = 1;
	    
	    #
	    # For virtual nodes, we prefer veth-ne cause vlans are a scarce
	    # resource, and most VM implementations should support them in
	    # some manner (eg: openvz veth device). 
	    #
	    if ($globalencap eq "default") {
		$encapval = "veth-ne";
	    }
	    else {
		$encapval = $globalencap;
	    }
	}
	else {
	    #
	    # No virtual nodes. We allow links to use encapsulation and to
	    # be multiplexed (emulated). This allows the experimentor to
	    # have more links then just the number of physical interfaces.
	    # Encapsulation without multiplexing is okay, although useful
	    # mostly for testing purposes. If the link is emulated but not
	    # encapsulated, an encapsulation method must be chosen. We
	    # prefer vlan these days cause it runs everywhere. Might want
	    # to look at the nodesdo info at some point.
	    #
	    if ($emulated) {
		if ($globalencap eq "default") {
		    $encapval = "vlan";
		}
		else {
		    $encapval = $globalencap;
		}
	    }
	    elsif ($globalencap ne "default") {
		$encapval = $globalencap;
	    }
	    if (defined($encapval)) {
		if ($nodesdo{$encapval} != $nonvirtnodes) {
		    tberror("Not all nodes in link $vname support $encapval ".
			    "encapsulation\n");
		    $errors++;
		    next;
		}
	    }
	    else {
		$encapval = "none";
	    }
	}
	$self->printdb("$vname: global/link = ".
		       "$globalencap/$linkencap => $encapval\n");

	#
	# Update the per-link values for emulated and encapsulation style.
	# Also init the per-member flags, since this might be a mixed
	# pnode/vnode link, where the pnode links use a different setting.
	#
	$vlan->_encapstyle($encapval);
	$vlan->_emulated($emulated);
	foreach my $member (@members) {
	    $member->_encapstyle($encapval);
	    $member->_emulated($emulated);
	}

	#
	# For links involving virtnodes, we prefer to use virtual links.
	# But we can only do this if all involved nodes support a common
	# emulation style.
	#
	my $allnodes = $simnodes + $realnodes;
	if ($virtnodes > 0) {
	    $trivial_ok = $vlan->_trivial_ok();

	    #
	    # MLE Constraint: Not allowed to use a shared node on
	    # any link that is part of a vpath.
	    #
	    if (defined($vlan->_vpath())) {
		tberror("Not allowed to use virtual/shared nodes in $vlan ".
			"since it is part of a path.\n");
		$errors++;
		next;
	    }

	    if ($sharednodes) {
		#
		# MLE Constraint: Not allowed to use a shared node on
		# any link that is implemented_by a vpath.
		#
		if (defined($vlan->_implemented_by())) {
		    tberror("Not allowed to use shared nodes in ".
			    "$vlan since is is implemented by a path.\n");
		    $errors++;
		    next;
		}
		
		#
		# All nodes must support vlan encapsulation since that is how
		# we create the links. Even if only one node in the link or
		# lan is on a shared node, they must all do vlan encap.
		# If none of the nodes land on a shared node, then use the
		# requested vlan encap. Right, this decision is actually made
		# later after assign maps the resources.
		#
		if ($nodesdo{"vlan"} != $allnodes) {
		    tberror("Shared nodes requested for $vname, ".
			    "but vlan encapsulation\n".
			    "not supported on all nodes.\n");
		    $errors++;
		}
	    }
	    #
	    # Regardless of shared nodes, there must be a common
	    # encapsulation style in case no shared nodes are used
	    # (and vlan encap is not needed).
	    #
	    if ($nodesdo{$encapval} == $allnodes) {
		#
		# All members support the encapsulation style, use it.
		#
		;
	    }
	    elsif ($nonvirtnodes && $encapval eq "veth-ne") {
		#
		# One way of mixing vnodes and pnodes is to require that all
		# nodes support the same style of encapsulation. The most
		# common is vlan encap.  But that is really inefficient
		# since it burns up scarce vlan ids. On the other hand, if
		# vnode links are veth-ne, and the user does not need/want
		# multiplexing on the pnodes, then a plain
		# non-encapsulating physical interface on the pnode is just
		# fine since all the pnode sees is ethernet frames with
		# fake mac addressess generated by the veth device on the
		# vnodes.
		#
		# At the moment, we have no NS syntax for the user to ask
		# for this, but if the pnodes do not support veth-ne, we
		# will just turn off the emulate bit for the pnode members
		# of the lan. Assign will not try to multiplex those, and
		# if the user asked for more links then interfaces, it will
		# fail to map.
		#
		$vlan->_mixedencap(1);
		
		foreach my $member (@members) {
		    my $virtnode = $member->virt_node();

		    next
			if ($virtnode->_isvirtnode());

		    if (! $member->_osdoesvethNE()) {
			tbwarn("$vname: changing $member to non-encapsulating ".
			       "since physical host does not support veth-ne\n");
			$member->_emulated(0);
			$member->_encapstyle("none");
		    }
		}
	    }
	    else {
		#
		# Not all members support the desired encapsulation. We used to
		# reset emulated and encapsulation style, but now we just throw
		# an error so that user knows the topology is not going to be
		# what was expected.
		#
		tberror("Encapsulation not supported on ".
			"$vname since at least one of the nodes in $vname ".
			"does not support '$encapval' link emulation\n");
		$errors++;
		next;
	    }
	}
	if ($protocol !~ /^ethernet/) {
	    #
	    # This arrangement is temporary. For now, if its not a
	    # regular ethernet, then create a lan attached to a fake
	    # switch. See ptopgen.  We label them differently though,
	    # since these do not get vlans.  Some other special
	    # treatment applies as well.
	    #
	    my $lanname = "fakelan/$vname";
	    $self->createNode($lanname, $mycmurn, $protocol, '1', undef, undef);
	    
	    # So we ignore it when it comes back from assign.
	    $self->lannodes()->{$lanname} = 1;
	    
	    # XXX If not ethernet, assume wireless. Need more info someplace.
	    $self->exptstats()->{'wirelesslans'} += 1;
	    
	    foreach my $member (@members) {
		my $plink = "fakelan/$vname/$member";
		my $vname = $member->virt_node()->vname();
		
		my ($top_bw, $top_rbw) = $self->virtlantopbw($vlan, $member);
		$self->createLink($vname, $plink, [$mycmurn],
				  {'virtual_node_id' => $vname,
				   'virtual_interface_id' => "$member" },
				  {'virtual_node_id' => $lanname,
				   'virtual_interface_id' => "$member" },
				  $top_bw, $protocol);
		next;
	    }
	}
	elsif (@members == 2 && !$vlan->_bridged()) {
	    #
	    # We treat LANs with two members specially - they are just links
	    #
	    $self->exptstats()->{'links'} += 1;

	    my ($member0,$member1) = @members;
	    my $virtnode0 = $member0->virt_node();
	    my $virtnode1 = $member1->virt_node();
	    my $vname0    = $virtnode0->vname();
	    my $vname1    = $virtnode1->vname();

	    my ($delay0,$bw0,$ebw0,$backfill0,$loss0,
		$rdelay0,$rbw0,$rebw0,$rbackfill0,$rloss0) =
		    @{$member0->_delayinfo()};
	    my ($delay1,$bw1,$ebw1,$backfill1,$loss1,
		$rdelay1,$rbw1,$rebw1,$rbackfill1,$rloss1) =
		    @{$member1->_delayinfo()};

	    # Here the r's are going to be 1->0 and the others 0->1
	    my $delay      = $delay0+$rdelay1;
	    my $loss       = 1-(1-$loss0)*(1-$rloss1);
	    my $bw         = min($bw0,$rbw1);
 	    my $backfill   = max($backfill0,$rbackfill1);
	    my $rdelay     = $rdelay0+$delay1;
	    my $rloss      = 1-(1-$rloss0)*(1-$loss1);
	    my $rbw        = min($rbw0,$bw1);
 	    my $rbackfill  = max($rbackfill0,$backfill1);
	    my $bandwidth  = $self->getbandwidth($member0, $vlan, $bw);
	    my $rbandwidth = $self->getbandwidth($member1, $vlan, $bw);

	    # Need to know about tracing on a per queue basis, since the
	    # user can specify tracing asymmetrically.
	    my ($traced,$trace_endnode)   = @{$member0->_traceinfo()};
	    my ($rtraced,$rtrace_endnode) = @{$member1->_traceinfo()};

	    # Rob says not supported
	    if (($trivial_ok || $emulated) &&
		($bandwidth == 0 || $rbandwidth == 0)) {
		tberror("Cannot mix trivial_ok|emulated with * bw\n");
		$errors++;
	    }

	    #
	    # See if the link is really being shaped, or if just need
	    # a delay node cause of tracing/monitoring.
	    #
	    my $shaped = 0;

	    if (((($delay >= $DELAYTHRESH) ||
		  (!$nobwshaping &&
		   ($self->requires_delay($member0, $vlan, $bw) ||
		    $self->requires_delay($member1, $vlan, $bw))) ||
		  ($loss != 0)) ||
		 (($rdelay >= $DELAYTHRESH) ||
		  (!$nobwshaping &&
		   ($self->requires_delay($member0, $vlan, $rbw) ||
		    $self->requires_delay($member1, $vlan, $rbw))) ||
		  ($rloss != 0)) ||
		 # Link must be shaped for other reasons (q_red).
		 $mustdelay ||
		 # Global force, or per-link force. 
		 $self->option('forcelinkdelays') || $uselinkdelay) &&
		# No shaping of geni nodes.
		$vlan->_geninodes() == 0) {
		# Need a delay node and its really a shaped link.
		$shaped = 1;
		# Mark the links as shaped for later.
		$vlan->setmembershaped($member0);
		$vlan->setmembershaped($member1);
	    }

	    #
	    # MLE Constraint: Not allowed to shape a link that is
	    # implemented_by a path, unless it uses link shaping.
	    #
	    if (defined($vlan->_implemented_by()) && $shaped &&
			!$self->virtlan_use_linkdelay($vlan, $shaped)) {
		tberror("Not allowed to shape (delay nodes) $vlan since it ".
			"is implemented_by a path. Try endnode shaping.\n");
		$errors++;
		next;
	    }

	    #
	    # MLE Constraint: The links in a path cannot be shaped at all.
	    #
	    if (defined($vlan->_vpath()) && $shaped) {
		my $vpath = $vlan->_vpath();
		tberror("Not allowed to shape $vlan cause its in $vpath\n");
		$errors++;
		next;
	    }
	    # And, a layer 1 link cannot be shaped no matter what right now.
	    if ($layer == 1 && $shaped) {
		tberror("Not allowed to shape $vlan cause its at layer 1\n");
		$errors++;
		next;
	    }

	    #
	    # Check to make sure that both nodes support linkdelays.  This
	    # check is only made for links comprised of physical nodes,
	    # since if the OS supports virtual nodes, it supports linkdelays.
	    #
	    if ($shaped && $virtnodes == 0 &&
		$self->virtlan_use_linkdelay($vlan, $shaped)) {
		#
		# The user had to specify the OS.
		#
		if (! (defined($virtnode0->_osinfo()) &&
		       defined($virtnode1->_osinfo()))) {
		    tberror("You must specify the OSID for all nodes in ".
			    "lan $vlan, when using linkdelays ".
			    "(endnode traffic shaping)\n");
		    $errors++;
		}
		else {
		    #
		    # All the OS's have to support linkdelays.
		    #
		    foreach my $virtnode ($virtnode0, $virtnode1) {
			my $osinfo = $virtnode->_osinfo();
			
			if (! $osdoeslinkdelays{$osinfo->osid()}) {
			    my $osname = $osinfo->osname();
			    tberror({type => 'primary', severity => SEV_ERROR,
				     error => ['node_lacks_linkdelay_support',
					       $virtnode, $vlan]},
				    "$virtnode in link $vlan is running an OS ".
				    "($osname) that does not support linkdelays ".
				    "(endnode traffic shaping)\n");
			    $errors++;
			}
		    }
		}
	    }

	    #
	    # Get the bandwidth we're supposed to put into the top file, which
	    # may be different that what we're limiting the link to
	    #
	    my ($top_bw0, $top_rbw0) = $self->virtlantopbw($vlan, $member0);
	    my ($top_bw1, $top_rbw1) = $self->virtlantopbw($vlan, $member1);

	    my $top_bw  = min($top_bw0, $top_rbw1);
	    my $top_rbw = min($top_rbw0, $top_bw1);

	    if (($shaped ||
		 (($traced || $rtraced) &&
		  !($trace_endnode && $rtrace_endnode))) &&
		# XXX simulated nodes hack. We don't want to put delay nodes
		# between simulated nodes. If there is a link between a
		# simulated and a real node, we might need to put in delay
		# nodes.
		($realnodes != 0)) {
		$self->exptstats()->{"shapedlinks"} += 1;
		
		#
		# We use a linkdelay if the link is emulated, globally forced,
		# globally preferred if the link is shaped, or if the per-link
		# flag was set (which means to put in a link delay regardless
		# of whether the link is shaped).
		#
		if ($self->virtlan_use_linkdelay($vlan, $shaped)) {
		    my $plink = "linksimple/$vname/$member0,$member1";
		    my $others = {};
		    if ($emulated) {
			$others->{'emulated'} = 1
			    if ($member0->_emulated() && $member1->_emulated());
			$others->{'virtualization_type'} =
			    $vlan->_encapstyle();
		    }
		    if ($trivial_ok) {
			$others->{'trivial_ok'} = 1;
		    }
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode0->_fixedvm())) {
			$vname0 = $virtnode0->_fixedvm()->vname();
		    }
		    if (defined($virtnode1->_fixedvm())) {
			$vname1 = $virtnode1->_fixedvm()->vname();
		    }
		    
		    if (defined($vlan->_implemented_by())) {
			#
			# We post pass these links. Save.
			#
			$self->vlinks()->{"$vlan"} = $plink;
		    }
		    else {
			$self->createLink($vname, $plink, [$mycmurn],
				    {'virtual_node_id' => $vname0,
				     'virtual_interface_id' => "$member0" },
				    {'virtual_node_id' => $vname1,
				     'virtual_interface_id' => "$member1" },
				      ($top_bw == 0 ? "*" : 
				       max($top_bw, $top_rbw)), $protocol,
				      $others);
		    }
		    my @delayinfo = ($delay,$bw,$backfill,$loss,
				     $rdelay,$rbw,$rbackfill,$rloss, 0);
		    
		    $self->printdb("Delay link $plink = " . 
				   join(" ", @delayinfo) . "\n");
		    
		    # Save for the post pass.
		    $self->delaylinks()->{$plink} = \@delayinfo;
		}
		else {
		    my $delayname   = $self->nextdelayname();
		    my $plink       = "linksdelaysrc/$vname/$member0,$member1";

		    my $delaydesirename = $self->delay_desire_name();
		    my $delaydesiretype = $self->delay_desire_type();
		    my $delaydesirepenalty = $self->delay_desire_penalty();
		    
		    
		    my @delayinfo = ($delay,$bw,$backfill,$loss,
				     $rdelay,$rbw,$rbackfill,$rloss,0);
		    my $desire = {};
		    if ($delaydesirename ne '') {
			$desire->{$delaydesirename} = 
			    [$delaydesiretype, $delaydesirepenalty];
		    }
		    $self->createNode($delayname, $mycmurn, "delay", '1', 
				      $desire, undef);

		    my $others = {};
		    $self->createLink($vname,
				      "linksdelaysrc/$vname/$member0,$member1",
				      [$mycmurn],
				      {'virtual_node_id' => $vname0,
				       'virtual_interface_id' => "$member0" },
				      {'virtual_node_id' => $delayname,
				       'virtual_interface_id' => "$member1" },
				      ($top_bw == 0 ? "*" : $top_bw), 
				      $protocol, $others);
		    
		    $self->createLink($vname,
				      "linksdelaydst/$vname/$member1,$member0",
				      [$mycmurn],
				      {'virtual_node_id' => $vname1,
				       'virtual_interface_id' => "$member1" },
				      {'virtual_node_id' => $delayname,
				       'virtual_interface_id' =>"$member0" },
				      ($top_bw == 0 ? "*" : $top_bw), 
				      $protocol, $others);
		    
		    $self->printdb("Delay node $plink ($delayname) = " . 
				   join(" ", @delayinfo) . "\n");
		    
		    # Save for the post pass.
		    $self->delaylinks()->{$plink} = \@delayinfo;
		    $self->delaynodes()->{$delayname} = $delayname;
		}
		#
		# Ports are set to the next-fastest speed when a link gets a
		# delay node.  This can override initialization above cause we
		# could not tell earlier if the link was going to get a real
		# delay node or just a delaywithswitch.
		#
		$self->portbw()->{$member0} =
		    $self->getbandwidth($member0,$vlan,$bandwidth);
		$self->portbw()->{$member1} =
		    $self->getbandwidth($member1,$vlan,$rbandwidth);
	    }
	    else {
		my $plink = "linksimple/$vname/$member0,$member1";
		my $bw = '';
		my $others = {'isgeninode' => $vlan->_geninodes()};

		if ($emulated) {
		    $bw = max($top_bw,$top_rbw);
		}
		else {
		    # Let assign choose bw if top_bw is zero.
		    $bw = ($top_bw == 0 ? "*" : $top_bw);
		}
		if ($emulated) {
		    $others->{'emulated'} = 1
			if ($member0->_emulated() && $member1->_emulated());
		    $others->{'virtualization_type'} = $vlan->_encapstyle();
		}
		if ($layer == 1) {
		    $protocol = "wire";
		}
		
		if ($trivial_ok) {
		    $others->{'trivial_ok'} = 1;
		    #
		    # We store this info in case assign actually does turn it
		    # into a trivial link. If that happens, we have to insert
		    # a link delay if the link is between two vnodes. Why?
		    # Cause a trivial link (using loopback) would have much
		    # more bandwidth (400+ Mb) then your typical 100Mb link.
		    # Note the final member of the array, which indicates this
		    # delay should be inserted only if assign makes it a
		    # trivial link.		    
		    #
		    if (!$nobwshaping && !$vlan->_allsim()) {
			$self->delaylinks()->{$plink} = 
			    [$delay,$bw,$backfill,$loss,
			     $rdelay,$rbw,$rbackfill,$rloss,1.000000];
		    }
		}
		if (defined($vlan->_implemented_by())) {
		    #
		    # We post pass these links. Save.
		    #
		    $self->vlinks()->{"$vlan"} = $plink;
		}
		else {
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode0->_fixedvm())) {
			$vname0 = $virtnode0->_fixedvm()->vname();
		    }
		    if (defined($virtnode1->_fixedvm())) {
			$vname1 = $virtnode1->_fixedvm()->vname();
		    }
		    $self->createLink($vname, $plink,
				      [$virtnode0->_cmurn(),
				       $virtnode1->_cmurn() ],
				      {'virtual_node_id' => $vname0,
				       'virtual_interface_id' =>"$member0" },
				      {'virtual_node_id' => $vname1,
				       'virtual_interface_id' =>"$member1" },
				      $bw, $protocol, $others);
		}
	    }
	}
	elsif ($#members != 0) {
	    $self->exptstats()->{"lans"} += 1;
	    my $lannode = ($vlan->_geninodes() ? "lan-$vname" : "lan/$vname");
	    my $cmurn   = ($vlan->_geninodes() ?
			   $members[0]->virt_nodes()->_cmurn() : $mycmurn);

	    # This is for mixing real nodes with pnodes in a lan. The goal 
	    # is to prevent assign from putting the lan node on a pc;
	    # always prefer a real switch. See corresponding change in
	    # ptopgen.
	    my $desires = ($virtnodes && $nonvirtnodes ?
			   {"real-switch" => ['' , "1.0"]} : undef);
			       
	    # Lan node for assign.
	    $self->createNode($lannode, $cmurn, "lan", '1', $desires,
			      { 'virtualization_type' => 'raw' ,
			        'isgeninode' => $vlan->_geninodes() });
	    
	    # So we ignore it when it comes back from assign.
	    $self->lannodes()->{$lannode} = 1;
	    
	    foreach my $member (@members) {
		my $virtnode   = $member->virt_node();
		my $vnodevname = $virtnode->vname();
		
		my ($delay,$bw,$ebw,$backfill,$loss,
		    $rdelay,$rbw,$rebw,$rbackfill,$rloss) =
			@{$member->_delayinfo()};
		
		# Need to know about tracing on a per queue basis, since the
		# user can specify tracing asymmetrically.
		my ($traced,$trace_endnode)  = @{$member->_traceinfo()};
		
		#
		# See if the link is really being shaped, or if the we just
		# need a delay node cause of tracing/monitoring.
		#
		my $shaped = 0;

                # XXX The expression below should be modified for
                # better bandwidth support.  Probably needs to happen
                # post assign somehow.
		if (((($delay >= $DELAYTHRESH) ||
		      (!$nobwshaping &&
		       $self->requires_delay($member, $vlan, $bw)) ||
		      ($loss != 0)) || 
		     (($rdelay >= $DELAYTHRESH) ||
		      (!$nobwshaping &&
		       $self->requires_delay($member, $vlan, $rbw)) ||
		      ($rloss != 0)) ||
		     # Link must be shaped for other reasons (q_red).
		     $mustdelay ||
		     # Global force, or per-lan force. 
		     $self->option('forcelinkdelays') || $uselinkdelay) &&
		    # No shaping on bridged lans.
		    !$vlan->_bridged() &&
		    # No shaping for geni nodes.
		    $vlan->_geninodes() == 0) {
		    $shaped = 1;
		    # Mark the link as shaped for later.
		    $vlan->setmembershaped($member);
		}

		#
		# Check to make sure that this node supports linkdelays.
		# This check is only made for links comprised of physical
		# nodes, since if the OS supports virtual nodes, it
		# supports linkdelays.
		#
		if ($shaped && $virtnodes == 0 &&
		    $self->virtlan_use_linkdelay($vlan, $shaped)) {
		    #
		    # The user had to specify the OS.
		    #
		    if (! defined($virtnode->_osinfo())) {
			tberror("You must specify the OSID for all nodes in ".
				"lan $vlan, when using linkdelays ".
				"(endnode traffic shaping)\n");
			$errors++;
		    }
		    else {
			#
			# All the OSes have to support linkdelays.
			#
			my $osinfo = $virtnode->_osinfo();
			
			if (!defined($osinfo)) {
			    tbreport(SEV_ERROR, 'node_lacks_linkdelay_support',
				     $virtnode, $vlan);
			}
			elsif (! $osdoeslinkdelays{$osinfo->osid()}) {
			    my $osname = $osinfo->osname();
			    tbwarn("$virtnode in lan $vlan is running an OSID".
				   " ($osname) that does not support linkdelays".
				   " (endnode traffic shaping)\n");
			    $errors++;
			}
		    }
		}
		my ($top_bw, $top_rbw) = $self->virtlantopbw($vlan, $member);
		my $bandwidth  = $self->getbandwidth($member,$vlan,$bw);
		my $rbandwidth = $self->getbandwidth($member,$vlan,$rbw);

		if (($shaped || ($traced && !$trace_endnode)) &&
		    # Ignore for bridged links.
		    !$vlan->_bridged() &&
		    # if we have 1 real node in the LAN, we may need to create
		    # a lan
		    ($realnodes != 0)) {
		    $self->exptstats()->{"shapedlans"} += 1;
		    
		    #
		    # We use a linkdelay if the link is emulated,
		    # globally forced, globally preferred if the link
		    # is shaped, or if the per-link flag was set
		    # (which means to put in a link delay regardless
		    # of whether the link is shaped).
		    #
		    if ($self->virtlan_use_linkdelay($vlan, $shaped)) {
			my $plink = "linklan/$vname/$member";
				
			my @delayinfo = ($delay,$bw,$backfill,$loss,
					 $rdelay,$rbw,$rbackfill,$rloss,0);
			
			my $others = {};
			if ($emulated) {
			    $others->{'emulated'} = 1 if ($member->_emulated());
			    $others->{'virtualization_type'} =
				$vlan->_encapstyle();
			}
			if ($trivial_ok) {
			    $others->{'trivial_ok'} = 1;
			}
			#
			# If the virtnode is a VM and it has been fixed to
			# a topology node, then we have to use that node
			# name, since the VM names do not appear in the vtop.
			#
			if (defined($virtnode->_fixedvm())) {
			    $vnodevname = $virtnode->_fixedvm()->vname();
			}
		    
			$self->createLink($vname, $plink, [],
					{'virtual_node_id' => $vnodevname,
					 'virtual_interface_id' =>"$member" },
					{'virtual_node_id' => "$lannode",
					 'virtual_interface_id' =>"$member" },
					  $top_bw == 0 ? "*" : 
					  max($top_bw,$top_rbw),
					  $protocol, $others);
			
			$self->printdb("Delay link $plink = " .
				       join(" ", @delayinfo) . "\n");
			
			# Save for the post pass.
			$self->delaylinks()->{$plink} = \@delayinfo;
		    }
		    else {
			my $delayname   = $self->nextdelayname();
			my $plink       = "linkdelaysrc/$vname/$member";
			my $delaydesirename = $self->delay_desire_name();
			my $delaydesiretype = $self->delay_desire_type();
			my $delaydesirepenalty = $self->delay_desire_penalty();
				
			my @delayinfo   = ($delay,$bw,$backfill,$loss,
					   $rdelay,$rbw,$rbackfill,$rloss,0);
			
			my $desire = {};
			if ($delaydesirename ne '') {
			    $desire->{$delaydesirename} = 
				[$delaydesiretype, $delaydesirepenalty];
			}
			$self->createNode($delayname, $mycmurn, "delay", '1',
					  $desire, undef);
			
			my $others = {};
			$self->createLink($vname,
					  "linkdelaysrc/$vname/$member",
					  [$mycmurn],
				       {'virtual_node_id' => $vnodevname,
					 'virtual_interface_id' =>"$member" },
				       {'virtual_node_id' => $delayname,
					 'virtual_interface_id' =>"$member" },
					  $top_bw == 0 ? "*" : $top_bw,
					  $protocol, $others);
				
			$self->createLink($vname,
					  "linkdelaydst/$vname/$member",
					  [$mycmurn],
					{'virtual_node_id' => "$lannode",
					 'virtual_interface_id' =>"$member" },
					{'virtual_node_id' => $delayname,
					 'virtual_interface_id' =>"$member" },
					  $top_bw == 0 ? "*" : $top_bw,
					  $protocol, {});
			
			$self->printdb("Delay node $plink ($delayname) = " .
				       join(" ", @delayinfo) . "\n");
	
			# Save for the post pass.
			$self->delaylinks()->{$plink} = \@delayinfo;
			$self->delaynodes()->{$delayname} = $delayname;
			
			# XXX Mark the lan as having delayed members so that
			# we create a delayed protolan. Bogus.
			$vlan->_delayed(1);
		    }
		    #
		    # Port is set to the next-fastest speed when the link
		    # gets a delay node.  This can override initialization
		    # above cause we could not tell earlier if the link was
		    # going to get a real delay node or just a
		    # delaywithswitch.
		    #
		    $self->portbw()->{$member} = $bandwidth;	    
		}
		else {
		    my $plink = "linklan/$vname/$member";
		    my $others = {'isgeninode' => $vlan->_geninodes()};
		    if ($emulated) {
			$others->{'emulated'} = 1 if ($member->_emulated());
			$others->{'virtualization_type'} =
			    $member->_encapstyle();
		    }
		    if ($trivial_ok) {
			$others->{'trivial_ok'} = 1;
		    }
		    #
		    # If the virtnode is a VM and it has been fixed to
		    # a topology node, then we have to use that node
		    # name, since the VM names do not appear in the vtop.
		    #
		    if (defined($virtnode->_fixedvm())) {
			$vnodevname = $virtnode->_fixedvm()->vname();
		    }
		    
		    #
		    # We store this info in case assign actually does
		    # turn it into a trivial link. If that happens, we
		    # have to insert a link delay if the link is
		    # between two vnodes. Why?  Cause a trivial link
		    # (using loopback) would have much more bandwidth
		    # (400+ Mb) then your typical 100Mb link. Note the
		    # final member of the array, which indicates this
		    # delay should be inserted only if assign makes it
		    # a trivial link.
		    #
		    if (!$nobwshaping) {
			$self->delaylinks()->{$plink} = 
			    [$delay,$bw,$backfill,$loss,
			     $rdelay,$rbw,$rbackfill,$rloss,1.000000];
		    }
		    $self->createLink($vname, $plink,
				      [$virtnode->_cmurn()],
				      {'virtual_node_id' => $vnodevname,
				       'virtual_interface_id' =>"$member" },
				      {'virtual_node_id' => $lannode,
				       'virtual_interface_id' =>"$member" },
				      ($top_bw == 0 ? "*" : $top_bw), 
				      $protocol, $others);
		}
	    }
	}
    }
    return $errors;
}

#
# Print the results in plain text top file format.
#
sub PrintTop($;$)
{
    my ($self, $outfile) = @_;

#    print Dumper($self);
    my $output = "";
    my %fixedifaces = ();

    foreach my $vclass (@{$self->rspec()->{'vclass'}}) {
	$output .= 'make-vclass ' . ' ';
	$output .= $vclass->{'name'} . ' ';
	$output .= $vclass->{'weight'} . ' ';
	foreach my $nodetype (@{$vclass->{'members'}}) {
	    $output .= $nodetype . ' ';
	}
	$output .= "\n";
    }

    foreach my $node (@{$self->rspec()->{'node'}}) {
	next
	    if (exists($node->{'isgeninode'}) && $node->{'isgeninode'});
	
	$output .= 'node' . ' ';
	$output .= $node->{'virtual_id'} . ' ';
	$output .= $node->{'node_type'} . ':' . $node->{'type_slots'} . ' ';
	if (exists($node->{'disallow_trivial_mix'})) {
	    $output .= 'disallow_trivial_mix' . ' ';
	}
	if (exists($node->{'subnode'})) {
	    $output .= 'subnode_of:' . $node->{'subnode'} . ' ';
	}
	while ( my ($desire, $desireval) = each (%{$node->{'desires'}})) {
	    $output .= $desireval->[0] . $desire . 
		':' .  sprintf("%f", $desireval->[1]) . ' ';
	}
	$output .= "\n";

	#
	# In ptop format, the fixed interfaces go on the link lines,
	# so just save them up for below.
	#
	if (exists($node->{'interfaces'})) {
	    foreach my $ref (@{ $node->{'interfaces'} }) {
		my $virtid = $ref->{'virtual_id'};
		my $compid = $ref->{'component_id'};

		$fixedifaces{$virtid} = $compid
		    if (defined($compid));
	    }
	}
    }

    foreach my $link (@{$self->rspec()->{'link'}}) {
	next
	    if (exists($link->{'isgeninode'}) && $link->{'isgeninode'});

	$output .= 'link' . ' ';
	$output .= $link->{'plink'} . ' ';
	$output .= $link->{'interface_ref'}->[0]->{'virtual_node_id'} . ' ';
	$output .= $link->{'interface_ref'}->[1]->{'virtual_node_id'} . ' ';
	$output .= $link->{'capacity'} . ' ';
	$output .= $link->{'latency'} . ' ';
	$output .= $link->{'packet_loss'} . ' ';
	$output .= $link->{'link_type'} . ' ';
	if (exists ($link->{'nodelay'})) {
	    $output .= 'nodelay' . ' ';
	}
	if (exists($link->{'emulated'})) {
	    $output .= 'emulated' . ' ';
	}
	if (exists($link->{'trivial_ok'})) {
	    $output .= 'trivial_ok' . ' ';
	}
	my $ifaceid1 = $link->{'interface_ref'}->[0]->{'virtual_interface_id'};
	my $ifaceid2 = $link->{'interface_ref'}->[1]->{'virtual_interface_id'};
	if (exists($fixedifaces{$ifaceid1})) {
	    $output .= 'fixsrciface:' . $fixedifaces{$ifaceid1} . ' ';
	}
	if (exists($fixedifaces{$ifaceid2})) {
	    $output .= 'fixdstiface:' . $fixedifaces{$ifaceid2} . ' ';
	}
	$output .= "\n";
    }

    foreach my $fixednode (@{$self->rspec()->{'fixed'}}) {
	$output .= 'fix-node' . ' ';
	$output .= $fixednode->{'vnode'} . ' ';
	$output .= $fixednode->{'pnode'};
	$output .= "\n";
    }

    $outfile = *STDOUT
	if (!defined($outfile));
    print $outfile $output;
    return 0;
}


#
# Print the rspec part of the topo. Eventually the whole thing needs
# to be in rspec. The RSPEC prints the results in v2 format
#
sub PrintRspec($;$)
{
    my ($self, $output) = @_;
    $output = *STDOUT
	if (!defined($output));
    
    my $doc = XML::LibXML::Document->new();

    # Construct the current time string 
    my $creation = time();
    my $expiration = $creation + 3600;

    my $rspecns = "http://www.protogeni.net/resources/rspec/2";
    my $rspecurl = "http://www.protogeni.net/resources/rspec/2/request.xsd";
    my $extns = "http://www.protogeni.net/resources/rspec/ext/emulab/1";
    my $exturl = "http://www.protogeni.net/resources/rspec/ext/emulab/1/vtop_extension.xsd";
    
    my $root = $doc->createElement("rspec");
    $root->setAttribute("xmlns", "$rspecns");
    $root->setAttribute("xmlns:xsi",
			"http://www.w3.org/2001/XMLSchema-instance");
    $root->setAttribute("xmlns:emulab", "$extns");

    ### XXX: Change the URL
    $root->setAttribute("xsi:schemaLocation",
			"$rspecns $rspecurl $extns $exturl"); 
    $root->setAttribute("type", "request");
    $root->setAttribute("generated", 
			POSIX::strftime("20%y-%m-%dT%H:%M:%S",
					gmtime($creation)));
    $root->setAttribute("valid_until",
			POSIX::strftime("20%y-%m-%dT%H:%M:%S",
					gmtime($expiration)));
    
    $doc->setDocumentElement($root);

    foreach my $ref (@{$self->rspec()->{'node'}}) {
    	$self->processNodeRspec($doc, $root, $ref);
    }
    foreach my $ref (@{$self->rspec()->{'link'}}) {
	$self->processLinkRspec($doc, $root, $ref);
    }
    foreach my $ref (@{$self->rspec()->{'vclass'}}) {
	$self->processVClassRspec($doc, $root, $ref);
    }
    
    print $output $doc->toString(1) . "\n";
    return 0;
}

#
# One time initialization for a vtop. 
#
sub CreateVtop($)
{
    my ($self) = @_;
    my $pid = $self->experiment()->pid();

    #
    # This is for stats gathering. It might duplicate other stuff, but
    # thats okay.
    #
    $self->{'EXPTSTATS'} =
    {
        # pnodes include jailnodes and delaynodes.
	# We let the wrapper determine pnodes once the
	# experiment is fully swapped in so that the record
	# is not "committed" until successful swapin.
	'jailnodes'   => 0,
	'vnodes'      => 0,
	# vnodes include wanodes.
	'wanodes'     => 0,
	# wanodes includes plabnodes.
	'plabnodes'   => 0,
	'simnodes'    => 0,
	'delaynodes'  => 0,
	'linkdelays'  => 0,
	'links'       => 0,
	'walinks'     => 0,
	'lans'        => 0,
	'wirelesslans' => 0,
	'shapedlinks' => 0,
	'shapedlans'  => 0,
	'minlinks'    => 100000,
	# includes emulated links. Maybe thats wrong.
	'maxlinks'    => 0,
    };

    # Initialize counters.
    $self->{'COUNTERS'}->{'nodecount'}   = 0;
    $self->{'COUNTERS'}->{'plabcount'}   = 0;
    $self->{'COUNTERS'}->{'genicount'}   = 0;
    $self->{'COUNTERS'}->{'virtcount'}   = 0;
    $self->{'COUNTERS'}->{'simcount'}    = 0;
    $self->{'COUNTERS'}->{'remotecount'} = 0;
    $self->{'COUNTERS'}->{'sharedcount'} = 0;
    $self->{'COUNTERS'}->{'physcount'}   = 0;

    #
    # Experiment wide options.
    #
    # Set this when forcing linkdelays instead of delay nodes. NS file.
    $self->options()->{'uselinkdelays'} =
	($self->virtexperiment()->uselinkdelays() ? 1 : 0);

    # Force a link delay, even when no delay would otherwise be inserted.
    $self->options()->{'forcelinkdelays'} =
	($self->virtexperiment()->forcelinkdelays() ? 1 : 0);

    # Allow override of delay capacity.
    $self->options()->{'delay_capacity'} = ($DELAYCAPACITY || 1);
    if ($self->virtexperiment()->delay_capacity()) {
	$self->options()->{'delay_capacity'} =
	    $self->virtexperiment()->delay_capacity();
	$self->options()->{'delaycap_override'} = 1;
	# Record this in the stats only when overridden.
	$self->exptstats()->{'delay_capacity'}  =
	    $self->options()->{'delay_capacity'};
    }

    # Allow override of delay osid.
    if (defined($self->virtexperiment()->delay_osname())) {
	my $osname = $self->virtexperiment()->delay_osname();
	my $osinfo = OSinfo->Lookup($pid, $osname);
	if (!defined($osinfo)) {
	    $osinfo = OSinfo->LookupByName($osname);
	    if (!defined($osinfo)) {
		tberror({cause => 'user',
			 type => 'primary', severity => SEV_ERROR,
			 error => ['invalid_os', 'delay', $osname, $pid]},
			"Invalid OS $osname in project $pid!");
		return -1;
	    }
	}
	my $osid = $osinfo->osid();
	$self->options()->{'delay_osid'} = $osid;
	# Keep a desire string we can use to make sure that the node
	# type picked for the delay node can load the right OS.
	$self->options()->{'delay_desire_type'} = '';
	$self->options()->{'delay_desire_name'} = "OS-$osid";
	$self->options()->{'delay_desire_penalty'} = '1';
    }
    else {
	$self->options()->{'delay_desire_type'} = '';
	$self->options()->{'delay_desire_name'} = '';
	$self->options()->{'delay_desire_penalty'} = '';
    }

    # Allow override of jail osid.
    if (defined($self->virtexperiment()->jail_osname())) {
	my $osname = $self->virtexperiment()->jail_osname();
	my $osinfo = OSinfo->Lookup($pid, $osname);
	if (!defined($osinfo)) {
	    $osinfo = OSinfo->LookupByName($osname);
	    if (!defined($osinfo)) {
		tberror({cause => 'user',
			 type => 'primary', severity => SEV_ERROR,
			 error => ['invalid_os', 'jail', $osname, $pid]},
			"Invalid OS $osname in project $pid!");
		return -1;
	    }
	}
	$self->options()->{'jail_osid'} = $osinfo->osid();
    }

    # XXX woeful NSE hack
    my $sim_osname = "FBSD-NSE";
    if (defined($sim_osname)) {
	my $osinfo = OSinfo->Lookup($pid, $sim_osname);
	if (!defined($osinfo)) {
	    $osinfo = OSinfo->LookupByName($sim_osname);
	}
	if (defined($osinfo)) {
	    $self->options()->{'sim_osid'} = $osinfo->osid();
	}
	elsif (exists($self->options()->{'jail_osid'})) {
	    $self->options()->{'sim_osid'} = $self->options()->{'jail_osid'};
	}
    }

    # Option to fix current resources. Command line overrides experiment.
    # This option does not make sense unless updating is also on.
    if ($self->updating() && !$self->fixcurrent() &&
	$self->virtexperiment()->allowfixnode()) {
	$self->{'FLAGS'} |= $VTOP_FLAGS_FIXNODES;
    }

    #
    # If updating, load current experiment resources. We have to be
    # careful of how this is merged in with the (new) desired
    # topology. Fixnodes might also be set independently of updating.
    #
    if ($self->updating() || $self->fixcurrent()) {
	return -1
	    if ($self->LoadCurrentResources());
    }
    
    return -1
	if ($self->LoadPhysInfo() ||
	    $self->LoadVirtNodes() ||
	    $self->LoadVirtLans());
    
    return -1
	if ($self->GenVirtTypes() ||
	    $self->GenVirtNodes() ||
	    $self->GenVirtLans() ||
	    $self->GenFixNodes() ||
	    $self->PrintSummaryStats());

    # Stats for the caller.
    $self->exptstats()->{"vnodes"}    = $self->counters()->{'virtcount'};
    $self->exptstats()->{"wanodes"}   = $self->counters()->{'remotecount'};
    $self->exptstats()->{"plabnodes"} = $self->counters()->{'plabcount'};
    $self->exptstats()->{"simnodes"}  = $self->counters()->{'simcount'};

    return 0;
}

#
# getbandwidth(bw)
# Returns the lowest ok bandwidth that is greater than or equal to
# the one passed. Takes a virtual node, from which it grabs a type - only
# considers bandwidths on the node types the virtual node can be mapped to.
# Very similar to requires_delay().
#
sub getbandwidth($$$$)
{
    my ($self, $virtlanmember, $virtlan, $targetbw) = @_;
    my $best = 10000000000;

    my $virtnode  = $virtlanmember->virt_node();
    my $node_type = $virtnode->type();
    my $protocol  = protocolbasetype($virtlan->_protocol());
    my $linkbws   = $self->{'TYPELINKBW'};

    #
    # A target bandwidth of zero indicates that we want assign to choose.
    #
    return 0
	if ($targetbw == 0);
	
    foreach my $bw (keys(%{ $linkbws->{$node_type}{$protocol} })) {
	if (($bw >= $targetbw) && ($bw < $best)) {
	    $best = $bw;
	}
    }

    if (! $virtnode->_isvtyped()) {
	my $node_class = $virtnode->_typeinfo()->class();
	
	foreach my $bw (keys(%{ $linkbws->{$node_class}{$protocol} })) {
	    if (($bw >= $targetbw) && ($bw < $best)) {
		$best = $bw;
	    }
	}
    }
    return $best;

}

# requires_delay()
# Returns 1 if the given bandwidth requires that a delay node be inserted, 0
# if it can be handled by some interface in the testbed
#
# Way bogus! We have to guess if we need to insert a delay node (assign should
# really be doing this). We need a delay node if the desired bw does not
# match the native hardware link speed. Of course, we do not know what assign
# will map the node too, but we do know generally what interface speeds are
# supported on each type/class of hardware that the user might request. If
# a 50Mb link on a "pc" is requested, we know we need a delay node cause
# pcs support just 100Mb and 1000Mb links. assign might pick either one, but
# we know we need a delay node no matter what. The problem is what happens if
# the user asks for 100Mb (no delay node), but assign maps it to a 1000Mb link?
# Well, we are screwed since we needed a delay node. We are ignoring that
# problem for now since no one has access to 1gig interfaces at the moment.
# 
sub requires_delay($$$$)
{
    my ($self, $virtlanmember, $virtlan, $targetbw) = @_;

    my $virtnode  = $virtlanmember->virt_node();
    my $node_type = $virtnode->type();
    my $protocol  = protocolbasetype($virtlan->_protocol());
    my $linkbws   = $self->{'TYPELINKBW'};
    my $node_class;

    #
    # A target bandwidth of zero indicates that we want assign to choose.
    # Therefore, no delay is needed since assign picks the native bw.
    #
    return 0
	if ($targetbw == 0);
	
    if (!exists($linkbws->{$node_type}{$protocol})) {    
	warn("requires_delay(): $virtnode - invalid type $node_type!\n");
	return 0;
    }

    if (! $virtnode->_isvtyped()) {
	$node_class = $virtnode->_typeinfo()->class();
	
	if (!exists($linkbws->{$node_class}{$protocol})) {
	    warn("requires_delay(): $virtnode - invalid class $node_class!\n");
	    return 0;
	}
    }

    foreach my $bw (keys(%{ $linkbws->{$node_type}{$protocol} })) {
	return 0
	    if ($targetbw == $bw);
    }
    if (defined($node_class)) {
	foreach my $bw (keys(%{ $linkbws->{$node_class}{$protocol} })) {
	    return 0
		if ($targetbw == $bw);
	}
    }
    return 1;
}

#
# Return the (bandwidth, rbandwidth) to put into a top file for this link -
# this is _NOT_ the hard limit on bandwidth that the user asked for us to
# set up traffic shaping for.
#
sub virtlantopbw($$$) {
    my ($self, $virtlan, $member) = @_;
    my $node = $member->virt_node()->vname();

    my ($delay,$bw,$ebw,$backfill,$loss,
	$rdelay,$rbw,$rebw,$rbackfill,$rloss) = @{$member->_delayinfo()};

    # Return the estimated bw if it was given; otherwise, return the normal
    # bandwidth, 
    my ($return_bw, $return_rbw);
    
    if (defined($ebw)) {
	$return_bw = $ebw;
    }
    else {
	#
	# If this is an emulated link, or one on which we are doing end node
        # shaping we put in only the bandwidth from the virtual topology -
	# otherwise, we put in the bandwidth of the type of physical interface
	# it is likely to get mapped to.
	#
        my $shaped = $virtlan->membershaped($member);
	
	if ($virtlan->_emulated() ||
	    $self->virtlan_use_linkdelay($virtlan, $shaped)) {
	    $return_bw = $bw;
	}
	else {
	    $return_bw = $self->getbandwidth($member, $virtlan, $bw);
	}
    }

    if (defined($rebw)) {
	$return_rbw = $rebw;
    }
    else {
	#
	# If this is an emulated link, we put in only the reported
	# bandwidth - otherwise, we put in the bandwidth of the type
	# of physical interface it is likely to get mapped to
	#
	if ($virtlan->_emulated()) {
	    $return_rbw = $rbw;
	}
	else {
	    $return_rbw = $self->getbandwidth($member, $virtlan, $bw);
	}
    }
    return ($return_bw, $return_rbw);
}

#
# Determine if a given link/lan uses linkdelays
#
sub virtlan_use_linkdelay($$$) {
    my ($self, $virtlan, $shaped) = @_;

    #print Dumper($virtlan);

    #
    # Here are the conditions for using linkdelays on each link/lan
    # Note: $forcelinkdelays and $uselinkdelays are global
    #
    if ( # linkdelays can be globally forced
         $self->option('forcelinkdelays') ||
         # We use linkdelays on emulated virtlans
         $virtlan->_emulated() ||
	 # Some of the nodes are on shared pnodes.
	 $virtlan->_sharednodes() ||
         # The user requested linkdelays, and this is a virtlan that gets
         # shaped (note - in this case, non-shaped virtlans don't get
         # linkdelays)
         ($self->option('uselinkdelays') && $shaped) ||
         # The user forced linkdelays for this specific virtlan
         $virtlan->_uselinkdelay()) {
        # Yep, use linkdelays
	#$self->printdb("Using linkdelay for $virtlan\n");
        return 1;
    } else {
        # No - either won't be delayed at all, or we'll use a delay node
        return 0;
    }
}

# We do not actually store information about the protocol heirarchy in the
# database, so we use a simple conventions for now - <basetype>[-subtype]
sub protocolbasetype($) {
    if ($_[0] =~ /^([^-]+)-/) {
        return $1;
    } else {
        return $_[0];
    }
}

#############################################################################
#
# Solution. Now we get into the code to process the solution. 
#
# Stuff for the solution and interpretation.
sub solution($)           { return $_[0]->{'SOLUTION'}; }
sub solution_p2v($)       { return $_[0]->{'SOLUTION'}->{'P2V'}; }
sub solution_v2p($)	  { return $_[0]->{'SOLUTION'}->{'V2P'}; }
sub solution_v2v($)	  { return $_[0]->{'SOLUTION'}->{'V2V'}; }
sub solution_plinks($)	  { return $_[0]->{'SOLUTION'}->{'PLINKS'}; }
sub solution_virtnodes($) { return $_[0]->{'SOLUTION'}->{'VIRTNODES'}; }
sub solution_delaynodes($){ return $_[0]->{'SOLUTION'}->{'DELAYNODES'}; }
sub solution_rtabmap($)	  { return $_[0]->{'SOLUTION'}->{'RTABMAP'}; }
sub solution_vethmap($)   { return $_[0]->{'SOLUTION'}->{'VETHMAP'}; }
sub solution_vethpatch($) { return $_[0]->{'SOLUTION'}->{'VETHPATCHES'}; }
sub solution_portmap($)   { return $_[0]->{'SOLUTION'}->{'PORTMAP'}; }
sub solution_vifacemap($) { return $_[0]->{'SOLUTION'}->{'VIFACEMAP'}; }
sub solution_ifacemap($)  { return $_[0]->{'SOLUTION'}->{'IFACEMAP'}; }

sub MapResources($)
{
    my ($self) = @_;

    if ($self->genicount()) {
	my $genirspec;
	
	$self->printdb("Mapping geni resources ...\n");
	
	if (libGeni::MapResourcesNew($self->experiment(),
				  $self->user(), $self->rspec(),
				  \$genirspec, $self->verbose())) {
	    tberror("Could not map Geni resources\n");
	    return -1;
	}
	if ($self->ReadRspecSolution($genirspec) != 0) {
	    tberror("Could not parse rspec solution! $!\n");
	    return -1;
	}
	$self->{'GENIRSPEC'} = $genirspec;
    }
    return 0;
}

sub ClearSolution($)
{
    my ($self) = @_;

    # Start with a new solution vector each time.
    $self->{'SOLUTION'} = {};
    $self->{'SOLUTION'}->{'TORESERVE'}   = {};
    $self->{'SOLUTION'}->{'V2P'}         = {};
    $self->{'SOLUTION'}->{'P2V'}         = {};
    $self->{'SOLUTION'}->{'V2V'}         = {};
    $self->{'SOLUTION'}->{'PLINKS'}      = {};
    $self->{'SOLUTION'}->{'VIRTNODES'}   = {};
    $self->{'SOLUTION'}->{'DELAYNODES'}  = {};
    $self->{'SOLUTION'}->{'RTABMAP'}     = {};
    $self->{'SOLUTION'}->{'VETHMAP'}     = {};
    $self->{'SOLUTION'}->{'VETHPATCHES'} = {};
    $self->{'SOLUTION'}->{'PORTMAP'}     = {};
    $self->{'SOLUTION'}->{'VIFACEMAP'}   = {};
    $self->{'SOLUTION'}->{'IFACEMAP'}    = {};

    return 0;
}

sub AddNodeToSolution($$$)
{
    my ($self, $virtual, $physical) = @_;

    # Skip LAN/Fake nodes.
    return 0
	if (exists($self->lannodes()->{$virtual}));

    #
    # XXX Must distinguish between local and ProtoGeni resources
    # until libGeni code is updated for new rspec stuff.
    #
    # This might not exist, as for internal nodes.
    my $virtnode = $self->vnodes()->{$virtual};

    if (defined($virtnode) && $virtnode->_isgeninode()) {
	#
	# We need the local node object which is essentially a
	# proxy for the real node at the remote component manager.
	#
	my $proxynode = libGeni::LookupProxyNode($physical);
	if (!defined($proxynode)) {
	    tberror("Could not find proxynode for $physical\n");
	    return -1;
	}
	$physical = $proxynode->node_id();
    }
    elsif ($PGENISUPPORT && GeniHRN::IsValid($physical)) {
	(undef,undef,$physical) = GeniHRN::Parse($physical);
    }

    # All we do in this stage is store the results.
    $self->solution()->{'V2P'}->{$virtual}  = $physical;
    $self->solution()->{'P2V'}->{$physical} = []
	if (!exists($self->solution()->{'P2V'}->{$physical}));

    push(@{ $self->solution()->{'P2V'}->{$physical} }, $virtual);
    $self->printdb("  $virtual $physical\n");

    return 0;
}

sub AddLinkToSolution($$$$$$$$;$)
{
    my ($self,
	$vlink, $trivial, $direct, $nodeA, $portA, $nodeB, $portB,
	$switchpath) = @_;
	
    #
    # Map the solution back to our objects and store the results.
    #
    my ($linktag) = ($vlink =~ m|^(\w+)/|);
    my $virtlan;
    my $member0;
    my $member1;
    my ($lan,$virtA,$virtB) = undef;

    if (($lan,$virtA,$virtB) =
	($vlink =~ m|^linksdelaysrc/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linkdelaysrc/([^/]+)/(.+)$|)) {
	# This is the link between the original node and the delay node.
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
    }
    elsif (($lan,$virtA,$virtB) =
	   ($vlink =~ m|^linksimple/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	if (!$trivial) {
	    $member0->_pnode($nodeA);
	    $member0->_pport($portA);
	    $member1->_pnode($nodeB);
	    $member1->_pport($portB);
	}
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linklan/([^/]+)/(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	if (!$trivial) {
	    $member0->_pnode($nodeA);
	    $member0->_pport($portA);
	    # For a special case, see below.
	    if (defined($nodeB)) {
		$member0->_lannode($nodeB);
		$member0->_lanport($portB);
	    }
	    else {
		$member0->_lannode("null");
		$member0->_lanport("null");
	    }
	}
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^fakelan/([^/]+)/(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
    }
    elsif (($lan,$virtA) =
	   ($vlink =~ m|^linkdelaydst/([^/]+)/(.+)$|)) {
	# This is the link between the delay node and lannode.
	$virtlan = $self->vlans()->{$lan};
	# Special case since the other side is a lannode.
	$member0 = $virtlan->members()->{$virtA};
	$member0->_delayportB($portB);
	# Stash the path here. Silly, but its easier.
	$member0->_delaypath($switchpath);
    }
    elsif (($lan,$virtA,$virtB) =
	   ($vlink =~ m|^linksdelaydst/(.+)/(.+),(.+)$|)) {
	$virtlan = $self->vlans()->{$lan};
	$member0 = $virtlan->members()->{$virtA};
	$member1 = $virtlan->members()->{$virtB};
	$member0->_pnode($nodeA);
	$member0->_pport($portA);
	$member0->_delaynode($nodeB);
	$member0->_delayport($portB);
	# Stash the path here. Silly, but its easier.
	$member0->_delaypath($switchpath);
    }
    else {
	tberror("Bad vlink in solution: $vlink\n");
	return -1;
    }

    $self->solution_plinks()->{$vlink} =
	[$linktag,$virtlan,$trivial,$direct,$member0,$member1,$switchpath];
    if (!$trivial) {
	$self->printdb("  $vlink ".
		       (defined($nodeA) ? "A:$nodeA:$portA " : "") .
		       (defined($nodeB) ? "B:$nodeB:$portB " : "") .
		       ($direct ? " (direct)" : "") . "\n");
    }
    else {
	$self->printdb("  $vlink trivial\n");
    }
    return 0;
}

sub ReadTextSolution($$)
{
    my ($self, $input) = @_;

    $self->ClearSolution();

    #
    # Still using the old assign format.
    #
    my $found_nodes_section = 0;
    
    while (<$input>) {
	# find the 'BEST SCORE' line and print that out for informational
	# purposes
	if (/BEST SCORE/) {
	    chomp($_);
	    $self->solution()->{"BEST SCORE"} = $_;
	}
        if (/^Nodes:/) {
            $found_nodes_section = 1;
            last;
        }
    }
    if (!$found_nodes_section) {
        tbwarn("Unable to find Nodes section in assign output");
        return -1;
    }
    $self->printdb("Nodes:\n");
    while (<$input>) {
	chomp;
	/^End Nodes$/ && last;
	my @info = split;
	my ($virtual,$physical) = @info[0,1];

	$self->AddNodeToSolution($virtual, $physical);
    }

    # read Edges
    # By convention, in plinks, the delay node is always the second
    # entry.
    my $found_edges_section = 0;
    while (<$input>) {
        if (/^Edges:/) {
            $found_edges_section = 1;
            last;
        }
    }
    if (!$found_edges_section) {
        tbwarn("Unable to find Edges section in assign output");
        return -1;
    }

    $self->printdb("Edges:\n");
    EDGEWHILE: while (<$input>) {
	my ($vlink,$rawA,$rawB) = undef;
	my $trivial = 0;
	my $direct  = 0;
	my $swpath  = undef;

	/^End Edges$/ && last EDGEWHILE;
        my @info = split;
	my $line = $_;
	my $type = $info[1];
        SWITCH1: for ($type) {
	    /^intraswitch$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,5];
		last SWITCH1;
	    };
	    /^interswitch$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,$#info];
		#
		# We need to save the path through the switches for later.
		#	
		$swpath = getportlist(@info);
		last SWITCH1;
	    };
	    /^direct$/ && do {
		($vlink,$rawA,$rawB) = @info[0,3,5];
		$direct = 1;
		last SWITCH1;
	    };
	    /^trivial$/ && do {
		# we don't have plinks for trivial links
		$vlink   = $info[0];
		$trivial = 1;
		last SWITCH1;
	    };
	    tberror("Found garbage: $line\n");
	    return -1;
	}

	my ($nodeportA,$nodeportB) = undef;
	my ($switchportA,$switchportB) = undef;
	my ($nodeA,$portA,$nodeB,$portB) = undef;

	if (!$trivial) {
	    ($nodeportA,$switchportA) = getnodeport($rawA);

	    # TODO: Add this error checking code in once ptopgen_new
	    # becomes standard
#	    if (! defined($nodeportA) || ! defined($switchportA)) {
#		tberror("Malformed interface pair A: $rawA\n");
#		return -1;
#	    }

	    # Convert back to node:iface format.
	    if (defined($nodeportA)) {
		$nodeportA =~ s/\//:/;
		($nodeA,$portA) = split(":", $nodeportA);
	    }

	    my $isswitch = 1;
	    if (defined($switchportA)) {
		$switchportA =~ s/\//:/;
		my ($switchA, $swportA) = split(":", $switchportA);
		my $noderef = Node->Lookup($switchA);
		$isswitch = $noderef->isswitch();
	    }

	    #
	    # If the link is direct and switchA is not a switch, this is
	    # a link directly between two nodes:
	    #
	    # $rawA hold both sides of the link (switchportA is really
	    # $nodeportB).
	    if ($direct && ! $isswitch) {
		$nodeportB   = $switchportA;
		$switchportB = undef;
	    }
	    else {
		($nodeportB,$switchportB) = getnodeport($rawB);
	    }

	    # TODO: Add this error checking code in once ptopgen_new
	    # become standard
#	    if (! defined($nodeportA)) {
#		tberror("Malformed interface pair B: $rawB\n");
#		return -1;
#	    }

	    if (defined($nodeportB)) {
		# Convert back to node:iface format.
		$nodeportB =~ s/\//:/;
		($nodeB,$portB) = split(":", $nodeportB);
	    }
	}
	$self->AddLinkToSolution($vlink, $trivial, $direct,
				 $nodeA, $portA, $nodeB, $portB, $swpath);
    }
    return 0;
}

sub ReadRspecSolution($$)
{
    my ($self, $rspec) = @_;
    my %ifacemap = ();
	
    $self->printdb("Processing rspec\n");
    $self->printdb("Nodes:\n");

    foreach my $ref (GeniXML::FindNodes("n:node", $rspec)->get_nodelist()) {
	my $node_urn  = GeniXML::GetNodeId($ref);
	my $virtual   = GeniXML::GetVirtualId($ref);

	# Skip LAN/Fake nodes.
	return 0
	    if (exists($self->lannodes()->{$virtual}));

	$self->AddNodeToSolution($virtual, $node_urn);
	    
	$ifacemap{$virtual} = {};
	foreach my $linkref (GeniXML::FindNodes("n:interface",
						$ref)->get_nodelist()) {
	

	    my $component_id  = GeniXML::GetNodeId($linkref);
	    my $virtual_id    = GeniXML::GetVirtualId($linkref);
	    my $virtlan       = $self->memberof()->{$virtual_id};

	    # Skip tunnels until assign can handle multiple rspecs
	    next
		if ($virtlan->_tunnel());

	    if (GeniHRN::IsValid($component_id)) {
		my ($urn_authority,$urn_node,$urn_iface) =
		    GeniHRN::ParseInterface($component_id);
		$component_id = $urn_iface;
	    }
	    $ifacemap{$virtual}->{$virtual_id} = $component_id;
	}
    }
    
    $self->printdb("Links:\n");
    foreach my $ref (GeniXML::FindNodes("n:link",
					    $rspec)->get_nodelist()) {
	my $virtual_id = GeniXML::GetVirtualId($ref);
	my $virtlan    = $self->vlans()->{$virtual_id};
	
	if (!defined($virtlan)) {
	    tberror("Could not find lan $virtual_id\n");
	    return -1;
	}
	# Skip tunnels until assign can handle multiple rspecs
	next
	    if ($virtlan->_tunnel());
	
	my @ifacerefs = GeniXML::FindNodes("n:interface_ref",
					   $ref)->get_nodelist();

	if (scalar(@ifacerefs) == 2) {
	    my ($ifaceA,$ifaceB) = @ifacerefs;
	    my $trivial = 0;

	    my $virtA  = GeniXML::GetText("virtual_interface_id", $ifaceA);
	    my $virtB  = GeniXML::GetText("virtual_interface_id", $ifaceB);
	    my $vnodeA = GeniXML::GetText("virtual_node_id", $ifaceA);
	    my $vnodeB = GeniXML::GetText("virtual_node_id", $ifaceB);
	    my $nodeA  = $self->solution()->{'V2P'}->{$vnodeA};
	    my $nodeB  = $self->solution()->{'V2P'}->{$vnodeB};
	    my $portA  = $ifacemap{$vnodeA}->{$virtA};
	    my $portB  = $ifacemap{$vnodeB}->{$virtB};
	    my $vlink  = "linksimple/$virtual_id/$virtA,$virtB";

	    if ($portA eq "loopback" || $portB eq "loopback") {
		$nodeA = $nodeB = $portA = $portB = undef;
		$trivial = 1;
		$virtlan->_trivial_ok(1);
	    }
	    
	    $self->AddLinkToSolution($vlink, $trivial, 0,
				     $nodeA, $portA, $nodeB, $portB);
	}
	else {
	    foreach my $iref (@ifacerefs) {
		my $virtA  = GeniXML::GetText("virtual_interface_id", $iref);
		my $vnodeA = GeniXML::GetText("virtual_node_id", $iref);
		my $nodeA  = $self->solution()->{'V2P'}->{$vnodeA};
		my $portA  = $ifacemap{$vnodeA}->{$virtA};
	    
		my $vlink = "linklan/$virtual_id/$virtA";
	    
		$self->AddLinkToSolution($vlink, 0, 0, $nodeA, $portA);
	    }
	}
    }
    return 0;
}

#
# Interpret the results. This is really just the first stage.
#
sub InterpNodes($)
{
    my ($self) = @_;

    #
    # Pre pass; if the user fixed VMs to specific nodes, then have to
    # augment the solution.
    #
    foreach my $vname (sort(keys(%{ $self->fixednodes() }))) {
	my $vnode = $self->vnodes()->{$vname};
	my $fixed = $self->fixednodes()->{$vname};

	# Delay and internal nodes do not have an entry in vnodes().
	next
	    if (! (defined($vnode) &&
		   $vnode->_isvirtnode() && $vnode->_fixedvm()));

	$self->AddNodeToSolution($vname, $self->solution()->{'V2P'}->{$fixed})
	    if (!exists($self->solution()->{'V2P'}->{$vname}));
    }

    foreach my $virtual (keys(%{ $self->solution()->{'V2P'} })) {
	my $physical = $self->solution()->{'V2P'}->{$virtual};
	my $pnode    = $self->pnodes()->{$physical};

	# This might not exist, as for internal nodes.
	my $virtnode = $self->vnodes()->{$virtual};

	#
	# A node already allocated to this experiment, and still wanted.
	# We also have to watch for shared nodes; we will not have the
	# pnode loaded cause it is not actually ours. Instead, have to
	# look in the current_p2v table to see if we are using it. 
	#
	if (defined($pnode) ||
	    exists($self->current_p2v()->{$physical})) {
	    #
	    # Mark pnode as being reused.
	    #
	    # Look at node being mapped to the pnode;
	    # if it not in the previous map, mark node for reboot.
	    #
	    if (defined($pnode) && $pnode->_reuse() eq "reboot") {
		# No changes once it goes into reboot.
		;
	    }
	    elsif (defined($virtnode) && $virtnode->_isvirtnode()) {
		#
		# A new virtual node on an existing physical node
		# does not force the physnode to be rebooted; we can
		# set up a new virtnode on it without a reboot. If its
		# an existing virtual on the same physnode, then mark
		# both as reused; no need to reboot either. If the 
		# virtnode has moved here from someplace else, no
		# reboot of the physnode either, but obviously the
		# vnode will be released and a new one allocated.  What
		# we cannot determine is if its just a renamed node
		# (which would require a reboot of the the virtual
		# node). 
		#
		$pnode->_reuse("reused")
		    if (defined($pnode));

		if (exists($self->current_v2p()->{$virtual}) &&
		    $self->current_v2p()->{$virtual} eq $physical) {
		    # This is the virtual pnode allocated on the real pnode.
		    my $virtpname = $self->current_v2v()->{$virtual};
		    my $virtpnode = $self->pnodes()->{$virtpname};

		    $virtpnode->_reuse("reused");
		}
	    }
	    else {
		#
		# If a new node mapped to this physnode (maybe
		# even the luser changed the name of the node), or if an
		# existing virtual node moved to this physnode, must
		# reboot the physnode. Else, the physnode is being
		# reused as is, and no need to mess with it. If the
		# user requested reboot, that will be handled outside
		# of this script.
		#
		if (!exists($self->current_v2p()->{$virtual}) ||
		    $self->current_v2p()->{$virtual} ne $physical) {
		    $pnode->_reuse("reboot");
		}
		else {
		    $pnode->_reuse("reused");
		}
	    }
	}
	else {
	    my $pnodeobj = Node->Lookup($physical);

	    #
	    # This is a new node; we have to reserve it. Note that
	    # we do not reserve a widearea physnode when a virtual node
	    # is mapped to it; they are special.
	    #
	    # If there is no virtnode, then its an internal node, like
	    # a delay.
	    #
	    $self->solution()->{'TORESERVE'}->{$physical} = 1
		if ((!defined($virtnode) ||
		     !$virtnode->_isvirtnode() ||
		     !($virtnode->_isremotenode() &&
		       !$virtnode->_isdedremote())) &&
		    # Avoid allocating local shared physical node.
		    !(defined($virtnode) && $virtnode->_isvirtnode() &&
		      defined($pnodeobj->sharing_mode())));
	}

	if (!defined($virtnode)) {
	    #
	    # Internally created node. At the moment, these should be
	    # delay nodes.
	    #
	    if (! exists($self->delaynodes()->{$virtual})) {
		tbwarn("Unknown node $virtual on $physical\n");
		return -1;
	    }
	    if (!exists($self->solution_delaynodes()->{$physical})) {
		$self->solution_delaynodes()->{$physical} = [];
	    }
	    push(@{$self->solution_delaynodes()->{$physical}}, $virtual);
	    
	}
	elsif ($virtnode->_isvirtnode()) {
	    #
	    # If mapping a virtual node, then record that, since we need
	    # to allocate the virtnodes on that physnode, later.
	    #
	    if (!exists($self->solution_virtnodes()->{$physical})) {
		$self->solution_virtnodes()->{$physical} = [];
	    }
	    push(@{$self->solution_virtnodes()->{$physical}}, $virtual);
	}
	elsif ($virtnode->_issubnode()) {
	    #
	    # Subnodes are currently not dynamically created, and there
	    # is only one subnode per physical host. That physical host
	    # needs to be allocated, if we do not already have it.
	    #
	    my $subnode_pnode = Node->Lookup($physical);
	    if (!defined($subnode_pnode)) {
		tbwarn("Could not lookup subnode host $physical\n");
		return -1;
	    }
	    my $parentname = $subnode_pnode->phys_nodeid();
	    
	    if (! exists($self->solution()->{'P2V'}->{$parentname})) {
		# Make up a name and add to the reserve list.
		my $newvname = $self->newvname($parentname, "phost");

		$self->solution()->{'TORESERVE'}->{$parentname} = 1;
		$self->solution()->{'V2P'}->{$newvname}   = $parentname;
		$self->solution()->{'P2V'}->{$parentname} = [ $newvname ];

		$self->printdb("  Adding subnode: $newvname $parentname\n");
	    }
	}
    }
}

#
# Allocate nodes.
#
sub AllocNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
	
    if ($self->impotent()) {
	my @nodeids = keys(%{ $self->solution()->{'TORESERVE'} });

	tbinfo("Pretending to allocate @nodeids\n")
	    if (@nodeids);
	goto skip;
    }

    #
    # Move existing nodes into a holding experiment and then back.
    #
    # Why? We will avoid any UNIQUE key issues when a virt_node in the
    # topology moves from one pnode to another, or from previous to new
    # mapping.
    #
    # Another reason to do this just before nalloc of a new toreserve
    # nodes is that, we can get into name clashes. For example, lets
    # say the user called his node pc2 and it was actually mapped to
    # pc99 in the initial swapin. If this was a swapmod where the user
    # asked for another node node0 which got mapped to pc2. nalloc of
    # pc2 will result in UNIQUE key problems since there exists a
    # reserved vname pc2 (virtual name). By having this operation of
    # moving the nodes into a holding experiment and back before a new
    # nalloc, we avoid this UNIQUE key problem. Also note that simply
    # updating the vname to be the same as the node_id field also does
    # not work all the time i.e. in the example discussed above.
    #
    #
    # We need to only once during a mapping.  If it gets repeatedly
    # called coz only some pnode resources got nalloced, we do not
    # have to do the above again.
    #
    # XXX Is there a race with the shared pool deamon; the shared node
    # could get deallocated.
    # 
    my @nodeids = keys(%{ $self->oldreservednodes() });
    if (@nodeids && !$self->{'OLDRSRVCLEAN_FLAG'}) {
	system("$NFREE -o $pid $eid @nodeids");
	if ($?) {
	    tberror("Could not move nodes to old reserved holding\n");
	    return -1;
	}
	system("$NALLOC $pid $eid @nodeids");
	if ($?) {
	    tberror("Could not move nodes back from old reserved holding\n");
	    return -1;
	}
	$self->{'OLDRSRVCLEAN_FLAG'} = 1;
    }

    #
    # Now alloc new nodes. This might include nodes already allocated
    # in a previous iteration. That is okay; nalloc will ignore them.
    #
    @nodeids = keys(%{ $self->solution()->{'TORESERVE'} });
    $self->printdb("Trying to allocate @nodeids\n");
    system("$NALLOC -p $pid $eid @nodeids");
    my $exitval  = $? >> 8;

    #
    # If nalloc failed with a fatal error, lets give it up. No retry.
    # 
    if ($exitval < 0) {
	tberror("Failed to reserve any nodes.\n");
	return -1; 
    }

    #
    # Okay, if nalloc got anything, we have to set the norecover bit,
    # since tbswap operates on the principle that once new nodes are
    # reserved, recovery is no longer possible. However, if we exit
    # cleanly enough that we can deallocate the new nodes, recovery
    # is still possible. In the old assign_wrapper that was handled
    # in the Fatal(). In the new version ... 
    #
    $self->{'NORECOVER'} = 1;

    #
    # Got some, perhaps not all nodes.
    #
    my @reserved  = $experiment->NodeList(0, 1);	# objects, virtual.

    #
    # All newly allocated nodes MUST go to the INIT_DIRTY allocstate
    # since the user now has control of them. If we eventually fail,
    # nodes not in RES_READY are deallocated (retry/modify).
    #
    foreach my $pnode (@reserved) {
	my $nodeid = $pnode->node_id();
	    
	if (exists($self->solution()->{'TORESERVE'}->{$nodeid})) {
	    $self->newreserved()->{$nodeid} = $nodeid;
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_INIT_DIRTY())
		if (!$self->impotent());

	    #
	    # Fix all of the nodes assigned to the pnode.
	    #
	    foreach my $vname (@{ $self->solution_p2v()->{$nodeid} }) {
		$self->fixednodes()->{$vname} = $nodeid;

		# And add to the results for the next vtop print.
		$self->createFixedNode($vname, $nodeid)
		    if (!$pnode->isfednode());
	    }
	}
    }
    
    if ($exitval > 0) {
	#
	# We got some but not all the nodes.
	#
	my $rcount    = scalar(@reserved);
	my $tcount    = scalar(@nodeids);
	my @justnames = map { $_->node_id() } @reserved;


	# We got only some. Need to figure out which.
	tbinfo("Reserved some nodes ($rcount) we needed, ".
	       "but not all ($exitval).\n");
	
	#
	# We check to see if we were able to reserve all the fixed
	# nodes we needed. If we could not get the fixed list, then
	# this experiment is unlikely to map in the "near" future, so
	# give up now (no retry).
	#
	my @fixed = values(%{ $self->fixednodes() });
	foreach my $fixname (@fixed) {
	    if (! grep {$_ eq $fixname} @justnames) {
		tbwarn("  Could not allocate fixed node $fixname!\n");
		return -1;
	    }
	}
	
	#
	# Must extend the fixed list with newly allocated nodes so
	# that we can recreate the top file, and try again with a new
	# set.
	#
	foreach my $pnode (@reserved) {
	    my $nodeid = $pnode->node_id();
	    
	    if (exists($self->solution()->{'TORESERVE'}->{$nodeid})) {
		#
		# Fix all of the nodes assigned to the pnode.
		#
		foreach my $vname (@{ $self->solution_p2v()->{$nodeid} }) {
		    $self->fixednodes()->{$vname} = $nodeid;

		    # And add to the results for the next vtop print.
		    $self->createFixedNode($vname, $nodeid)
			if (!$pnode->isfednode());
		}
	    }
	}

	#
	# Return indicator that we made forward progress (got some nodes).
	# Caller will decide if appropriate to keep trying. We made progress
	# if the return value of nalloc (number of nodes not allocated) does
	# not equal the number of nodes we tried to allocate.
	#
	return (($tcount == $exitval) ? 2 : 3);
    }

    #
    # Lets do a check to see if the shared nodes are still shared. This
    # check is advisory; we will not really know until CreateVnodes()
    # locks the tables, but if the node is not shared now cause the pool
    # daemon released it, we can still recover with another run. 
    #
    my $rerun = 0;
    
    foreach my $physical (sort(keys(%{ $self->solution_virtnodes() }))) {
	my $pnode = Node->Lookup($physical);
	if (!defined($pnode)) {
	    tberror("Could not get object for $physical\n");
	    return -1;
	}
	# Remote node. Not our problem.
	next
	    if ($pnode->isfednode());
	
	$pnode->FlushReserved();
	my $reservation = $pnode->Reservation();
	if (!defined($reservation) ||
	    (! $reservation->SameExperiment($self->experiment()) &&
	     ! $pnode->erole() eq "sharedhost")) {
	    tbinfo("$pnode is not in shared mode.\n");
	    $rerun++;
	}
    }
    return 1
	if ($rerun);

    #
    # Set the node allocstate for unused/dirty nodes.
    #
    foreach my $pnode (values(%{ $self->oldreservednodes() })) {
	if ($pnode->_reuse() eq "unused") {
	    #
	    # Node was used in previous incarnation, but not any more.
	    # Mark it for teardown by the caller (tbswap currently).
	    #
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_TEARDOWN())
		if (! $self->impotent());
	}
	elsif ($pnode->_reuse() eq "reboot") {
	    #
	    # Node is being reused, but for a different purpose, so
	    # it should be rebooted.
	    #
	    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT())
		if (! $self->impotent());
	}
    }
  skip:
    if ($self->AllocVirtNodes() != 0) {
	tberror("Could not allocate virtual nodes\n");
	return -1;
    }

    #
    # Allocate Geni nodes (get tickets). Eventually we want to retry
    # the assignment and replace tickets that we could not get. 
    #
    if (defined($self->genirspec()) &&
	!($self->impotent() || $self->alloconly())) {
	$self->printdb("Requesting geni tickets ...\n");

	my $progress = libGeni::GetTickets($self);
	if ($progress) {
	    tberror("Error allocating (some) Geni Tickets\n");
	    #
	    # Need to find out what geni nodes we could not get tickets for.
	    # The local proxy nodes for them need to be released, and if we
	    # made forward progress, we try again in another loop through.
	    # The rest of the solution state will get cleared before
	    # the next loop, but calling nfree is easiest here. 
	    #
	    my @tofree = ();
	    
	    foreach my $pnode (@reserved) {
		my $nodeid = $pnode->node_id();

		#
		# XXX See libGeni; it sets external_resource_index if the
		# if we get a ticket. Need a state variable instead. 
		#
		if (exists($self->solution()->{'TORESERVE'}->{$nodeid}) &&
		    !defined($pnode->external_resource_index())) {
		    push(@tofree, $nodeid);
		}
	    }
	    if (@tofree) {
		tbinfo("Releasing unticketed nodes: @tofree\n");
		system("$NFREE $pid $eid @tofree");
		if ($?) {
		    tberror("Could not free unticketed nodes\n");
		    return -1;
		}
		foreach my $nodeid (@tofree) {
		    delete($self->newreserved()->{$nodeid});
		}
	    }
	    return $progress;
	}
	tbinfo("Successfully got all geni tickets we needed.\n");
	
	#
	# Redeem the tickets.
	#
	$self->printdb("Redeeming geni tickets ...\n");
	    
	if (libGeni::RedeemTickets($self->experiment(), $self->user())) {
	    tberror("Could not redeem Geni Tickets\n");
	    #
	    # Release outstanding tickets now since we are hosed. 
	    #
	    if (libGeni::ReleaseTickets($self->experiment(), $self->user())) {
		tberror("Could not release Geni Tickets\n");
	    }
	    return -1;
	}
	tbinfo("Successfully redeemed all geni tickets.\n");
    }

    #
    # Update the pnodes() array with the newly allocated nodes.
    #
    foreach my $physical (keys(%{ $self->solution_p2v() })) {
	my @vlist = @{ $self->solution_p2v()->{$physical} };

	my $pnode = Node->Lookup($physical);
	if (!defined($pnode)) {
	    tberror("Could not get object for $physical\n");
	    return -1;
	}
	$self->pnodes()->{$physical} = $pnode;

	# Node might need the link delay kernel.
	$pnode->_needslinkdelay(0);
	# ipfw pipe numbers.
	$pnode->_pipenumber(110);
	# Routing table id for each vnode on a pnode. Do not use 0.
	$pnode->_rtabid(1);
	# For assigning dynamic ports.
	$pnode->_portarray(undef);
	$pnode->_portlow(TBDB_LOWVPORT);
	$pnode->_portnext(TBDB_LOWVPORT);
	$pnode->_porthigh(TBDB_MAXVPORT);
	# To avoid unitialized access.
	$pnode->_reuse("used");
	
	#
	# The node might not have a reservation entry if in
	# impotent mode. But if the node is shared, it *will*
	# so if there is no erole, we know the node is not shared.
	#
	$pnode->_sharedhost((defined($pnode->erole()) &&
			     $pnode->erole() eq "sharedhost") ? 1 : 0);
	
	#
	# Typically, its one-to-one, unless its a physnode hosting
	# virtnodes, in which case the mapping is one-to-many.
	#
	foreach my $virtual (@vlist) {
	    #
	    # Nodes that we create in assign_wrapper, like delays
	    # nodes (tbdelayXX) and jail hosts (vhost-XX) do not have
	    # entries in the virt_nodes table. Should we form one, so
	    # that we can refer to all nodes consistently?
	    #
	    next
		if (!exists($self->vnodes()->{$virtual}));

	    my $virtnode = $self->vnodes()->{$virtual};
	    
	    if ($virtnode->_isvirtnode()) {
		#
		# The physical node is the virtual node on the physical.
		#
		my $vpnode = Node->Lookup($self->solution_v2v()->{$virtual});
		if (!defined($vpnode)) {
		    tberror("Could not get object for $physical\n");
		    return -1;
		}
		$self->pnodes()->{$vpnode->node_id()} = $vpnode;
		$virtnode->_onsharednode($pnode->_sharedhost());
		$virtnode->_pnode($vpnode);

		#
		# Minor post processing; Whenever a shared node is
		# selected by assign, must reset the encap style of
		# the lans it is a memberof, to vlan encap.
		#
		if ($virtnode->_onsharednode()) {
		    foreach my $virtlan ($virtnode->memberlist()) {
			$virtlan->_encapstyle("vlan");
		    }
		}
	    }
	    else {
		# Default this for physnodes.
		$virtnode->_onsharednode(0);
		$virtnode->_pnode($pnode);
	    }
	}
    }
    $self->SetPortRange() == 0
	or return -1;
    
    #
    # Set the sshd ports. Its complicated by the fact that a single
    # experiment could have multiple jailed nodes on the same physical
    # node, and so a per-experiment wide sshd port is not going to
    # work unless there happens to be just one jail per node, but
    # thats not likely in the local area case.
    #
    foreach my $vnodename (sort(keys(%{ $self->solution_v2v() }))) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};
	my $vpnode     = $self->pnodes()->{$vpnodename};
	my $virtnode   = $self->vnodes()->{$vnodename};
	
	if ($vpnode->isjailed() ||
	    $vpnode->isremotenode() || $virtnode->_onsharednode()) {
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $pnode     = $self->pnodes()->{$pnodename};
	    my $sshdport;

	    #
	    # XXX What an absurd DB default for this! Should be null.
	    #
	    if (exists($self->current_v2v()->{$vnodename}) &&
		$vpnode->sshdport() != 11000) {
		
		$sshdport = $vpnode->sshdport();
		$self->printdb("sshdport: Reusing $sshdport on $vpnode\n");
	    }
	    else {
		$sshdport = nextipportnum($pnode);
		return -1
		    if ($sshdport < 0);

		$self->printdb("sshdport: Using $sshdport on $vpnode\n");
	    }

	    DBQueryWarn("update nodes set sshdport=$sshdport ".
			"where node_id='$vpnodename'")
		or return -1 if (! ($self->impotent() || $self->alloconly()));
	}
    }

    #
    # Must post pass the trafgens list to make sure no ip port collisions.
    #
    foreach my $virt_trafgen ($self->virt_trafgens()->Rows()) {
	my $vnodename = $virt_trafgen->vnode();
	my $pnodename = $self->solution_v2p()->{$vnodename};
	my $pnode     = $self->pnodes()->{$pnodename};
	my $ipport    = nextipportnum($pnode);

	my $trafname         = $virt_trafgen->vname();
	my $target_vnodename = $virt_trafgen->target_vnode();
	my $target_trafname  = $virt_trafgen->target_vname();

	$self->printdb("Setting $virt_trafgen port to $ipport\n");

	if (! ($self->impotent() || $self->alloconly())) {
	    DBQueryWarn("update virt_trafgens set port=$ipport ".
			"where exptidx='$idx' and ".
			"      vnode='$vnodename' and vname='$trafname'")
		or return -1;
	
	    DBQueryWarn("update virt_trafgens set target_port=$ipport ".
			"where exptidx='$idx' and ".
			"      vnode='$target_vnodename' and ".
			"      vname='$target_trafname'")
		or return -1;
	}
    }

    #
    # Upload the v2pmap table. The only place I know that cares about
    # this table is dohosts() in tmcd.c
    #
    foreach my $vnodename (keys(%{ $self->solution_v2p() })) {
	#
	# If a virtual node, the pnode is the virtual node, not the
	# underlying physical node.
	#
	my $pnodename = (exists($self->solution_v2v()->{$vnodename}) ?
			 $self->solution_v2v()->{$vnodename} :
			 $self->solution_v2p()->{$vnodename});

	$self->printdb("v2pmap: $vnodename $pnodename\n");

	DBQueryWarn("insert into v2pmap set ".
		    "  pid='$pid', eid='$eid', exptidx='$idx', ".
		    "  vname='$vnodename', node_id='$pnodename'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }
    
    return 0;
}

# Allocate virtnodes. This is a little hokey in that the virtnodes
# just need to be allocated from the pool that is on the real node. We
# know they are free, but we should go through nalloc anyway. If
# anything fails, no point in retry.
#
sub AllocVirtNodes($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    foreach my $physical (sort(keys(%{ $self->solution_virtnodes() }))) {
	my @vlist = sort(@{ $self->solution_virtnodes()->{$physical} });
	my $numvs = @vlist;
	my @plist = ();
	my @oplist = ();
	my @ovlist = ();
	my @delvlist = ();

	$self->printdb("On pnode $physical: vnodes @vlist\n");

	#
	# If updating, need to watch for nodes that are already reserved.
	# We save that info in oplist/ovlist, and build a new vlist for
	# avail, of just the nodes we need in this run. 
	#
	if ($self->updating()) {
	    my @oldvlist = ();
	    if (exists($self->current_p2v()->{$physical})) {
		@oldvlist = @{ $self->current_p2v()->{$physical} };
	    } 
	    $self->printdb("On pnode $physical: oldvlist: @oldvlist\n");

	    # newvlist = elements in vlist but not in oldvlist
	    #            i.e. newly mapped to this pnode
	    my @newvlist = array_diff( \@vlist, \@oldvlist );
	    $self->printdb("On pnode $physical: newvlist: @newvlist\n");

	    # curvlist = elements in both vlist and oldvlist
	    #            i.e. vnodes mapped the same way from previous
	    #            to current
	    # This is the same as @vlist intersection @oldvlist
	    # since the lists have no duplicates
	    my @curvlist = array_diff( \@vlist, \@newvlist );
	    $self->printdb("On pnode $physical: curvlist: @curvlist\n");

	    foreach my $virtual (@curvlist) {
		if (exists($self->current_v2v()->{$virtual}) ) {
		    push(@oplist, $self->current_v2v()->{$virtual});
		    push(@ovlist, $virtual);
		}
	    }

	    # delvlist = elements in oldvlist not in vlist
	    #            i.e. vnodes that moved to another pnode or
	    #            went away
	    @delvlist = array_diff( \@oldvlist, \@vlist );
	    $self->printdb("On pnode $physical: delvlist: @delvlist\n");

	    while (scalar(@newvlist) && scalar(@delvlist)) {
		my $del_vnode = pop(@delvlist);
		if (exists($self->current_v2v->{$del_vnode})) {
		    my $reserved_node = $$self->current_v2v()->{$del_vnode};
		    push(@oplist, $reserved_node);
		    my $new_vnode = pop(@newvlist);
		    push(@ovlist, $new_vnode);
		}
	    }
	
	    # These are the new nodes we need to allocate
	    @vlist = @newvlist;
	    $numvs = scalar(@vlist);

	    if (@oplist) {
		$self->printdb("Reusing vnodes @oplist\n"); 
	    }
	}

	#
	# Still need to allocate some virtnodes?
	#
	if ($numvs) {
	    #
	    # All vnodes on pnode are dynamic if the first one is.
	    # We also assume that we do not mix vnode types on a pnode; bad.
	    #
	    my $virtnode = $self->vnodes()->{$vlist[0]};
	    
	    if ($virtnode->_isdynamic()) {
		# Always use the base type ... node type system sucks.
		my $basetype = $virtnode->_typeinfo()->type();

		#
		# We might be expecting to allocate a shared vnode on
		# a shared host. We cannot be sure until CreateVnodes
		# does the table locking, and so it might actually
		# fail (CreateVnodes will make sure).  At this time I
		# am not going to worry about rerunning the
		# assignment; we will fail with a temp resource
		# shortage and let the user try again.
		#
		my $sharedokay = $virtnode->_sharedokay();
		
		#
		# Call into library. Be sure to pass impotent mode along.
		#
		if (Node->CreateVnodes(\@plist,
				       {"pid"      => "$pid",
					"eid"      => "$eid",
					"count"    => $numvs,
					"vtype"    => $basetype,
					"nodeid"   => $physical,
					"debug"    => 0,
					"verbose"  => $self->verbose(),
					"impotent" => $self->impotent(),
					"sharedokay" => $sharedokay,
					"regression" => $self->regression()})
		    < 0) {
		    tberror("Could not allocate vnodes on $physical\n");
		    return -1;
		}
	    }
	    else {
		#
		# Run avail to get the list of virtnodes on the phys node. We
		# already know there are enough, since assign knows that.
		#
		$self->printdb("Asking avail for $numvs for vnodes: ".
			       "@vlist on $physical\n");
		if (! open(AVAIL, "$AVAIL ".
			   "virtonly=$physical rand limit=$numvs|")) {
		    tberror("Could not start avail\n");
		    return -1;
		}
		while (<AVAIL>) {
		    next
			if (! /^\|/);
		    next
			if (/node_id/);

		    if ($_ =~ /^\|([-a-zA-Z0-9]+)\s*\|(\w+)\s*\|(\w+)\s*\|$/) {
			push(@plist, $1);
		    }
		    else {
			tberror("Bad line from avail: $_\n");
			return -1;
		    }
		}
		close(AVAIL);

		# Sanity check.
		if (scalar(@vlist) != scalar(@plist)) {
		    $self->printdb("avail gave " . scalar(@plist) .
				   " vnodes: @plist on $physical\n");
		    tberror("Could not map some virtual nodes on $physical\n");
		    return -1;
		}

		#
		# Try to allocate. Note, if this fails we are done
		# for. Okay for now since it is never the case that it
		# should fail!
		#
		if ($self->impotent() || $self->alloconly()) {
		    tbinfo("Selected for $physical: @plist\n");
		    tbinfo("Skipping physical reservation, as directed.\n");
		}
		else {
		    tbinfo("Reserving on $physical: @plist ...\n");
		    system("$NALLOC $pid $eid @plist");
		    if ($?) {
			tberror("Failed to reserve @plist (on $physical)\n");
			return -1;
		    }
		}
	    }
	}

	if ($self->updating()) {
	    #
	    # Append the lists we created above, so that we get all of them
	    # in the loop below.
	    #
	    @plist = (@plist, @oplist);
	    @vlist = (@vlist, @ovlist);
	}
    
	while (@plist) {
	    my $virtphys = pop(@plist);
	    my $virtual  = pop(@vlist);
	    my $pnode    = Node->Lookup($virtphys);
	    if (!defined($pnode)) {
		tberror("Could not get node object for $virtphys\n");
		return -1;
	    }

	    $self->solution_v2v()->{$virtual} = $virtphys;
	    $self->printdb("  Mapping $virtual to $virtphys on $physical\n");

	    #
	    # New virtual nodes are always clean. Old ones stay in whatever
	    # state they were in so that os_setup/vnode_setup know they
	    # need to reboot them.
	    #
	    if (! $self->impotent()) {
		if (!exists($self->current_v2v()->{$virtual})) {
		    $self->newreserved()->{$virtphys} = $virtphys;
		    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_INIT_CLEAN());
		}
		elsif ($self->current_v2v()->{$virtual} ne $virtphys) {
		    # Node has moved.
		    $pnode->SetAllocState(TBDB_ALLOCSTATE_RES_REBOOT());
		}
	    }
	    #
	    # Set the vname for the reserved node right away. Needed in
	    # the libGeni::GetTickets() to find the pnode.
	    #
	    $pnode->ModifyReservation({"vname" => $virtual}) == 0
		or return -1 if (!$self->impotent());
	}

	# Since we have some extra physical vnodes reserved on this pnode,
	# we will let tbswap tear them down.
	while (@delvlist) {
	    my $del_vnode = pop(@delvlist);

	    if (exists($self->current_v2v()->{$del_vnode})) {
		my $pname = $self->current_v2v()->{$del_vnode};
		my $pnode = $self->pnodes()->{$pname};

		$pnode->SetAllocState(TBDB_ALLOCSTATE_RES_TEARDOWN())
		    if (!$self->impotent() &&
			$pnode->allocstate() ne
			TBDB_ALLOCSTATE_RES_INIT_CLEAN());
	    }		
	}
    }

    return 0;
}

#
# Now interpret the plinks. This comes out of assign_wrapper, no way
# I would try to mess with it, not yet.
#
sub InterpLinks($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    $self->printdb("Interpreting link/lan results from assign\n");

    #
    # MLE: Add the links that are implemented by others.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vpath = $virtlan->_implemented_by();

	next
	    if (!defined($vpath));

	my $vlink = $self->vlinks()->{"$virtlan"};
	my ($member0,$member1) = $virtlan->memberlist();
	my $firstmember = $vpath->firstmember();
	my $lastmember  = $vpath->lastmember();

	$self->printdb("Adding link $virtlan, implemented by $vpath\n");

	$self->AddLinkToSolution($vlink, 0, 0,
				 $firstmember->_pnode(),
				 $firstmember->_pport(),
				 $lastmember->_pnode(),
				 $lastmember->_pport());
    }
    return -1
	if ($self->InterpLinksAux() != 0);

    #
    # Go through and look for bridge nodes. 
    #
    foreach my $bridgename (keys(%{ $self->bridges() })) {
	my @members = values(%{ $self->bridges()->{$bridgename} });

	# Can only bridge two links.
	my ($member0,$member1) = @members;

	$self->AddBridge($bridgename, $member0, $member1);
    }

    #
    # Locally shared nodes.
    #
    # This should go elsewhere ...
    #
    my @sharedpnodes = ();

    foreach my $virtual (keys(%{ $self->solution_v2p() })) {
	my $pnode = $self->pnodes()->{$self->solution_v2p()->{$virtual}};
	my $virtnode = $self->vnodes()->{$virtual};

	# internally created node ...
	next
	    if (!defined($virtnode));
	next
	    if ($pnode->_reuse() eq "unused");
	next
	    if ($pnode->isvirtnode());

	if (defined($virtnode->sharing_mode()) &&
	    $virtnode->sharing_mode() eq "shared_local") {
	    push(@sharedpnodes, $pnode);
	}
    }
    if (@sharedpnodes > 1) {
	my $protovlan = ProtoLan->Create($experiment, "sharedlan",
					 $self->impotent() ||
					 $self->alloconly());
					 
	$protovlan->SetRole("encapsulation");
	$protovlan->SetType("vlan");
	$protovlan->SetAttribute("link/lan", "sharedlan");
	$protovlan->SetEncapStyle("default");
	# Total hack ... see snmpit.
	$protovlan->SetAttribute("trunk_mode", "dual");
	
	foreach my $pnode (@sharedpnodes) {
	    my $pnodename = $pnode->node_id();
	    my @interfaces;
	    if ($pnode->AllInterfaces(\@interfaces)) {
		tberror("Could not get interface list for $pnode\n");
		return -1;
	    }
	    foreach my $interface (@interfaces) {
		my $iface   = $interface->iface();
		my $type    = $interface->type();
		my $wiredup = $interface->wiredup();

		next
		    if ($interface->role() ne TBDB_IFACEROLE_EXPERIMENT() ||
			!$wiredup);

		#
		# Gack. We need to make sure that we are connected to an
		# ethernet switch, not something like an apcon or another
		# node. Use the Port library for this.
		#
		my $port = Port->GetOtherEndByIface($pnodename, $iface);
		if (!defined($port)) {
		    tberror("Could not get Port other end for $interface\n");
		    return -1;
		}
		next
		    if (! $port->is_switch_side());
		my $switchname = $port->node_id();
		my $switch = Node->Lookup($switchname);
		if (!defined($switch)) {
		    tberror("Could not lookup node object for $switchname\n");
		    return -1;
		}
		my $forwarding_protocols;
		if ($switch->NodeTypeAttribute("forwarding_protocols",
					       \$forwarding_protocols) ||
		    !defined($forwarding_protocols) ||
		    $forwarding_protocols eq "") {
		    tberror("No forwarding_protocols set for $switch\n");
		    return -1;
		}
		next
		    if ($forwarding_protocols ne "ethernet");

		my $speed = $self->interfacespeedmbps($type, "ethernet");
		DBQueryWarn("update interfaces set " .
			    "   current_speed='$speed',trunk=1 " .
			    "where node_id='$pnodename' and iface='$iface'")
		    or return -1 if (!($self->impotent() ||
				       $self->alloconly()));

		# Use attributes in the future, instead of above query.
		my $mem =
		    $protovlan->AddMember($pnodename, $iface,
					  {"trunk_mode"    => "dual",
					   "current_speed" => $speed});
		
		#
		# Do not do this for nodes already in the shared experiment.
		# It would reset the in-use bandwidth. Bad.
		#
		if (!exists($self->current_p2v()->{$pnodename})) {
		    # Must convert this to kbps like everything else is.
		    $speed = $speed * 1000;
		
		    DBQueryWarn("update interface_state set " .
				"   remaining_bandwidth='$speed' " .
				"where node_id='$pnodename' and ".
				"      iface='$iface'")
			or return -1 if (!($self->impotent() ||
					   $self->alloconly()));
		}
	    }
	}
    }

    #
    # Check the portbw to make sure they are all set; if the user is
    # letting assign pick the interfaces (zero bandwidth), then portbw
    # is still zero, and it needs to be set to the default speed for
    # that interface.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));

	    # XXX NSE checks I do not understand.
	    next
		if (! (exists($self->portbw()->{$member}) &&
		       exists($self->solution_v2p()->{$member->vnode()})));

	    # Skip anything that is implemented by a path; speed set elsewhere.
	    next
		if (defined($virtlan->_implemented_by()));

	    # Skip anything that was turned into a vinterface; the
	    # port speed will get set elsewhere.
	    next
		if (exists($self->solution_vifacemap()->{$member}));

	    my $iface     = $self->solution_portmap()->{$member};
	    my $pnodename = $self->solution_v2p()->{$member->vnode()};
	    my $speed     = $self->portbw()->{$member};

	    # Already set.
	    next
		if ($speed);

	    my $interface = Interface->LookupByIface($pnodename, $iface);
	    if (!defined($interface)) {
		tberror("Could not lookup interface $pnodename:$iface\n");
		return -1;
	    }
	    $speed =
		$self->interfacespeedmbps($interface->type(), "ethernet");

	    # portbw() is in bps.
	    $self->portbw()->{$member} = $speed * 1000;

	    $self->printdb("Setting portbw: $pnodename:$iface $speed\n");
	}
    }

    # Write the vlans to the DB.
    $self->UploadVlans() == 0
	or return -1;
    $self->UpLoadIPAddresses() == 0
	or return -1;
    $self->UpLoadTunnels() == 0
	or return -1;
    $self->UpLoadInterfaceSettings() == 0
	or return -1;

    return 0;
}

sub InterpLinksAux($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();

    my $vlanid     = 0;
    my %portmap    = %{ $self->solution_portmap() };
    my %protovlans = ();

    my %plinks = %{ $self->solution_plinks() };
    my @plinks = sort(keys(%plinks));

    while (@plinks) {
	my $plink = shift(@plinks);
	
	my ($linktag,$virtlan,$trivial,$direct,$member0,$member1,$pathA) =
	    @{$plinks{$plink}};
	my $lan = $virtlan->vname();

	#
	# trivial links do not have physical links, so no delay
	# nodes. But, we *do* use trivial links for intranode links,
	# and thus there could be link delays (ie: two jailed nodes on
	# a link/lan assigned to the same phys node).
	#
	if ($trivial) {
	    $self->printdb("plink $plink - trivial\n");
	}
	else {
	    $self->printdb("plink $plink\n");
	}
	$self->printdb("  path - $pathA\n")
	    if (defined($pathA));

	# There is always a member0.
	my $virtA  = $member0;
	my $vnodeA = $member0->vnode();
	my $vportA = $member0->vport();
	my ($nodeA,$portA) = undef;
	# But it might be trivial, so no portinfo.
	if (!$trivial) {
	    $nodeA  = $member0->_pnode();
	    $portA  = $member0->_pport();
	}
	my $virtnodeA = $self->vnodes()->{$vnodeA};

	if ($linktag eq "linksdelaysrc") {
	    # trivial links do not have physical links, so no delay nodes.
	    next
		if ($trivial);

	    # The other node in the link that correspond to the topology.
	    my $virtC  = $member1;
	    my $nodeC  = $member1->_pnode();
	    my $portC  = $member1->_pport();
	    my $vnodeC = $member1->vnode();
	    my $vportC = $member1->vport();
	    # The delay node port/links
	    my $nodeB = $member0->_delaynode();
	    my $portB = $member0->_delayport();
	    my $nodeD = $member1->_delaynode();
	    my $portD = $member1->_delayport();
	    my $pathB = $member0->_delaypath();

	    $self->printdb("LINK delay: $virtA,$virtC - ".
			   "$nodeA:$portA,$nodeB:$portB,".
			   "$nodeD:$portD,$nodeC:$portC\n");
	    $self->printdb(" path - $pathB\n")
		if (defined($pathB));

	    my $protolan    = ProtoLan->Create($experiment, "$lan",
					       $self->impotent() ||
					       $self->alloconly());
	    my $protolansrc = ProtoLan->Create($experiment,
					       "$lan" . "-delaysrc",
					       $self->impotent() ||
					       $self->alloconly(),
					       $protolan);
	    my $protolandst = ProtoLan->Create($experiment,
					       "$lan" . "-delaydst",
					       $self->impotent() ||
					       $self->alloconly(),
					       $protolan);
	    $protolansrc->SetType("vlan");
	    $protolandst->SetType("vlan");
	    $protolansrc->SetRole("delay");
	    $protolandst->SetRole("delay");
	    $protolansrc->SetAttribute("link/lan", $lan);
	    $protolandst->SetAttribute("link/lan", $lan);
	    $protolansrc->SetAttribute("switchpath", "$pathA")
		if (defined($pathA));
	    $protolandst->SetAttribute("switchpath", "$pathB")
		if (defined($pathB));
	    $protolan->SetRole("link/lan");
	    $protolan->AddInterface($nodeC, $vnodeC, $vportC, $portC);
	    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
	    $protolansrc->AddMember($nodeA, $portA);
	    $protolansrc->AddMember($nodeB, $portB);
	    $protolandst->AddMember($nodeC, $portC);
	    $protolandst->AddMember($nodeD, $portD);
	
	    $self->AddDelay($virtlan, $member0, $member1,
			    $nodeB,$portB,$portD,0,
			    $self->delaylinks()->{$plink});
	    
	    #
	    # Setup portmap using virt members in plink name.
	    #
	    $portmap{$virtA} = $portA;
	    $portmap{$virtC} = $portC;

	    #
	    # Set up tracing across the delay node (both directions).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeB, $portB, $portD);
	    $self->SetUpTracing($virtlan, $member1, $nodeB, $portD, $portB);
	}
	elsif ($linktag eq "linkdelaysrc") {
	    # trivial links do not have physical links, so no delay nodes.
	    next
		if ($trivial);

	    # The delay node port/links
	    my $nodeB = $member0->_delaynode();
	    my $portB = $member0->_delayport();
	    my $pathB = $member0->_delaypath();
	    my $nodeD = $nodeB;
	    my $portD = $member0->_delayportB();

	    $self->printdb("LAN delay: $virtA - ".
			   "$nodeA:$portA,$nodeB:$portB,$nodeD:$portD\n");

	    #
	    # Construct a name for the delay link. This has to be unique
	    # since now (with virtual nodes) we can have multiple vnodes
	    # from the same lan, on the same pnode, without using veths.
	    # Multiple routing tables made this possible.
	    #
	    my $dlink = $lan . "/dlink/$vnodeA";

	    my $protolan = ProtoLan->Lookup($experiment, $lan);
	    if (!defined($protolan)) {
		$protolan = ProtoLan->Create($experiment, "$lan",
					     $self->impotent() ||
					     $self->alloconly());
		$protolan->SetRole("link/lan");
	    }
	    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);

	    my $protolanlan = ProtoLan->Lookup($experiment,
					       $lan . "-delaylan");
	    if (!defined($protolanlan)) {
		$protolanlan = ProtoLan->Create($experiment,
						$lan . "-delaylan",
						$self->impotent() ||
						$self->alloconly(),
						$protolan);
		$protolanlan->SetType("vlan");
		$protolanlan->SetRole("delay");
		$protolanlan->SetAttribute("link/lan", $lan);
	    }
	    $protolanlan->AddMember($nodeD, $portD);
	    if (defined($pathB)) {
		my $path = $protolanlan->GetAttribute("switchpath");
		$protolanlan->SetAttribute("switchpath",
					   AddToSwitchPath($path, $pathB));
	    }
	    my $protolanlink = ProtoLan->Create($experiment, $dlink,
						$self->impotent(),
						$protolan);
	    $protolanlink->SetType("vlan");
	    $protolanlink->SetRole("delay");
	    $protolanlink->SetAttribute("link/lan", $lan);
	    $protolanlink->SetAttribute("switchpath", "$pathA")
		if (defined($pathA));
	    $protolanlink->AddMember($nodeA, $portA);
	    $protolanlink->AddMember($nodeB, $portB);

	    $self->AddDelay($virtlan, $member0, $member0,
			    $nodeB,$portB,$portD,1,
			    $self->delaylinks()->{$plink});
	    
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;

	    #
	    # Set up tracing across the delay node (one direction
	    # cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeB, $portB, $portD);
	}
	elsif ($linktag eq "linksimple") {
	    # The other node in the link that correspond to the topology.
	    my $virtB  = $member1;
	    my $vnodeB = $member1->vnode();
	    my $vportB = $member1->vport();
	    my ($nodeB,$portB) = undef;
	    my $protolink;
	    my $virtnodeB = $self->vnodes()->{$vnodeB};

	    #
	    # If the link is delayed, its with endpoint delays, not a
	    # delay node.
	    #
	    # trivial links do not have physical links, but could be using
	    # virtual interfaces on the same node. 
	    #
	    #
	    if (! $trivial) {
		$nodeB  = $member1->_pnode();
		$portB  = $member1->_pport();

		$self->printdb("LINK simple: $virtA,$virtB - ".
			       "$nodeA:$portA,$nodeB:$portB\n");

		if ($virtlan->_layer() == 1) {
		    #
		    # A layer one link is a "wire" between two interfaces
		    # attached to a layer one switch; snmpit deals with
		    # wires by creating the links on the layer one switch.
		    #
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    $protovlans{$lan} = $protolink;
		    $protolink->SetType("wire");
		    $protolink->SetRole("link");
		    $protolink->AddInterface($nodeA, $vnodeA,
					     $vportA, $portA);
		    $protolink->AddInterface($nodeB, $vnodeB,
					     $vportB, $portB);

		    #
		    # The layer one link when it is in existence, is just like
		    # a wire between the end points. But of course the wire
		    # is dynamic, only in existence because the layer one
		    # switch hooks them up to each other. While this
		    # connection is in existence, we want to create a
		    # "logical" wire so that the link at the next layer up
		    # sees that wire (as for snmpit).
		    #
		    my $logicalwire =
			Interface::LogicalWire->Create($self->impotent(),
						       $nodeA, $portA,
						       $nodeB, $portB);
		    return -1
			if (!defined($logicalwire));

		    $self->printdb("Created $logicalwire for $virtlan\n");

		    #
		    # Stash this into segment so we can find it later, as when
		    # doing the link at the next layer up.
		    #
		    $virtlan->_logicalwire($logicalwire);

		    #
		    # And stash into the lan entry for snmpit later, which will
		    # need to find the wire so it can mark it as active once
		    # the layer 1 link is created.
		    #
		    $protolink->SetAttribute("logicalwireid",
					     $logicalwire->WireID());
		    
		    next;
		}
		elsif ($virtlan->_layer() == 2 && $virtlan->_vpath()) {
		    #
		    # A layer two path. We know we want to put the
		    # ports into trunk mode, but we might not know the
		    # vlan(s) yet since the link(s) running over this
		    # path might not have been created.
		    #
		    # Note that the current implementation of a layer
		    # two path is a set of nodes, with each interior
		    # node in the path acting as a bridge. All of the
		    # ports along the way are added to the vlan that
		    # was created for the link. 
		    #
		    # Look at the list of all the links this path
		    # implements. If not all of them have been
		    # processed then push this back on the vlinks list
		    # to be processed later.
		    #
		    my $vpath = $virtlan->_vpath();
		    
		    foreach my $implements (values(%{$vpath->implements()})) {
			if (!exists($protovlans{$implements->vname()})) {
			    push(@plinks, $plink);
			    goto loop;
			}
		    }
		    #
		    # Okay, all of the vlans implemented by this path
		    # (segment) have been created. Put the ports of this
		    # segment into the those vlans, and make sure the
		    # ports are marked for trunking. 
		    #
		    foreach my $implements (values(%{$vpath->implements()})) {
			my $protovlan = $protovlans{$implements->vname()};

			$protovlan->AddMember($nodeA, $portA,
					      {"trunk_mode" => "equal"})
			    if (! $protovlan->IsMember($nodeA, $portA));

			$protovlan->AddMember($nodeB, $portB,
					      {"trunk_mode" => "equal"})
			    if (! $protovlan->IsMember($nodeB, $portB));

			$self->printdb("Path Segment: $vpath:$implements\n");
		    }
		    next;
		}
		#
		# Special handing for layer two links implemented by a path.
		#
		if ($virtlan->_implemented_by()) {
		    #
		    # Make sure the underlying links have been processed.
		    # Push back on the list if not.
		    #
		    my $vpath = $virtlan->_implemented_by();
		    my @links = $vpath->virtlanlist();

		    foreach my $link (@links) {
			if (!exists($protovlans{$link->vname()})) {
			    push(@plinks, $plink);
			    goto loop;
			}
		    }
		    #
		    # Find the first and last links (the segments) of the path.
		    # The logical wires created by those segments are the wires
		    # we want to use below.
		    #
		    # XXX Not sure this makes sense if the path has more then
		    # 2 segments in it.
		    #
		    my $firstlink = shift(@links);
		    my $lastlink  = (@links ? pop(@links) : $firstlink);
		    my $firstwire = $firstlink->_logicalwire();
		    my $lastwire  = $lastlink->_logicalwire();

		    $self->printdb("$virtlan; $firstwire, $lastwire\n");

		    $portA = $firstwire->ifaceA();
		    $portB = $lastwire->ifaceB();
		}
		if ($virtlan->usevirtiface()) {
		    my $protovlan;
		    
		    #
		    # Create some new virtual devices.
		    #
		    my ($virtifaceA, $virtifaceB);

		    if ($member0->usevirtiface()) {
			$virtifaceA = $self->NewVirtIface($virtlan, $member0,
							  $nodeA, $portA);
			return -1
			    if (!defined($virtifaceA));
		    }
		    if ($member1->usevirtiface()) {
			$virtifaceB = $self->NewVirtIface($virtlan, $member1,
							  $nodeB, $portB);
			return -1
			    if (!defined($virtifaceB));
		    }

		    #
		    # We need to reserve the shared bandwidth.
		    #
		    if (exists($self->delaylinks()->{$plink}) ||
			$member0->_reservebw() || $member1->_reservebw()) {
			my ($bandwidth,$rbandwidth) = 0;
			
			if (exists($self->delaylinks()->{$plink})) {
			    (undef,$bandwidth,undef,undef,
			     undef,$rbandwidth,undef) =
				 @{$self->delaylinks()->{$plink}};
			}
			else {
			    $bandwidth  = $member0->_reservebw();
			    $rbandwidth = $member1->_reservebw();
			}

			if (($virtnodeA->_onsharednode() ||
			     $member0->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: $member0,".
					   "$bandwidth,$virtifaceA\n") &&
			    !($self->impotent() || $self->alloconly()) &&
			    $virtifaceA->ReserveSharedBandwidth($bandwidth)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member0,$bandwidth,$virtifaceA\n");
			    return -1;
			}
			if (($virtnodeB->_onsharednode() ||
			     $member1->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: $member1,".
					   "$rbandwidth,$virtifaceB\n") &&
			    !($self->impotent() || $self->alloconly()) && 
			    $virtifaceB->ReserveSharedBandwidth($rbandwidth)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member1,$rbandwidth,$virtifaceB\n");
			    return -1;
			}
		    }

		    #
		    # When using virtual interfaces we need to create a
		    # protolan for the underlying vlan, and then another link
		    # for the endpoints that run over that vlan. Note though
		    # that there might be multiple emulated links running on
		    # on this physical link. Once we have everything created
		    # there is a postpass to merge the vlans into a single
		    # supervlan since a nodeport can be in just a single vlan.
		    # Note that if the encapstype is "vlan" then the previous
		    # is obviously false, since then the ports are going to
		    # be in trunk mode, and the nodeports in multiple vlans.
		    #
		    if ($virtlan->_encapstyle() ne "vlan") {
			my $lanid = "v" . "$lan" . $vlanid++;

			$protovlan = ProtoLan->Create($experiment, $lanid,
						      $self->impotent() ||
						      $self->alloconly());
			$protovlan->SetRole("encapsulation");
			$protovlan->SetType("vlan");
			$protovlan->SetEncapStyle($virtlan->_encapstyle());
			$protovlan->SetAttribute("link/lan", $lan);
			$protovlan->SetAttribute("switchpath", "$pathA")
			    if (defined($pathA));
			$protovlans{$lan} = $protovlan;

			$protovlan->AddMember($nodeA, $portA)
			    if (!$protovlan->IsMember($nodeA, $portA));
			$protovlan->AddMember($nodeB, $portB)
			    if (!$protovlan->IsMember($nodeB, $portB));
		    }
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly(),
						  $protovlan);
		    my $vlan_type;
		    my $vlan_role;

		    if (defined($protovlan)) {
			$vlan_type = "emulated";
			$vlan_role = "link/lan";
		    }
		    else {
			$vlan_type = "vlan";
			$vlan_role = "emulated";
			$protolink->SetAttribute("link/lan", $lan);
			$protolink->SetAttribute("switchpath", "$pathA")
			    if (defined($pathA));
		    }
		    $protolink->SetType($vlan_type);
		    $protolink->SetRole($vlan_role);

		    $protolink->AddInterface($nodeA, $vnodeA, $vportA,
					     (defined($virtifaceA) ?
					      $virtifaceA->viface() : $portA),
					     (defined($protovlan) ?
					      undef : $portA));
 		    $protolink->AddInterface($nodeB, $vnodeB, $vportB,
					     (defined($virtifaceB) ?
					      $virtifaceB->viface() : $portB),
					     (defined($protovlan) ?
					      undef : $portB));
		    # For portmap below
		    $portA = $virtifaceA->viface()
			if (defined($virtifaceA));
		    $portB = $virtifaceB->viface()
			if (defined($virtifaceB));
		}
		else {
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    #
		    # At layer 2, a direct link is a wire between two
		    # interfaces. We want them setup like any layer 2
		    # link.
		    #
		    $protolink->SetType(($direct ? "direct" : "vlan"));
		    $protolink->SetRole("link/lan");
		    $protolink->SetAttribute("link/lan", $lan);
		    $protolink->SetAttribute("switchpath", "$pathA")
			if (defined($pathA));
		    $protolink->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    $protolink->AddInterface($nodeB, $vnodeB, $vportB, $portB);
		    $protovlans{$lan} = $protolink;
		}
		#
		# If this link is implemented by a path, link them up so we
		# encode the ordering in the lans table (for snmpit).
		#
		if ($virtlan->_implemented_by()) {
		    my $vpath = $virtlan->_implemented_by();
		    my @links = $vpath->virtlanlist();

		    # If the proto link has an underlying proto vlan, that is 
		    # the actual dependency.
		    my $protodep = $protolink->link() || $protolink;

		    foreach my $link (@links) {
			$protovlans{$link->vname()}->SetLink($protodep);
		    }
		}
	    }
	    else {
		# If the trivial link has all simulated members, we
		# don't want a veth interface
		if (! $virtlan->_allsim()) {
		    # No phys mapping. We create a veth, but there is
		    # no phys mapping for the port and no underlying
		    # (linked) vlan.
		    $nodeA = $self->solution_v2p()->{$vnodeA};
		    $nodeB = $self->solution_v2p()->{$vnodeB};

		    my $virtifaceA = $self->NewVirtIface($virtlan,
							 $member0, $nodeA);
		    return -1
			if (!defined($virtifaceA));
		    my $virtifaceB = $self->NewVirtIface($virtlan, $member1,
							 $nodeB);
		    return -1
			if (!defined($virtifaceB));
		    
		    $portA = $virtifaceA->viface();
		    $portB = $virtifaceB->viface();

		    $self->printdb("LINK simple (trivial): $virtA,$virtB - ".
				   "$nodeA:$portA,$nodeB:$portB\n");
		    
		    $protolink = ProtoLan->Create($experiment, $lan,
						  $self->impotent() ||
						  $self->alloconly());
		    $protolink->SetType("trivial");
		    $protolink->SetRole("link/lan");
		    $protolink->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    $protolink->AddInterface($nodeB, $vnodeB, $vportB, $portB);
		}
		else {
		    # next plink
		    next;
		}
	    }
	
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;
	    $portmap{$virtB} = $portB;
	
	    if (exists($self->delaylinks()->{$plink})) {
		my ($delay,$bandwidth,$backfill,$loss,
		    $rdelay,$rbandwidth,$rbackfill,$rloss,$trivial_ok) =
			@{$self->delaylinks()->{$plink}};

		if (!$trivial_ok || ($trivial_ok && $trivial)) {
		    #
		    # Two entries, one for each side of the duplex link.
		    #
		    $self->AddLinkDelay($virtlan,$member0,$nodeA,$portA,0,
					[$delay,$bandwidth,$backfill,$loss]);

		    $self->AddLinkDelay($virtlan,$member1,$nodeB,$portB,0,
				       [$rdelay,$rbandwidth,$rbackfill,$rloss]);
		}
	    }
	    #
	    # Set up tracing across the link. There is trace on each end node,
	    # on the output (after the linkdelay above).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	    $self->SetUpTracing($virtlan, $member1, $nodeB, undef, $portB);
	}
	elsif ($linktag eq "linklan") {
	    # A single node in a lan, no delay node.
	    my $protolan;

	    #
	    # trivial links do not have physical links, but could be using
	    # virtual interfaces on the same node. 
	    #
	    if (! $trivial) {
		$self->printdb("LAN node: $virtA - $nodeA:$portA\n");
		
		if ($virtlan->usevirtiface()) {
		    #
		    # Look for the underlying protovlan for this lan. Create
		    # new one otherwise.
		    #
		    my $protovlan;
		    
		    if (1) {
			if (exists($protovlans{$lan})) {
			    $protovlan = $protovlans{$lan};
			}
			else {
			    my $lanid = "v" . "$lan" . $vlanid++;
			    $protovlan = ProtoLan->Create($experiment, $lanid,
							  $self->impotent() ||
							  $self->alloconly());
			    $protovlan->SetRole("encapsulation");
			    $protovlan->SetType("vlan");
			    $protovlan->SetEncapStyle($virtlan->_encapstyle());
			    $protovlan->SetAttribute("link/lan", $lan);
			    $protovlans{$lan} = $protovlan;
			}
			$protovlan->AddMember($nodeA, $portA)
			    if (!$protovlan->IsMember($nodeA, $portA));

			if (defined($pathA)) {
			    my $path = $protovlan->GetAttribute("switchpath");
			    $protovlan->SetAttribute("switchpath",
						AddToSwitchPath($path, $pathA));
			}
		    }
		
		    #
		    # Create new veth device. Watch for a mixed pnode/vnode
		    # lan where the pnode is not using encapsulation.
		    #
		    my $virtiface;
		    if ($member0->usevirtiface()) {
			$virtiface = $self->NewVirtIface($virtlan, $member0,
							 $nodeA, $portA);
			return -1
			    if (!defined($virtiface));

			$portA = $virtiface->viface();
		    }
		    #
		    # We need to reserve the shared bandwidth. 
		    #
		    if (exists($self->delaylinks()->{$plink}) ||
			 $member0->_reservebw()) {
			my ($bandwidth,$rbandwidth) = 0;
			
			if (exists($self->delaylinks()->{$plink})) {
			    (undef,$bandwidth,undef,undef,
			     undef,$rbandwidth,undef) =
				 @{$self->delaylinks()->{$plink}};
			}
			else {
			    $bandwidth = $rbandwidth = $member0->_reservebw();
			}
			my $maxbw = max($bandwidth, $rbandwidth);
			if (($virtnodeA->_onsharednode() ||
			     $member0->_reservebw()) &&
			    $self->printdb("  Reserving shared BW: ".
					   "$member0,$maxbw,$virtiface\n") &&
			    !($self->impotent() || $self->alloconly) && 
			    $virtiface->ReserveSharedBandwidth($maxbw)) {
			    tbinfo("Could not reserve shared bandwidth: ".
				   "$member0,$maxbw,$virtiface\n");
			    return -1;
			}
		    }

		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (defined($protolan)) {
			#
			# Watch for a lan that mixes trivial links and
			# actual vlan encapsulated links. We might
			# have processed a trivial member first, in
			# which case we have to set its link pointer
			# to the protovlan.
			#
			if ($protolan->type() eq "trivial") {
			    $protolan->SetLink($protovlan);
			}
		    }
		    else {
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly(),
						     $protovlan);
		    }
		    $protolan->SetType("emulated");
		    $protolan->SetRole("link/lan");
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		
		    #
		    # If the "lannode" is placed on a node, and that node is
		    # different than the current node, we have to connect the
		    # two in the vlan. Typically, the lannode is placed on a
		    # switch, and this is not an issue. Rob understands this!
		    #
		    if (!$virtnodeA->_onsharednode() &&
			! ($member0->_lannode() ne "null" &&
			   $member0->_lanport() ne "null" &&
			   $member0->_lannode() eq $nodeA &&
			   $member0->_lanport() eq $portA)) {
			$protovlan->AddMember($member0->_lannode(),
					      $member0->_lanport())
			    if (!$protovlan->IsMember($member0->_lannode(),
						      $member0->_lanport()));
			$self->AddVirtPatch($lan,
					    $member0->_lannode(),
					    $member0->_lanport());
		    }
		}
		else {
		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (!defined($protolan)) {
			#
			# XXX Watch for a lan that mixes delayed and
			# non-delayed members. We should create the
			# protolans earlier.
			#
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly());
		    
			if ($virtlan->_delayed()) {
			    my $protolanlan =
				ProtoLan->Create($experiment,
						 $lan . "-delaylan",
						 $self->impotent() ||
						 $self->alloconly(),
						 $protolan);
			    $protolanlan->SetType("vlan");
			    $protolanlan->SetRole("delay");
			    $protolanlan->SetAttribute("link/lan", $lan);
			}
			else {
			    $protolan->SetType("vlan");
			    $protolan->SetAttribute("link/lan", $lan);
			}
			$protolan->SetRole("link/lan");
		    }
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		    if ($virtlan->_delayed()) {
			my $protolanlan =
			    ProtoLan->Lookup($experiment,
					     $lan . "-delaylan");
			$protolanlan->AddMember($nodeA, $portA);
			if (defined($pathA)) {
			    my $path = $protolanlan->GetAttribute("switchpath");
			    $protolanlan->SetAttribute("switchpath",
					       AddToSwitchPath($path, $pathA));
			}
		    }
		    else {
			if (defined($pathA)) {
			    my $path = $protolan->GetAttribute("switchpath");
			    $protolan->SetAttribute("switchpath",
					    AddToSwitchPath($path, $pathA));
			}
		    }
		}
	    }
	    else {
		# If the trivial lan has all simulated members, we
		# don't want a veth interface
		if (! $virtlan->_allsim()) {
		    # No phys mapping. We create a veth, but there is
		    # no phys port.
		    $nodeA = $self->solution_v2p()->{$vnodeA};
		    my $virtiface = $self->NewVirtIface($virtlan, $member0,
							$nodeA);
		    return -1
			if (!defined($virtiface));
		    
		    $portA = $virtiface->viface();

		    $self->printdb("LAN node (trivial): ".
				   "$virtA - $nodeA:$portA\n");

		    $protolan = ProtoLan->Lookup($experiment, $lan);
		    if (!defined($protolan)) {
			$protolan = ProtoLan->Create($experiment, $lan,
						     $self->impotent() ||
						     $self->alloconly());
			$protolan->SetType("trivial");
			$protolan->SetRole("link/lan");
		    }
		    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
		}
		else {
		    # next plink
		    next;
		}
	    }
	    # Setup portmap using virt members in plink name.
	    $portmap{$virtA} = $portA;
	
	    if (exists($self->delaylinks()->{$plink})) {
		my ($delay,$bandwidth,$backfill,$loss,
		    $rdelay,$rbandwidth,$rbackfill,$rloss,$trivonly) =
			@{$self->delaylinks()->{$plink}};

		if (!$trivonly || $trivonly && $trivial) {
		    #
		    # One entry, comprising each side of the link to lan.
		    #
		    $self->AddLinkDelay($virtlan,$member0,$nodeA,$portA,1,
					$self->delaylinks()->{$plink});
		}
	    }
	    #
	    # Set up tracing on the end node (one direction cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	}
	elsif ($linktag eq "fakelan") {
	    #
	    # No trivial links, emulated links, delays, vlans. We do
	    # however need to come up with an ssid?
	    #
	    $self->printdb("FakeLan - $virtA - $nodeA:$portA\n");
	    
	    my $protolan = ProtoLan->Lookup($experiment, $lan);
	    $protolan = ProtoLan->Create($experiment, $lan,
				 $self->impotent() || $self->alloconly())
		if (!defined($protolan));
	    $protolan->SetType("fakelan");
	    $protolan->SetRole("link/lan");
	    $protolan->AddInterface($nodeA, $vnodeA, $vportA, $portA);
	
	    $portmap{$virtA} = $portA;

	    #
	    # Set up tracing on the end node (one direction cause its a lan).
	    #
	    $self->SetUpTracing($virtlan, $member0, $nodeA, undef, $portA);
	}
	elsif ($plink =~ m|^linkdelaydst/([^/]+)/(.+)$| ||
	       $plink =~ m|^linksdelaydst/(.+)/(.+),(.+)$|) {
	    next;
	}
	else {
	    warn("Bad plink: $plink\n");
	}
      loop:
    }
    $self->{'SOLUTION'}->{'PORTMAP'} = \%portmap;

    return 0;
}

#
# Initialize the nodes.
#
sub InitializePhysNodes($)
{
    my ($self) = @_;
    
    #
    # Init each pnode.
    #
    foreach my $pnodename (keys(%{ $self->solution_p2v() })) {
	my $pnode = $self->pnodes()->{$pnodename};
	
	$pnode->FlushReserved();
	my $reservation = $pnode->Reservation();

	#
	# We should never try to initialize a node that is not
	# allocated to the experiment. 
	#
	# This case covers shared nodes as well since the phys node
	# is in a holding experiment.
	#
	if ((!defined($reservation) || 
	     !$self->experiment()->SameExperiment($reservation))) {
	    if (defined($pnode->sharing_mode())) {
		$self->printdb("InitPnode: Skipping shared host $pnodename\n");
		next;
	    }
	    elsif (! ($self->impotent() && 
		      exists($self->solution()->{'TORESERVE'}->{$pnodename}))){
		tbinfo("InitPnode: Skipping $pnodename; reserved elsewhere\n");
		next;
	    }
	}
	
	#
	# Physical nodes can be plain nodes in the topo, delay nodes,
	# internal nodes hosting other things (like virtual nodes),
	# etc. Determine the role the node is going to play, and
	# initialize it based on that role. Note that I am ignoring
	# the simulation code these days since it no longer works and
	# no one understands it.
	#
	# XXX A node cannot play multiple roles. This is unfortunate. 
	#
	my @vnodelist = @{ $self->solution_p2v()->{$pnodename} };
    	my $vnodename;
	my $role      = TBDB_RSRVROLE_NODE;

	if (exists($self->solution_delaynodes()->{$pnodename})) {
	    $role = TBDB_RSRVROLE_DELAYNODE;
	    # Need only one of the virtnodes to complete the initialization
	    $vnodename = $vnodelist[0];
	}
	elsif (exists($self->solution_virtnodes()->{$pnodename})) {
	    $role = TBDB_RSRVROLE_VIRTHOST;
	    #
	    # Since we allow a VM to be "fixed" to a node in the topology, it
	    # is possible that a physnode has two roles; its normal node role
	    # and its role as a virthost. We want to initialize the pnode
	    # for the VIRTHOST role, but using the normal node virtnode, not
	    # one of the VM virtnodes. The only reason for using the VM
	    # virtnode, is when we have to use the VM to figure out what
	    # OS to run on the internally created pnode.
	    #
	    foreach my $vname (@vnodelist) {
		my $virtnode = $self->vnodes()->{$vname};

		# Find the one real node. Icky.
		if (!$virtnode->_isvirtnode()) {
		    $vnodename = $vname;
		    last;
		}
	    }
	    $vnodename = $vnodelist[0]
		if (!defined($vnodename));
	}
	else {
	    $vnodename = $vnodelist[0];
	}
	$self->InitializePhysNode($pnodename, $role, $vnodename) == 0
	    or return -1;
    }

    #
    # Now do each of the virtual physical nodes (pcvmxxx-yyy). These
    # are naturally plain nodes and always one-to-one.
    #
    foreach my $vnodename (keys(%{ $self->solution_v2v() })) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};

	$self->InitializePhysNode($vpnodename, 
				  TBDB_RSRVROLE_NODE, $vnodename) == 0
	    or return -1;
    }
    
    #
    # XXX This is here cause vnames were not set until now. Need to move.
    #
    if (defined($self->genirspec()) &&
	!($self->impotent() || $self->alloconly())){
	if (libGeni::MapNodes($self->experiment(), $self->verbose())) {
	    tberror("Could not map geni nodes to local nodes.\n");
	    return -1;
	}
    }
    return 0;
}

#
# Initialize a physical (or virtual physical) node. A lot of magic
# in this function
#
sub InitializePhysNode($$$)
{
    my ($self, $pnodename, $role, $vnodename) = @_;
    my $pnode = $self->pnodes()->{$pnodename};

    $self->printdb("InitPnode: $pnodename,$vnodename\n");

    # If this is a node in the topology (in the vnodes() array) then
    # there must be a virtual physical node (which might be the same
    # as the pnode if its a plain node, not a VM or subnode).
    my $virtnode;
    my $vpnode;
    if (exists($self->vnodes()->{$vnodename})) {
	$virtnode = $self->vnodes()->{$vnodename};
	$vpnode   = $virtnode->_pnode();
	if (!defined($vpnode)) {
	    tberror("No virtual physical node for $vnodename on $pnodename\n");
	    return -1;
	}
    }
    
    my %nodesets     = ();
    my %rsrvsets     = ();
    my $cmdline_role = "default";
    my $cmdline      = "";
    my $vname;
    my $osid;
    my $routertype;

    if ($role eq TBDB_RSRVROLE_DELAYNODE() ||
	($role eq TBDB_RSRVROLE_VIRTHOST() && $virtnode->_isvirtnode())) {
	#
	# One of our internally created nodes. 
	#
	if ($role eq TBDB_RSRVROLE_DELAYNODE()) {
	    #
	    # A delay node.
	    #
	    $osid = ($self->option("delay_osid") || $pnode->delay_osid());
	    $vname        = $vnodename;
	    $routertype   = TBDB_ROUTERTYPE_NONE;
	    $cmdline_role = "delay";

	    $self->exptstats()->{"delaynodes"} += 1;
	}
	else {
	    #
	    # An internal node hosting VMs.
	    #
	    if (defined($virtnode->_parent_osinfo())) {
		$osid = $virtnode->_parent_osinfo()->osid();
	    }
	    else {
		$osid  = ($self->option("jail_osid") ||
			  $self->nodejailosid($virtnode));
	    }
	    $vname        = $self->newvname($pnodename, "vhost");
	    $routertype   = TBDB_ROUTERTYPE_MANUAL;
	    $cmdline_role = "vnodehost";

	    $self->exptstats()->{"jailnodes"} += 1;
	}
	if (!defined($osid)) {
	    tberror("No OSID is defined for internal node $vname!\n");
	    return -1;
	}
	$cmdline = $self->osidbootcmd($osid, $cmdline_role, $cmdline);
	if (!defined($cmdline)) {
	    tberror("Error determining boot command line for $pnode\n");
	    return -1;
	}
	%nodesets = ("def_boot_cmd_line" => $cmdline,
		     "startstatus"       => 0,
		     "bootstatus"        => 'unknown',
		     # This is no longer used for anything.
		     "deltas"            => '', 
		     "ready"             => 0,
		     "routertype"        => $routertype);

	%rsrvsets = ("vname"             => $vname,
		     "erole"             => $role);

	if (!$self->impotent() && !$self->alloconly() &&
	    $self->experiment()->AddInternalProgramAgent($vname)) {
	    tberror("Error determining boot command line for $pnode\n");
	    return -1;
	}
    }
    else {
	#
	# A normal user node (physical or virtual).
	#
	my ($cmdline,$rpms,$startupcmd,$tarfiles,$loadlist,
	    $failureaction,$routertype) = @{ $virtnode->_settings() };

	$osid = (defined($virtnode->_osinfo()) ?
		 $virtnode->_osinfo()->osid() : $pnode->default_osid());
	my $vname           = $vnodename;
	my $inner_elab_role = $virtnode->inner_elab_role();
	my $plab_role       = $virtnode->plab_role();
	my $sharing_mode;

	if (!$pnode->isvirtnode() &&
	    (!defined($cmdline) || $cmdline eq "")) {
	    # If the user has not overridden the command line, try to
	    # find a default for this OSID. Only test real physical node.
	    if ($role eq TBDB_RSRVROLE_VIRTHOST) {
		$cmdline = $self->osidbootcmd($osid, "vnodehost", "");
	    }
	    elsif ($pnode->_needslinkdelay()) {
		$cmdline = $self->osidbootcmd($osid, "linkdelay", "");
	    }
	    elsif ($virtnode->_isbridge()) {
		$osid = ($self->option("delay_osid") || $pnode->delay_osid());
		$cmdline = $self->osidbootcmd($osid, "delay", "");
		$role = TBDB_RSRVROLE_DELAYNODE();
		$routertype = TBDB_ROUTERTYPE_NONE;
	    }
	    elsif (defined($inner_elab_role) && $inner_elab_role =~ /boss/) {
		$cmdline = $self->osidbootcmd($osid, "linkdelay", "");
	    }
	    if (!defined($cmdline)) {
		tberror("Error determining boot command line for $pnode\n");
		return -1;
	    }
	}
	elsif ($pnode->isvirtnode() || defined($virtnode->sharing_mode())) {
	    # in some situations we don't allow a user-specified command line
	    $cmdline = "";
	}
	if (!$pnode->isvirtnode() &&
	    defined($virtnode->sharing_mode()) &&
	    $virtnode->sharing_mode() eq "shared_local") {
	    $role = "sharedhost";
	    $sharing_mode = "shared_local";
	    $cmdline = $self->osidbootcmd($osid, "vnodehost", "")
		if (!defined($cmdline) || $cmdline eq "");
	}
	#
	# NOTE: We no longer include tarballs and RPMs in this update,
	# because they are now handled by tarfiles_setup
	#
	%nodesets = ("def_boot_cmd_line" => $cmdline,
		     "startstatus"       => 'none',
		     "bootstatus"        => 'unknown',
		     # This is no longer used for anything.
		     "deltas"            => '', 
		     "ready"             => 0,
		     "startupcmd"        => $startupcmd || '',
		     "loadlist"          => $loadlist || '',
		     "failureaction"     => $failureaction,
		     "routertype"        => $routertype);

	%rsrvsets = ("vname"             => $vnodename,
		     "erole"             => $role,
		     "plab_role"         => $plab_role);
	$rsrvsets{"inner_elab_role"} = $inner_elab_role
	    if (defined($inner_elab_role));
	$rsrvsets{"sharing_mode"} = $sharing_mode
	    if (defined($sharing_mode));

    }
    $self->printdb("InitPnode: Storing info for $pnodename,$vnodename\n");

    # Do this in regression mode to avoid timestamp diffs
    if ($self->regression()) {
	$rsrvsets{"rsrv_time"} = 0;
    }
    if ($self->verbose()) {
	my $setstr = join(",",
			  map("$_='" . $nodesets{$_} . "'", keys(%nodesets)));
	$self->printdb("  $setstr\n");
    }
    $pnode->Update(\%nodesets) == 0
	or return -1 if (! ($self->impotent() || $self->alloconly()));

    if ($self->verbose()) {
	my $setstr =
	    join(",", map("$_='" . $rsrvsets{$_} . "'", keys(%rsrvsets)));
	$self->printdb("  $setstr\n");
    }
    $pnode->ModifyReservation(\%rsrvsets) == 0
	or return -1 if (! ($self->impotent() || $self->alloconly()));
    
    #
    # Now call os_select.
    #
    if (defined($osid) && (!$pnode->isremotenode()
			   || $pnode->isdedicatedremote())) {
	# osselect wants an osinfo object.
	my $osinfo = OSinfo->Lookup($osid);
	if (!defined($osinfo)) {
	    tberror("Could not map $osid to osinfo object\n");
	    return -1;
	}
	#
	# Map generic OSID to the specific one.
	#
	if ($osinfo->IsGeneric()) {
	    my $tmp = $osinfo->ResolveNextOSID($self->experiment());
	    if (!defined($tmp)) {
		tberror("Could not resolve specific osid for $osinfo on $pnode!\n");
		return -1;
	    }
	    # If the specific OS is already loaded, go ahead and set to that
	    # so that we do not cause a boot problem on the node.
	    if ($pnode->IsOSLoaded($tmp)) {
		$osinfo = $tmp;
	    }
	}
	
	if ($self->impotent() || $self->alloconly()) {
	    $self->printdb("  pretending to os_select $osinfo\n");
	}
	else {
	    $self->printdb("  os_select $osinfo\n");

	    if ($pnode->OSSelect($osinfo, "def_boot_osid", $self->verbose())) {
		tberror("OSSelect($pnode,$osinfo) failed\n");
		return -1;
	    }
	}
    }
    # Clear this after os_select.
    if ($self->regression()) {
	DBQueryFatal("update nodes set state_timestamp=0, ".
		     "    op_mode_timestamp=0,allocstate_timestamp=0 ".
		     "where node_id='$pnodename'");
    }
    return 0;
}

#
# This is special. Look at the osid of the virtnodes on this pnode and
# map to a suitable osid using the nextosid field. This overloads nextosid
# to some extent ...
#
sub nodejailosid($$)
{
    my ($self, $virtnode) = @_;

    #
    # We know at this point that all vnodes on this pnode want the same
    # osid (at least, the same vhost osid :-)) cause of assign (osid 
    # features/desires). 
    #
    my $osinfo    = $virtnode->_osinfo();
    my $posinfo   = $virtnode->_parent_osinfo();
    my $nextosid;

    $self->printdb("nodejailosid: $virtnode, $osinfo\n");

    if (!defined($posinfo)) {
	return undef
	    if (!defined($osinfo->nextosid()));
	my $newosinfo = $osinfo->ResolveNextOSID($self->experiment());
	return undef
	    if (!defined($newosinfo));
	$nextosid = $newosinfo->osid();
    
	if (defined($nextosid)) {
	    $self->printdb("Mapping VM osinfo $osinfo to ".
			   "$newosinfo on $virtnode\n");
	}
	else {
	    tbwarn("Could not map jail osid to real osid on $virtnode\n");
	}
    }
    else {
	# Don't try resolving nextosid if the vnode is booting a subOS.
	$nextosid = $osinfo->osid();
	$self->printdb("Mapping VM osinfo to subOS $osinfo".
		       " on $virtnode\n");
    }

    return $nextosid;
}

sub osidbootcmd($$$$)
{
    my ($self, $osid, $role, $default) = @_;

    my $osinfo = OSinfo->Lookup($osid);
    if (!defined($osinfo)) {
	tbwarn("No such OSID $osid\n");
	return undef;
    }
    if (defined($osinfo->nextosid())) {
	$osinfo = $osinfo->ResolveNextOSID($self->experiment());
	return undef
	    if (!defined($osinfo));
    }
    return undef
	if ($osinfo->OSBootCmd($role, \$default) != 0);
    return $default;
}

#
# Takes vnode, pnode as arguments
# and determines the correct routing table id
#
sub getrtabid($$$)
{
    my ($self, $pnode, $member) = @_;
    my $rtabid;
    my $vnodename = $member->vnode();
    my $numvnodesonpnode =
	scalar(@{ $self->solution_p2v()->{$pnode->node_id()} });

    if ($numvnodesonpnode > 1 || $pnode->_sharedhost()) {
	if (! exists($self->solution_rtabmap()->{$vnodename})) {
	    if ($pnode->_sharedhost() &&
		!($self->impotent() || $self->alloconly())) {
		$rtabid = $pnode->Nextrtabid();
	    }
	    else {
		$rtabid = $pnode->_rtabid();
		$pnode->_rtabid($rtabid + 1);
	    }
	    $self->solution_rtabmap()->{$vnodename} = $rtabid;
	}
	else {
	    $rtabid = $self->solution_rtabmap()->{$vnodename};
	}
    }
    else {
	$rtabid = $self->solution_rtabmap()->{$vnodename} = 0;
    }
    return $rtabid;
}


sub NewVirtIface($$$$;$)
{
    my ($self, $virtlan, $member, $pnodename, $pport) = @_;

    my $lan       = $virtlan->vname();
    my $pnode     = $self->pnodes()->{$pnodename};
    my $vnodename = $member->vnode();
    my $ip        = $member->ip();
    my $mask      = $member->mask();
    my $encap     = $virtlan->_encapstyle();
    my $isveth    = (($encap eq "veth" || $encap eq "veth-ne") ? 1 : 0);
    my $vllidx    = $virtlan->idx();
    my $rtabid    = $self->getrtabid($pnode, $member);
    my $exptidx   = $self->experiment()->idx();
    my $isvnode   = exists($self->solution_v2v()->{$vnodename});
    my $vvnode;
    my $isvdev;
    my $type;
    my $mac;

    #
    # Special actions for virtnodes (as opposed to just emulated links).
    #
    if ($isvnode) {
	#
	# XXX type should be either veth or vlan
	#
	$type = $encap;
	if (!$isveth && $type ne "vlan") {
	    tbwarn("whacked encap type '$type' for vnode, ".
		   "setting to 'veth' instead\n");
	    $type = "veth";
	    $isveth = 1;
	}
	$isvdev = 1;

	# to the nodes table entry for the virtnode. 
	$vvnode = $self->solution_v2v()->{$vnodename};
    }
    else {
	#
	# For multiplexed links, the default is no encapsulation,
	# aka "alias".
	#
	$type = $encap;
	if ($type eq "default" || $type eq "alias") {
	    $type = "alias";
	    $isvdev = 0;
	}
	else {
	    $isvdev = 1;
	}
    }

    #
    # Make up a MAC address.  For now, just derive it from the assigned
    # IP address.
    #
    if ($ip =~ /^\d+\.\d+\.\d+\.\d+$/) {
	$mac = sprintf "0000%.2x%.2x%.2x%.2x", split(/\./, $ip);
    } else {
	$mac = "000000000000";
    }

    #
    # Create new virtiface in the DB.
    #
    my %argref = ("mac"    => $mac,
		  "IP"     => $ip,
		  "mask"   => $mask,
		  "type"   => $type,
		  "rtabid" => $rtabid,
		  "exptidx" => $exptidx,
		  "virtlanidx" => $vllidx,
	      );
    $argref{"iface"} = $pport
	if (defined($pport));
    $argref{"vnode_id"} = $vvnode
	if (defined($vvnode));

    my $virtiface = ($self->impotent() || $self->alloconly() ?
		     Interface::VInterface->MakeFake($pnodename, \%argref) :
		     Interface::VInterface->Create($pnodename, \%argref));
    if (!defined($virtiface)) {
	return undef;
    }
    $self->printdb("$virtiface: $member, isvdev:$isvdev, isveth:$isveth\n");
    my $newid = $virtiface->unit();

    # Record this vinterface mapping.
    $self->solution_vifacemap()->{$member} = $virtiface;
    $member->_virtiface($virtiface);
    
    #
    # For veth and vlan interfaces, we need to set the characteristics
    # of the underlying physical interface, but only if we actually own
    # the node; it might be on a shared physical node.
    #
    # If the pnode is a shared host, we do not want to do this; the physical
    # interfaces are all set up the right way, do not mess it up. 
    #
    if (defined($pport) && $isvdev &&
	(!$pnode->_sharedhost() || $member->_needtrunk())) {
	my $speed = $self->interfacespeedmbps(physinterfacetype($pnode,$pport),
					      "ethernet");
	my $trunk = ($type eq "vlan" ? 1 : 0);

	$self->printdb("  Setting port speed/trunk for $pnodename: ".
		       "$pport:$speed/$trunk\n");
	
	DBQueryWarn("update interfaces set " .
		     "   current_speed='$speed',trunk=$trunk " .
		     "where node_id='$pnodename' and iface='$pport'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }

    #
    # XXX hackery that only Rob and Leigh understand.
    # A LAN of vnodes split across multiple physical machines may
    # not have the correct physical LAN info coming out of assign
    # and may need to be patched up later.
    #
    if (!defined($pport) && $isvnode) {
	$self->solution_vethmap()->{$lan} = {}
	  if (!exists($self->solution_vethmap()->{$lan}));
	$self->solution_vethmap()->{$lan}->{$pnodename} = []
	  if (!exists($self->solution_vethmap()->{$lan}->{$pnodename}));
	
	push(@{ $self->solution_vethmap()->{$lan}->{$pnodename} }, $newid);
    }
    return $virtiface;
}

sub AddVirtPatch($$$$)
{
    my ($self, $lan, $pnodename, $pport) = @_;

    $self->printdb("Adding Virt Patch: $lan, $pnodename, $pport\n");

    $self->solution_vethpatch()->{$lan} = {}
        if (!exists($self->solution_vethpatch()->{$lan}));
    
    $self->solution_vethpatch()->{$lan}->{$pnodename} = $pport;
}

#
# Add a delay node entry.
#
sub AddDelay($$$$$$$$$)
{
    my ($self, $virtlan, $member0, $member1, $pnodename,
	$iface0, $iface1, $islan, $params) = @_;

    # Delay Info. 
    my ($delay,$bandwidth,$backfill,$lossrate,
	$rdelay,$rbandwidth,$rbackfill,$rlossrate) = @{$params};

    my $pnode =  $self->pnodes()->{$pnodename};

    # ipfw pipe numbers so we can control it remotely.
    my $pipe0 = $pnode->_pipenumber();
    my $pipe1 = $pipe0 + 10;
    $pnode->_pipenumber($pipe1 + 10);

    my $vnodename0 = $member0->vnode();
    my $vnodename1 = $member1->vnode();
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();
    my $nobwshaping = $virtlan->_nobwshaping();

    #
    # We allow users to oversubscribe by letting them turn off the
    # bandwidth shaping. If however, if the link was shaped for some
    # other reason (like a delay), then turn off just the bw shaping
    # part by setting them to 0.  This is special; means no limits in
    # ipfw.
    #
    if ($nobwshaping) {
	$bandwidth = $rbandwidth = 0;
    }

    $self->printdb("  Delay: \[$iface0:$pnodename:$iface1 ".
		   "pipes:$pipe0+$pipe1,".
		   "$delay,$bandwidth,$backfill,$lossrate,".
		   "$rdelay,$rbandwidth,$rbackfill,$rlossrate]\n");
    
    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, towards the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    if (!$islan) {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

	my ($q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm,
	    $q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit,
	    $q1_droptail,$q1_red,$q1_gentle) = @{ $member1->_queueinfo() };

	#
	# See if this delaynode was inserted strictly for tracing/monitoring.
	#
	my $noshaping = (($virtlan->membershaped($member0) ||
			  $virtlan->membershaped($member1)) ? 0 : 1);
    
	DBQueryWarn("insert into delays " .
	     " (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1" .
	     ",vlan0,vlan1".
	     ",vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0" .
	     ",vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1" .
	     ",q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm" .
	     ",q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit" .
	     ",q0_droptail,q0_red,q0_gentle" .
	     ",q1_limit,q1_maxthresh,q1_minthresh,q1_weight,q1_linterm" .
	     ",q1_qinbytes,q1_bytes,q1_meanpsize,q1_wait,q1_setbit" .
	     ",q1_droptail,q1_red,q1_gentle)" .
	     " values ('$pid','$eid','$idx','$pnodename','$lan' ".
	     ",$noshaping,'$iface0','$iface1','$lan','$lan'".
	     ",'$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate".
	     ",'$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill,$rlossrate".
	     ",$q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm".
	     ",$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit".
	     ",$q0_droptail,$q0_red,$q0_gentle".
  	     ",$q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm".
	     ",$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit".
	     ",$q1_droptail,$q1_red,$q1_gentle)")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    else {
	my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	    $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	    $q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

	#
	# See if this delaynode was inserted strictly for tracing/monitoring.
	#
	my $noshaping = ($virtlan->membershaped($member0) ? 0 : 1);
    
	#
	# Obviously, its implied that the q0 params are towards the lan,
	# For the reverse side, force the queue to 2 slots (should be 1
	# but dummynet not quite precise enough) to avoid excess queuing
	# delay since the traffic should already be at the proper bandwidth
	# when it gets to the node.
	#
	DBQueryWarn("insert into delays" .
	     " (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1," .
	     "  vlan0,vlan1,".
	     "  vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0," .
	     "  vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1," .
	     "  q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm," .
	     "  q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit," .
	     "  q0_droptail,q0_red,q0_gentle,q1_limit,q1_qinbytes) " .
	     " values ('$pid','$eid','$idx','$pnodename','$lan', ".
	     "  $noshaping,'$iface0','$iface1','$lan','$lan',".
	     "  '$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate,".
	     "  '$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill,$rlossrate,".
	     "  $q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,".
	     "  $q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,".
	     "  $q0_droptail,$q0_red,$q0_gentle,2,0)")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }

    #
    # XXX - Whenever a delay node is inserted, port speeds are set to
    #       their maximum speed on the delay node ports. This is to ensure that
    #       they get a valid number instead of something left over, but
    #       also because this is a simplification.
    #       At some point we might want to force all the
    #       ports along the way to 10Mbs, and have the delay node worry
    #       about delay only, and not bandwidth. That will be harder to
    #       to do in this mess. See companion XXX above where portbw hash
    #       is set.
    #
    my $speed0 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface0),
				  "ethernet");
    my $speed1 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface1),
				  "ethernet");

    $self->printdb("  Setting port speeds on $pnodename: ".
		   "$iface0:$speed0 $iface1:$speed1\n");

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed0' " .
		"where node_id='$pnodename' and ".
		"iface='$iface0'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed1' " .
		"where node_id='$pnodename' and ".
		"iface='$iface1'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    return 0;
}

#
# Link delays. These are done differently than delays. A link delay is
# a delay that is established at the endpoints of the link, instead of
# on a delay node. So, in a duplex link, there would be a traffic
# shaping rule on each output side of the link. On a lan, there are
# two rules, one for traffic to the switch, and one for traffic from
# the switch. Like above, there are also queues associated with output
# side (to the switch) of a link.
#
sub AddLinkDelay($$$$$$)
{
    my ($self, $virtlan, $member, $pnodename, $iface, $islan, $params) = @_;

    # backfill unsupported for linkdelays so ignore its entry in params.
    my ($delay,$bandwidth,$backfill,$lossrate,
	$rdelay,$rbandwidth,$rbackfill,$rlossrate) = @{$params};

    #
    # We need to find the queue info. If its a member of a lan, there
    # is just one queue, *towards* the lan. A duplex link has two queues,
    # one for each member (outgoing side).
    #
    my ($q_limit,$q_maxthresh,$q_minthresh,$q_weight,$q_linterm,
	$q_qinbytes,$q_bytes,$q_meanpsize,$q_wait,$q_setbit,
	$q_droptail,$q_red,$q_gentle) = @{ $member->_queueinfo() };

    my $pnode =  $self->pnodes()->{$pnodename};

    # Mark pnode for alternate kernel.
    $pnode->_needslinkdelay(1);
    # Stats.
    $self->exptstats()->{"linkdelays"} += 1;

    # ipfw pipe numbers so we can control it remotely.
    my $pipe  = $pnode->_pipenumber();
    my $rpipe = $pipe + 10;
    $pnode->_pipenumber($rpipe + 10);

    my $vnodename  = $member->vnode();
    my $mask       = $member->mask();
    my $ip         = $member->ip();
    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();
    my $nobwshaping = $virtlan->_nobwshaping();

    #
    # We allow users to oversubscribe by letting them turn off the
    # bandwidth shaping. If however, if the link was shaped for some
    # other reason (like a delay), then turn off just the bw shaping
    # part by setting them to 0.  This is special; means no limits in
    # ipfw.
    #
    if ($nobwshaping) {
	$bandwidth = $rbandwidth = 0;
    }

    $self->printdb("  LinkDelay: \[$pipe,$rpipe," .
		   "$virtlan,$delay,$bandwidth,$backfill,$lossrate".
		   ($islan ? "$rdelay,$rbandwidth,$rbackfill,$rlossrate" : "").
		   "\]\n");

    return 0
	if ($self->impotent() || $self->alloconly());

    DBQueryWarn("insert into linkdelays " .
		" (node_id,iface,type,ip,netmask,exptidx,pid,eid,vlan, ".
		"  vnode,pipe,delay,bandwidth,lossrate, ".
		"  q_limit,q_maxthresh,q_minthresh,q_weight, ".
		"  q_linterm,q_qinbytes,q_bytes,q_meanpsize, ".
		"  q_wait,q_setbit,q_droptail,q_red,q_gentle) ".
		" values " .
		" ('$pnodename','$iface','simplex','$ip','$mask', ".
		"  '$idx', '$pid','$eid', ".
		"  '$lan','$vnodename',$pipe,$delay,$bandwidth,$lossrate, ".
		"  $q_limit,$q_maxthresh,$q_minthresh,$q_weight, ".
		"  $q_linterm,$q_qinbytes,$q_bytes,$q_meanpsize, ".
		"  $q_wait,$q_setbit,$q_droptail,$q_red,$q_gentle)")
	or return -1;
    
    #
    # If its a lan, add the from-switch stuff. On the node, the ipfw
    # pipe that is built for this will need to specify a queue size of 1.
    #
    if ($islan) {
	DBQueryWarn("update linkdelays set ".
		    " rpipe=$rpipe,rdelay=$rdelay,rbandwidth=$rbandwidth, ".
		    " rlossrate=$rlossrate,type='duplex' ".
		    "where node_id='$pnodename' and ".
		    "      vlan='$lan' and vnode='$vnodename'")
	    or return -1;
    }
    return 0;
}

#
# Add a bridge. At the moment, bridges are just delay nodes. 
#
sub AddBridge($$$$)
{
    my ($self, $bridgename, $member0, $member1) = @_;
    my $iface0 = $member0->_pport();
    my $iface1 = $member1->_pport();
    my $pnodename = $member0->_pnode();
    my $pnode =  $self->pnodes()->{$pnodename};
    my $lan0  = $member0->virt_lan()->vname();
    my $lan1  = $member1->virt_lan()->vname();

    # Bridge index, multiple rows in the table under the same index.
    my $bridgeidx = $pnode->_pipenumber();
    $pnode->_pipenumber($bridgeidx + 1);

    # ipfw pipe numbers.
    my $pipe0 = $pnode->_pipenumber();
    my $pipe1 = $pipe0 + 10;
    $pnode->_pipenumber($pipe1 + 10);

    my $vnodename0 = $member0->vnode();
    my $vnodename1 = $member1->vnode();
    my $experiment = $self->experiment();
    my $pid   = $experiment->pid();
    my $eid   = $experiment->eid();
    my $idx   = $experiment->idx();

    # The name of the bridge (as for the delay agent).
    my $vname = $bridgename;

    $self->printdb("  Bridge:$bridgeidx $iface0:$pnodename:$iface1\n");

    # Grab the queue info.
    my ($q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm,
	$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit,
	$q0_droptail,$q0_red,$q0_gentle) = @{ $member0->_queueinfo() };

    my ($q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm,
	$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit,
	$q1_droptail,$q1_red,$q1_gentle) = @{ $member1->_queueinfo() };

    #
    # And the shaping params. Since this bridge mimics the delay for
    # a duplex link, we only use the "forward" params from each
    # member.
    #
    my ($delay,$bandwidth,undef,$backfill,$lossrate)      =
	@{ $member0->_delayinfo() };
    my ($rdelay,$rbandwidth,undef,$rbackfill,$rlossrate)  =
	@{ $member1->_delayinfo() };

    # See if the user wants the bw shaping to be disabled.
    $bandwidth = 0
	if ($member0->nobwshaping());
    $rbandwidth = 0
	if ($member1->nobwshaping());

    #
    # We are inserting the bridge, but it might not be for shaping.
    # Maybe for tracing. We use the estimated bandwidth field to
    # signal this, but need a better approach.
    #
    my $noshaping = (defined($member0->est_bandwidth()) ||
		     defined($member1->est_bandwidth()) ? 0 : 1);

    $self->printdb("  Shaping: $lan0: $pipe0,$delay,$bandwidth,$lossrate\n".
		   "           $lan1: $pipe1,$rdelay,$rbandwidth,$rlossrate\n")
	if (!$noshaping);
    
    DBQueryWarn("insert into delays " .
		" (pid,eid,exptidx,node_id,vname,noshaping,iface0,iface1" .
		",vlan0,vlan1,isbridge".
		",vnode0,pipe0,delay0,bandwidth0,backfill0,lossrate0" .
		",vnode1,pipe1,delay1,bandwidth1,backfill1,lossrate1" .
		",q0_limit,q0_maxthresh,q0_minthresh,q0_weight,q0_linterm" .
		",q0_qinbytes,q0_bytes,q0_meanpsize,q0_wait,q0_setbit" .
		",q0_droptail,q0_red,q0_gentle" .
		",q1_limit,q1_maxthresh,q1_minthresh,q1_weight,q1_linterm" .
		",q1_qinbytes,q1_bytes,q1_meanpsize,q1_wait,q1_setbit" .
		",q1_droptail,q1_red,q1_gentle)" .
		" values ('$pid','$eid','$idx','$pnodename','$vname' ".
		",$noshaping,'$iface0','$iface1','$lan0','$lan1',1".
		",'$vnodename0',$pipe0,$delay,$bandwidth,$backfill,$lossrate".
		",'$vnodename1',$pipe1,$rdelay,$rbandwidth,$rbackfill".
		",$rlossrate".
		",$q0_limit,$q0_maxthresh,$q0_minthresh,$q0_weight,$q0_linterm".
		",$q0_qinbytes,$q0_bytes,$q0_meanpsize,$q0_wait,$q0_setbit".
		",$q0_droptail,$q0_red,$q0_gentle".
		",$q1_limit,$q1_maxthresh,$q1_minthresh,$q1_weight,$q1_linterm".
		",$q1_qinbytes,$q1_bytes,$q1_meanpsize,$q1_wait,$q1_setbit".
		",$q1_droptail,$q1_red,$q1_gentle)")
	or return -1 if (! ($self->impotent() || $self->alloconly()));

    #
    # Check for tracing.
    #
    my ($traced0, $endnode0, $trace_type0, $trace_expr0,
	$trace_snaplen0, $trace_db0) = @{ $member0->_traceinfo() };

    if ($traced0) {
	#
	# Must find the other end of the link, since a trace works by
	# capturing packets *leaving* the other side. 
	#
	my $omember = ($member0->virt_lan()->member(0) eq "$member0" ?
		       $member0->virt_lan()->member(1) :
		       $member0->virt_lan()->member(0));
	
	$self->printdb("  Trace: $member0: $omember,$pnodename,$iface0,$iface1\n");
	my $vname = $member0->virt_lan()->vname();
	my $vnode = $omember->virt_node()->vname();

	DBQueryWarn("insert into traces ".
		    " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		    "  linkvname, vnode, trace_type, trace_expr, ".
		    "  trace_snaplen, trace_db) ".
		    "values ".
		    "  ('$pnodename', 0, '$iface0', '$iface1','$pid','$eid', ".
		    "   '$idx', '$vname', '$vnode', ".
		    "   '$trace_type0', '$trace_expr0', $trace_snaplen0, ".
		    "   '$trace_db0')")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    
    my ($traced1, $endnode1, $trace_type1, $trace_expr1,
	$trace_snaplen1, $trace_db1) = @{ $member1->_traceinfo() };

    if ($traced1) {
	#
	# Must find the other end of the link, since a trace works by
	# capturing packets *leaving* the other side. 
	#
	my $omember = ($member1->virt_lan()->member(0) eq "$member1" ?
		       $member1->virt_lan()->member(1) :
		       $member1->virt_lan()->member(0));
	
	$self->printdb("  Trace: $member1: $omember,$pnodename,$iface1,$iface0\n");
	my $vname = $member1->virt_lan()->vname();
	my $vnode = $omember->virt_node()->vname();

	DBQueryWarn("insert into traces ".
		    " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		    "  linkvname, vnode, trace_type, trace_expr, ".
		    "  trace_snaplen, trace_db) ".
		    "values ".
		    "  ('$pnodename', 0, '$iface1', '$iface0','$pid','$eid', ".
		    "   '$idx', '$vname', '$vnode', ".
		    "   '$trace_type1', '$trace_expr1', $trace_snaplen1, ".
		    "   '$trace_db1')")
	    or return -1 if (! ($self->impotent() || $self->alloconly()));
    }
    
    #
    # XXX - Whenever a bridge node is inserted, port speeds are set to
    #       their maximum speed on the ports. This is to ensure that
    #       they get a valid number instead of something left over, but
    #       also because this is a simplification.
    my $speed0 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface0),
				  "ethernet");
    my $speed1 =
	$self->interfacespeedmbps(physinterfacetype($pnode, $iface1),
				  "ethernet");

    $self->printdb("  Setting port speeds on $pnodename: ".
		   "$iface0:$speed0 $iface1:$speed1\n");

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed0' " .
		"where node_id='$pnodename' and ".
		"iface='$iface0'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    DBQueryWarn("update interfaces set " .
		"current_speed='$speed1' " .
		"where node_id='$pnodename' and ".
		"iface='$iface1'")
	or return -1 if (!($self->impotent() || $self->alloconly()));

    return 0;
}

#
# Setup tracing on a link.
#
sub SetUpTracing($$$$$)
{
    my ($self, $virtlan, $member, $pnodename, $iface0, $iface1) = @_;
    my $vnodename = $member->vnode();

    # Bridged links handled elsewhere.
    return 0
	if ($virtlan->_bridged());

    #
    # Handle virtual nodes - in some cases (ie. PlanetLab), we have to
    # look in v2vmap to find out which node we got placed on.
    #
    if (exists($self->solution_v2v()->{$vnodename})) {
        $pnodename = $self->solution_v2v()->{$vnodename};
    }

    #
    # First see if this member of the lan wanted tracing. 
    #
    my ($traced, $endnode, $trace_type, $trace_expr,
	$trace_snaplen, $trace_db) = @{ $member->_traceinfo() };

    return 0
	if (!$traced);

    # This means its on an end node.
    $iface0 = ""
	if (!defined($iface0));

    $self->printdb("Trace: $virtlan, $member, ".
		   "$endnode, $pnodename, $iface0, $iface1\n");

    return 0
	if ($self->impotent() || $self->alloconly());

    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();
    my $lan = $virtlan->vname();

    DBQueryWarn("insert into traces ".
		 " (node_id, idx, iface0, iface1, pid, eid, exptidx, ".
		 "  linkvname, vnode, trace_type, trace_expr, trace_snaplen, ".
		 "  trace_db) ".
		 "values ".
		 "  ('$pnodename', 0, '$iface0', '$iface1', '$pid', '$eid', ".
		 "   '$idx', '$lan', '$vnodename', ".
		 "   '$trace_type', '$trace_expr', $trace_snaplen, ".
		 "   '$trace_db')")
	or return -1;
    
    return 0;
}

#
# Write the vlans table to the DB.
#
sub UploadVlans($)
{
    my ($self) = @_;
    my $experiment = $self->experiment();
    my $exptidx = $experiment->idx();
    
    #
    # Post process; mark vlans on federated nodes with a different type
    # so that we do not try to create them locally.
    #
    foreach my $protolanA (ProtoLan->ProtoLanList()) {
	next
	    if ($protolanA->type() ne "vlan");

	foreach my $member ($protolanA->MemberList()) {
	    my $node = $protolanA->MemberNode($member);
	    if ($node->isfednode()) {
		$protolanA->SetType("geni-vlan");
		last;
	    }
	}
	foreach my $member ($protolanA->IfaceList()) {
	    my $node = $protolanA->IfaceNode($member);
	    if ($node->isfednode()) {
		$protolanA->SetType("geni-vlan");
		last;
	    }
	}
    }

    #
    # MLE: make a pass through the implemented_by tree setting port speeds
    # that the user left up to assign (i.e., that are 0).  We start at the
    # lowest level links and assign default speeds.  Then we propagate those
    # speeds up to higher level links, and warn the user if the higher level
    # links don't support those speed settings (if they don't, we're gonna
    # have a problem :)).
    #
    $self->printdb("Setting speeds for MLE virtlans...\n");
    my @mlevlans = ();
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if (!($virtlan->_implemented_by() || $virtlan->_vpath()));

	if ($virtlan->_vpath()) {
	    $virtlan->_vpath()->_pathspeed0(0);
	    $virtlan->_vpath()->_pathspeed1(0);
	}

	push @mlevlans, $virtlan;
    }
    $self->printdb("mle virtlans: ".join(" ",@mlevlans)."\n");

    while (@mlevlans) {
      mleagain:
	my $virtlan = shift @mlevlans;
	
	# If it's a lan implemented by a path, we need to derive speeds from
	# the path endpoints.
	my $vpath;
	if (defined($vpath = $virtlan->_implemented_by())) {
	    if ($vpath->_pathspeed0() == 0 || $vpath->_pathspeed1() == 0) {
		$self->printdb("mlevlanspeed: delaying $virtlan until its" . 
			       " vpath $vpath is processed\n");
		push @mlevlans, $virtlan;
		goto mleagain;
	    }
	}
	else {
	    $vpath = $virtlan->_vpath();
	}

	#
	# Handle a virtlan (whether it's a path segment or a link implemented
	# by a path -- we handle each case a little differently below):
	#
	my $protolink = ProtoLan->Lookup($self->experiment(),
					 $virtlan->vname());
	my $lan = Lan->Lookup($self->experiment()->idx(),
			      $virtlan->vname());

	my ($member0,$member1) = $virtlan->memberlist();
	my ($iface0,$iface1,$pnode0,$pnode1);
	if ($protolink->IfaceList() != 0) {
	    ($iface0,$iface1,$pnode0,$pnode1) = 
		($protolink->{"IFACES"}->{$member0}->{"iface"},
		 $protolink->{"IFACES"}->{$member1}->{"iface"},
		 $protolink->{"IFACES"}->{$member0}->{"node"},
		 $protolink->{"IFACES"}->{$member1}->{"node"});
	}
	else {
	    $self->printdb("ERROR: is $protolink a protovlan?!\n");
	    return -1;
	}

	my $member0if = $protolink->{"IFACES"}->{$member0};
	my $member1if = $protolink->{"IFACES"}->{$member1};
	my ($cs_member0,$cs_member1) = (0,0);

	if (defined($member0if->{"attrs"})
	    && exists($member0if->{"attrs"}->{"current_speed"})) {
	    $cs_member0 = $member0if->{"attrs"}->{"current_speed"};
	}
	if (defined($member1if->{"attrs"})
	    && exists($member1if->{"attrs"}->{"current_speed"})) {
	    $cs_member1 = $member1if->{"attrs"}->{"current_speed"};
	}

	if ($virtlan->_implemented_by()) {
	    $self->printdb("mlevlanspeed: $virtlan (implemented by $vpath):" . 
			   " $member0 ($pnode0,$iface0,$cs_member0)" . 
			   " $member1 ($pnode1,$iface1,$cs_member1)\n");
	}
	else {
	    $self->printdb("mlevlanspeed: vpath $vpath segment $virtlan:" . 
			   " $member0 ($pnode0,$iface0,$cs_member0)" . 
			   " $member1 ($pnode1,$iface1,$cs_member1)\n");
	}
	
	my $interface0 = Interface->LookupByIface($pnode0,$iface0);
	my $interface1 = Interface->LookupByIface($pnode1,$iface1);

	my ($speed0,$speed1);
	if ((!exists($self->portbw()->{$member0})
	     || $self->portbw()->{$member0} == 0)
	    && $cs_member0 == 0) {
	    #
	    # Figure out the default speed if this is a path segment;
	    # otherwise inherit from the path.
	    #
	    if ($virtlan->_implemented_by()) {
		$speed0 = $vpath->_pathspeed0();
	    }
	    else {
		$speed0 =
		    $self->interfacespeedmbps($interface0->type(),"ethernet");
	    }

	    $self->printdb("Setting ifacebw: $pnode0:$iface0 $speed0\n");
	    #
	    # Save it off for later rounds of this loop for possible reference
	    #
	    $member0if->{"attrs"}->{"current_speed"} = $speed0;
	    #
	    # Upload it if we're not impotent or alloconly
	    #
	    if (!($self->impotent() || $self->alloconly())) {
		$interface0->Update({'current_speed' => $speed0 });
	    }
	}
	else {
	    $speed0 = (exists($self->portbw()->{$member0})
		       && $self->portbw()->{$member0}) ? 
		       $self->portbw()->{$member0} / 1000 :
		       $cs_member0;
	    #
	    # Sanity check: did somebody set a speed already (user or previous
	    # current_speed attribute from an AddInterface call), and does it
	    # not match what the underlying path thinks it should be?
	    #
	    if ($virtlan->_implemented_by()
		&& $virtlan->_vpath()->_pathspeed0() ne $speed0) {
		print STDERR "mlevlanspeed: preset link speed disagreed with" . 
		    " implementing start path segment!";
		return -1;
	    }
	}

	if ((!exists($self->portbw()->{$member1})
	     || $self->portbw()->{$member1} == 0)
	    && $cs_member1 == 0) {
	    #
	    # Figure out the default speed if this is a path segment;
	    # otherwise inherit from the path.
	    #
	    if ($virtlan->_implemented_by()) {
		$speed1 = $vpath->_pathspeed1();
	    }
	    else {
		$speed1 =
		    $self->interfacespeedmbps($interface1->type(),"ethernet");
	    }

	    $self->printdb("Setting ifacebw: $pnode1:$iface1 $speed1\n");
	    #
	    # Save it off for later rounds of this loop for possible reference
	    #
	    $member1if->{"attrs"}->{"current_speed"} = $speed1;
	    #
	    # Upload it if we're not impotent or alloconly
	    #
	    if (!($self->impotent() || $self->alloconly())) {
		$interface1->Update({'current_speed' => $speed1 });
	    }
	}
	else {
	    $speed1 = (exists($self->portbw()->{$member1})
		       && $self->portbw()->{$member1}) ? 
		       $self->portbw()->{$member1} / 1000 :
		       $cs_member1;
	    #
	    # Sanity check: did somebody set a speed already (user or previous
	    # current_speed attribute from an AddInterface call), and does it
	    # not match what the underlying path thinks it should be?
	    #
	    if ($virtlan->_implemented_by()
		&& $virtlan->_vpath()->_pathspeed1() ne $speed1) {
		print STDERR "mlevlanspeed: preset link speed disagreed with" . 
		    " implementing start path segment!";
		return -1;
	    }
	}

	#
	# Now, if this segment was part of a path, and it's the end or start
	# segment, set some bits on the path object so we can let links that
	# are implemented by paths inherit speed settings from the implementing
	# path endpoints.
	#
	if ($virtlan->_vpath()) {
	    my @links = $vpath->virtlanlist();

	    # save the endpoint speeds!
	    if ($links[0]->vname() eq $virtlan->vname()) {
		$vpath->_pathspeed0($speed0);
		$self->printdb("Saving ifacebw for vpath $vpath start: $speed0\n");
	    }
	    elsif ($links[@links-1]->vname() eq $virtlan->vname()
		   || @links == 1) {
		$vpath->_pathspeed1($speed1);
		$self->printdb("Saving ifacebw for vpath $vpath end: $speed1\n");
	    }
	}
    }
    $self->printdb("Done setting speeds for MLE virtlans.\n");
    
    #
    # Emulated vlans will result in node:port pairs being in more than
    # one vlan since that link is shared for several lans. For hardware
    # implemented 802.1q tagged vlans (type "vlan"), this is ok. But for
    # "veth" implemented vlans, we have to merge the overlapping vlans
    # into "supervlans". Must be done iteratively of course.
    #
    $self->printdb("Dumping protolans before merging.\n");
    ProtoLan->DumpAll()
	if ($self->verbose());
    
    $self->printdb("Merging vlans ...\n");
  again:
    foreach my $protolanA (ProtoLan->ProtoLanList()) {
	my @membersA = $protolanA->MemberList();
	my $keyA     = $protolanA->vname();

	next
	    if (! ($protolanA->type() eq "vlan" &&
		   $protolanA->role() eq "encapsulation" &&
		   $protolanA->encapstyle() ne "vlan"));

	foreach my $protolanB (ProtoLan->ProtoLanList()) {
	    my @membersB = $protolanB->MemberList();
	    my $keyB     = $protolanB->vname();

	    next
		if (! ($protolanB->type() eq "vlan" &&
		       $protolanB->role() eq "encapsulation" &&
		       $protolanB->encapstyle() ne "vlan"));
	    
	    if ($keyA ne $keyB) {
		foreach my $memberA (@membersA) {
		    if (grep {$_ eq $memberA} $protolanB->MemberList()) {
			foreach my $memberB (@membersB) {
			    if (! grep {$_ eq $memberB}
				$protolanA->MemberList()) {
				$protolanA->AddMember(split(":", $memberB));
			    }
			}
			# Must reset the links before killing the old one.
			foreach my $protolan (ProtoLan->ProtoLanList()) {
			    if (defined($protolan->link()) &&
				$protolan->link()->vname()
				   eq $protolanB->vname()) {
				$protolan->SetLink($protolanA);
			    }
			}
			$self->printdb("Merged $protolanB into $protolanA\n");
			$protolanB->Destroy();
			goto again;
		    }
		}
	    }
	}
    }
    
    if (!($self->impotent() || $self->alloconly())) {
	$self->printdb("Uploading protolans table.\n");
	ProtoLan->DumpAll()
	    if ($self->verbose());
	if (ProtoLan->InstantiateAll($self->regression()) != 0) {
	    tberror("Could not instantiate protolans!\n");
	    return -1;
	}

	my @lans;
	if (Lan->ExperimentLans($experiment, \@lans) != 0) {
	    tberror("Could not get list of all lans for $experiment\n");
	    return -1;
	}
	#
	# Once the lans are instantiated we have to go back and update the
	# vinterfaces table. Eventually I want to roll vinterface creation
	# into lan instantiation.
	#
	foreach my $lan (@lans) {
	    # Only care about encapsulated links.
	    next
		if (! ($lan->type() eq "emulated" ||
		       $lan->GetRole() eq "emulated"));

	    my $virtlan     = $self->vlans()->{$lan->vname()};
	    if (!defined($virtlan)) {
		tberror("Could not find lan $lan in local lan list!\n");
		return -1;
	    }
	    my $virtlanidx  = $virtlan->idx();
	    my $linkedlanid = $lan->lanid();

	    #
	    # An encapsulated lan is linked to the real lan.
	    # A vlan encapsulated link does not have a linked lan;
	    # there is no need for it.
	    #
	    if ($lan->type() eq "emulated") {
		my $linkedlan = $lan->GetLinkedLan();
		if (!defined($linkedlan)) {
		    tberror("Emulated lan $lan does not have a linked vlan!\n");
		    return -1;
		}
		$linkedlanid = $linkedlan->lanid();
	    }
	    DBQueryWarn("update vinterfaces set vlanid='$linkedlanid' ".
			"where virtlanidx='$virtlanidx' and ".
			"      exptidx='$exptidx'")
		or return -1;
	}

	#
	# Set the trunk/speed for any physical ports so marked.
	#
	foreach my $lan (@lans) {
	    next
		if ($lan->type() ne "vlan");

	    # Set the failureaction on the vlan according to the link/lan.
	    my $lanname;
	    $lan->GetAttribute("link/lan", \$lanname);
	    my $virtlan = $self->vlans()->{$lanname};
	    if (defined($virtlan)) {
		$lan->SetAttribute("failureaction", $virtlan->failureaction());
	    }
	    
	    my @members;
	    if ($lan->MemberList(\@members) != 0) {
		tberror("Could not get member list for $lan\n");
		return -1;
	    }
	    foreach my $member (@members) {
		my $current_speed;
		my $trunk_mode;
		$member->GetAttribute("trunk_mode", \$trunk_mode);
		$member->GetAttribute("current_speed", \$current_speed);

		next
		    if (! (defined($trunk_mode) || defined($current_speed)));
		
		my $interface = $member->GetInterface();
		if (!defined($interface)) {
		    tberror("No interface for $member\n");
		    return -1;
		}
		my $args = {};
		$args->{'current_speed'} = $current_speed
		    if (defined($current_speed));
		$args->{'trunk'} = 1
		    if (defined($trunk_mode));
		$interface->Update($args) == 0
		    or return -1;
	    }
	}
    }
    else {
	$self->printdb("Dumping final protolans table.\n");
	ProtoLan->DumpAll()
	    if ($self->verbose());
    }

    #
    # Upload the port bw to the interfaces table for each iface.
    #
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();

	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));

	    # XXX NSE checks I do not understand.
	    next
		if (! (exists($self->portbw()->{$member}) &&
		       exists($self->solution_v2p()->{$member->vnode()})));

	    # Skip anything that is implemented by a path; speed set elsewhere.
	    next
		if (defined($virtlan->_implemented_by()));

	    # Skip anything that was turned into a vinterface; the
	    # port speed will get set elsewhere.
	    next
		if (exists($self->solution_vifacemap()->{$member}));

	    my $iface     = $self->solution_portmap()->{$member};
	    my $pnodename = $self->solution_v2p()->{$member->vnode()};
	    my $speed     = $self->portbw()->{$member};
	    
	    # XXX - the following converts from bps to Mbps
	    $speed = $speed / 1000;

	    $self->printdb("Interface speed: $pnodename:$iface $speed\n");
	    
	    DBQueryWarn("update interfaces set current_speed='$speed' ".
			"where node_id='$pnodename' and iface='$iface'")
		or return -1 if (!($self->impotent() || $self->alloconly()));
	}
    }

    #
    # Patch up virts.
    #
    foreach my $vname (keys(%{ $self->vlans() })) {
	next
	    if (!exists($self->solution_vethpatch()->{$vname}));

	foreach my $pname (keys(%{ $self->solution_vethmap()->{$vname} })) {
	    next
		if (!exists($self->solution_vethpatch()->{$vname}->{$pname}));

	    my $pport = $self->solution_vethpatch()->{$vname}->{$pname};
	    my $pnode = $self->pnodes()->{$pname};

	    foreach my $vid (@{$self->solution_vethmap()->{$vname}->{$pname}}) {
		#
		# For veth and vlan interfaces, we need to set the
		# characteristics of the underlying physical
		# interface.
		#
		my $speed =
		    $self->interfacespeedmbps(physinterfacetype($pnode, $pport),
					      "ethernet");
		$self->printdb("Virt Patch: ".
			       "$vname $pname $vid $pport $speed\n");
	
		if (!($self->impotent() || $self->alloconly())) {
		    DBQueryWarn("update vinterfaces set iface='$pport' ".
				"where node_id='$pname' and unit='$vid'")
			or return -1;

		    DBQueryWarn("update interfaces set " .
				"   current_speed='$speed' " .
				"where node_id='$pname' and iface='$pport'")
			or return -1;
		}
	    }
	}
    }
    return 0;
}

#
# Upload the IP addresses to the interfaces table.
#
sub UpLoadIPAddresses($)
{
    my ($self) = @_;

    # For recording IPs we have seen already.
    my %IPs = ();

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();
	my $mask     = $virtlan->_mask();

	next
	    if ($virtlan->_layer() != 2);

	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));

	    my $iface = $self->solution_portmap()->{$member};
	    my $vnodename = $member->vnode();

	    if ($member->usevirtiface()) {
		#
		# Emulated links on local virtual nodes use the new
		# veth device.
		#
		# See NewVirtIface() calls. Everything was set up then.
		#
		my $pnodename = $self->solution_v2p()->{$vnodename};
		my $ip        = $member->ip();

		$self->printdb("IP: $member - $pnodename:$iface $ip\n");
	    }
	    else {
		#
		# Use IPs above to catch if we have inserted an entry
		# for this pnode/iface yet. If not, insert a normal
		# entry. If so, we want to add a new ipalias for the
		# interface. That is cause assign can cause an interface
		# to be shared between multiple links, and so we need
		# ipaliases on the client side.
		#
		my $pnodename  = $self->solution_v2p()->{$vnodename};
		my $pnode      = $self->pnodes()->{$pnodename};
		my $ip         = $member->ip();
		my $rtabid     = $self->getrtabid($pnode, $member);
		my $pvnodename = undef;

		# Mark as being a jail interface by establishing a connection
		# to the nodes table entry for the virtnode.
		if (exists($self->solution_v2v()->{$vnodename})) {
		    my $pvnode =
			$self->pnodes()->{$self->solution_v2v()->{$vnodename}};

		    if ($pvnode->isjailed()) {
			$pvnodename = $self->solution_v2v()->{$vnodename};
		    }
		}

		if (! exists($IPs{"$pnodename:$iface"})) {
		    $self->printdb("IP: $member - ".
				   (defined($pvnodename) ? "$pvnodename:" : "").
				   "$pnodename:$iface $ip\n");
		    
		    #
		    # Never update control net interfaces. This is so
		    # that we can consider them for mapping purposes
		    # (ie. PlanetLab), but don't have to worry about
		    # their IPs getting changed, since that's
		    # important persistent state!
		    #
		    if (physinterfacerole($pnode,$iface) eq
			TBDB_IFACEROLE_CONTROL) {
			$self->printdb("Not setting IP for control interface: ".
				       "$pnode:$iface\n");
		    }
		    else {
			my $vnode_id = (defined($pvnodename) ?
					"'$pvnodename'" : "NULL");
			
			DBQueryWarn("update interfaces set ".
				    "   IP='$ip',IPaliases=NULL,mask='$mask',".
				    "   vnode_id=$vnode_id,rtabid='$rtabid' ".
				    "where node_id='$pnodename' and ".
				    "      iface='$iface'")
			    or return -1 if (!($self->impotent() ||
					       $self->alloconly()));
			    
			$IPs{"$pnodename:$iface"} = 1;
		    }
		}
		else {
		    #
		    # Rather then an IP aliases like we used to do,
		    # tie a virtual interface to it.
		    #
		    my $viface =
			$self->NewVirtIface($virtlan, $member,
					    $pnodename, $iface);

		    $self->printdb("IP: $member - ".
				   "$pnodename:$iface $ip ($viface)\n");
		}
	    }
	}
    }
    return 0;
}

#
# Upload the tunnels table. These are built for remote node links.
#
sub UpLoadTunnels($)
{
    my ($self) = @_;

    #
    # First need to assign ports to the servers. To do that need to
    # figure out who is a server! We put the server on a real emulab
    # node if possible, and otherwise one of the virtual nodes. Also,
    # we want to share the server amongst more than one link, if
    # possible, since a server can handle more than one tunnel. So,
    # make sure that only one port is assigned per server node.
    #
    my %lantotunnelserver = ();
    my %rnodetotunnelport = ();
    my $secretkey;

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $server;
	
	next
	    if (! $virtlan->_tunnel());
	next
	    if ($virtlan->_geninodes());

	my @members = $virtlan->memberlist();
	if (@members != 2) {
	    tberror("Too many members for a tunnel!\n");
	    return -1;
	}

	#
	# Pick one of the members to be the server.
	# 
	foreach my $member (@members) {
	    my $virtnode = $member->virt_node();

	    # Start with the first node, but overwrite if better choice.
	    $server = $virtnode
		if (!defined($server) ||
		    (! $virtnode->_isremotenode() &&
		     ! exists($lantotunnelserver{$virtlan})));
	}
	$lantotunnelserver{$virtlan} = $server;

	# Assign a port, but only the first time chosen.
	if (! $rnodetotunnelport{$server}) {
	    my $pnodename = $self->solution_v2p()->{$server->vname()};
	    my $pnode = $self->pnodes()->{$pnodename};
	
	    $rnodetotunnelport{$server} = nextipportnum($pnode);
	}
    }
    foreach my $virtlan (values(%{ $self->vlans() })) {
	next
	    if (! $virtlan->_tunnel());
	next
	    if ($virtlan->_geninodes());

	my $server    = $lantotunnelserver{$virtlan};
	my $ipport    = $rnodetotunnelport{$server};
	my $mask      = $virtlan->_mask();
	my $secretkey = TBGenSecretKey();

	my ($member0,$member1) = $virtlan->memberlist();
	my $virtnode0 = $member0->virt_node();
	my $virtnode1 = $member1->virt_node();
	my $ip0       = $member0->ip();
	my $ip1       = $member1->ip();
	
	my $pnodename0 = ($virtnode0->_isvirtnode() ?
			  $self->solution_v2v()->{$virtnode0->vname()} :
			  $self->solution_v2p()->{$virtnode0->vname()});
	my $pnodename1 = ($virtnode1->_isvirtnode() ?
			  $self->solution_v2v()->{$virtnode1->vname()} :
			  $self->solution_v2p()->{$virtnode1->vname()});
	my $pnode0 = $self->pnodes()->{$pnodename0};
	my $pnode1 = $self->pnodes()->{$pnodename1};
    
	#
	# Need to map the server to the control net interface of the
	# physical node.
	#
	my $peerip0 = Interface->LookupControl($pnode0);
	my $peerip1 = Interface->LookupControl($pnode1);

	if (!defined($peerip0)) {
	    tberror("No Control Network IP for $pnodename0!\n");
	    return -1;
	}
	if (!defined($peerip1)) {
	    tberror("No Control Network IP for $pnodename1!\n");
	    return -1;
	}
	$self->printdb("Tunnel: $member0 <-> $member1, ".
		       "$ip0 <-> $ip1, $peerip0 <-> $peerip1\n");

	next
	    if ($self->impotent() || $self->alloconly());

	my $tunnel = Tunnel->Create($self->experiment(),
				    $virtlan->vname(), $secretkey,
				    $virtlan->_encapstyle(), $mask, $ipport);
	if (!defined($tunnel)) {
	    tberror("Could not create tunnel for $virtlan\n");
	    return -1;
	}
	my $iface0 = $tunnel->AddInterface($pnodename0,
					   $member0->vnode(),
					   $member0->vport());
	if (!defined($iface0)) {
	    tberror("Could not add $member0 to $tunnel\n");
	    return -1;
	}
	my $iface1 = $tunnel->AddInterface($pnodename1,
					   $member1->vnode(),
					   $member1->vport());
	if (!defined($iface1)) {
	    tberror("Could not add $member1 to $tunnel\n");
	    return -1;
	}

	# Need to set a bunch of attributes later returned by tmcd.
	if ($iface0->SetAttribute("tunnel_ip", $ip0) ||
	    $iface0->SetAttribute("tunnel_peerip", $ip1) ||
	    $iface0->SetAttribute("tunnel_srcip", $peerip0) ||
	    $iface0->SetAttribute("tunnel_dstip", $peerip1) ||
	    $iface0->SetAttribute("tunnel_isserver",
			  ($server->vname() eq $virtnode0->vname() ? 1 : 0)) ||
	    $iface0->SetAttribute("tunnel_secretkey", $secretkey) ||
	    $iface0->SetAttribute("tunnel_ipmask", $mask) ||
	    $iface0->SetAttribute("tunnel_serverport", $ipport) ||
	    $iface0->SetAttribute("tunnel_lan", $virtlan->vname()) ||
	    $iface0->SetAttribute("tunnel_unit", $iface0->memberid() + 1) ||
	    $iface0->SetAttribute("tunnel_style", $virtlan->_encapstyle())) {
	    tberror("Could not set attributes for $iface0 in $tunnel\n");
	    return -1;
	}
	if ($iface1->SetAttribute("tunnel_ip", $ip1) ||
	    $iface1->SetAttribute("tunnel_peerip", $ip0) ||
	    $iface1->SetAttribute("tunnel_srcip", $peerip1) ||
	    $iface1->SetAttribute("tunnel_dstip", $peerip0) ||
	    $iface1->SetAttribute("tunnel_isserver",
			  ($server->vname() eq $virtnode1->vname() ? 1 : 0)) ||
	    $iface1->SetAttribute("tunnel_secretkey", $secretkey) ||
	    $iface1->SetAttribute("tunnel_ipmask", $mask) ||
	    $iface1->SetAttribute("tunnel_serverport", $ipport) ||
	    $iface1->SetAttribute("tunnel_lan", $virtlan->vname()) ||
	    $iface1->SetAttribute("tunnel_unit", $iface1->memberid() + 1) ||
	    $iface1->SetAttribute("tunnel_style", $virtlan->_encapstyle())) {
	    tberror("Could not set attributes for $iface1 in $tunnel\n");
	    return -1;
	}
    }
    return 0;
}

#
# Upload interface settings.
#
sub UpLoadInterfaceSettings($)
{
    my ($self) = @_;

    my $experiment = $self->experiment();
    my $pid = $experiment->pid();
    my $eid = $experiment->eid();
    my $idx = $experiment->idx();

    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $protocol = $virtlan->_protocol();
	my $vlanname = $virtlan->vname();

	next
	    if (! ($protocol =~ /^(80211|flex900|xcvr2450)/));

	my @members = $virtlan->memberlist();
	my $ssid    = "${vlanname}_${idx}";
	my $apmac;

	if (defined($virtlan->_accesspoint())) {
	    my $member    = $virtlan->_accesspoint();
	    my $vnodename = $member->vnode();
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $iface     = $self->solution_portmap()->{$member};
	    my $pnode     = $self->pnodes()->{$pnodename};
	    my $interface;

	    if ($pnode->GetInterface($iface, \$interface) != 0) {
		tberror("Could not find interface $pnodename:$iface\n");
		return -1;
	    }
	    $apmac = $interface->mac();
	}

	foreach my $member (@members) {
	    my $vnodename = $member->vnode();
	    my $pnodename = $self->solution_v2p()->{$vnodename};
	    my $iface     = $self->solution_portmap()->{$member};

	    #
	    # First copy over the lan settings.
	    #
	    foreach my $lan_setting ($self->virt_lan_settings()->Rows()) {
		my $capkey = DBQuoteSpecial($lan_setting->capkey());
		my $capval = DBQuoteSpecial($lan_setting->capval());
		my $vname  = $lan_setting->vname();

		next
		    if ($vname ne $vlanname);

		$self->printdb("interface_setting: $vname: ".
			       "$pnodename $iface $capkey $capval\n");
	    
		DBQueryWarn("insert into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', ".
			    "        $capkey, $capval)")
		    or return -1 if (!($self->impotent() ||
				       $self->alloconly()));
	    }

	    #
	    # Next do the per-member settings, which override lan settings.
	    #
	    foreach my $setting ($self->virt_lan_member_settings()->Rows()) {
		next
		    if ("$member" ne $setting->member());

		my $capkey = DBQuoteSpecial($setting->capkey());
		my $capval = DBQuoteSpecial($setting->capval());

		$self->printdb("interface_setting (member): ".
			       "$pnodename $iface $capkey $capval\n");
	    
		DBQueryWarn("replace into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', ".
			    "        $capkey, $capval)")
		    or return -1 if (! ($self->impotent() ||
					$self->alloconly()));
	    }

	    #
	    # And lastly, these override anything the user says to do.
	    # 
	    DBQueryWarn("replace into interface_settings ".
			 "       (node_id, iface, capkey, capval) ".
			 "values ('$pnodename', '$iface', ".
			 "        'protocol', '$protocol')")
		or return -1 if (! ($self->impotent() ||
				    $self->alloconly()));
		
	    $self->printdb("interface_setting: ".
			   "$pnodename $iface protocol $protocol\n");

	    DBQueryWarn("replace into interface_settings ".
			"       (node_id, iface, capkey, capval) ".
			"values ('$pnodename', '$iface', 'ssid', '$ssid')")
		or return -1 if (! ($self->impotent() ||
				    $self->alloconly()));
	
	    $self->printdb("interface_setting: ".
			   "$pnodename $iface ssid $ssid\n");

	    if (defined($apmac)) {
		DBQueryWarn("replace into interface_settings ".
			    "       (node_id, iface, capkey, capval) ".
			    "values ('$pnodename', '$iface', ".
			    "        'accesspoint', '$apmac')")
		    or return -1 if (! ($self->impotent() ||
					$self->alloconly()));
		    
		$self->printdb("interface_setting: ".
			       "$pnodename $iface accesspoint $apmac\n");
	    }
	}
    }
    return 0;
}

# getnodeport(s)
# Takes a ports result from assign (mac0,mac1) and converts null strings to undef.
sub getnodeport($)
{
    my $macstring=$_[0];
    my ($A,$B) = ($macstring =~ /^\(([^,]+),([^,]+)\)$/);

    $A = undef
	if ($A eq "(null)");
    $B = undef
	if ($B eq "(null)");

    return ($A, $B);
}

# getportlist
# Takes the list of arguments on an edges line and returns the set of
# ports spanned by that vlan.
sub getportlist(@)
{
    my @info   = @_;
    my @result = ();
    # The beginning and end of the list are ignored for the path
    # since we care only about the Trunk links.
    @info = splice(@info, 4, $#info);
    while (@info) {
	#
	# Traverse two at a time. We can deduce the switch pair
	# from the first string, but thats a kludge.  The
	# second string is supposed to be real interface info,
	# but ignore that for now, until new ptopgen actually
	# sets it.
	#
	my $field1 = shift(@info);
	my $field2 = shift(@info);

	if ($field1 =~ /^link\-/ &&
	    $field2 eq "((null),(null))") {
	    $field1 =~ s/^link\-//;
	    push(@result, $field1);
	}
    }
    return join(" ", @result);
}

# Get the type for an interface.
sub physinterfacetype($$)
{
    my ($pnode, $iface) = @_;

    my $interface;
    if ($pnode->GetInterface($iface, \$interface) != 0) {
	tberror("Could not get interface: $pnode:$iface\n");
	return -1;
    }
    return $interface->type();
}
# Get the role for an interface.
sub physinterfacerole($$)
{
    my ($pnode, $iface) = @_;

    my $interface;
    if ($pnode->GetInterface($iface, \$interface) != 0) {
	tberror("Could not get interface: $pnode:$iface\n");
	return -1;
    }
    return $interface->role();
}

#
# Give me a new vname for an internally allocated node. We have to
# watch for names that were made up previously (say, if this is an
# update).  Not allowed to reuse names of course. We do not mark nodes
# as hosting, so have to infer this from reserved_pnodes. I'm sure
# there is a better way to do this.
#
sub newvname($$$)
{
    my ($self, $pnodename, $prefix) = @_;

    #
    # First check to see if this pnode was already allocated (update)
    #
    my @vnames = keys(%{ $self->current_v2p() });
	
    foreach my $vname (@vnames) {
	# Skip the v mappings.
	next
	    if (exists($self->current_v2v->{$vname}));

	return $vname
	    if ($pnodename eq $self->current_v2p->{$vname});
    }
    
    while (1) {
	my $newname = $prefix . "-" . $self->nextphostnumber();

	return $newname
	    if (!exists($self->current_v2p->{$newname}));
    }
}

sub array_diff($$)
{
    my ($a, $b) = @_;

    my %seen; # lookup table
    my @aonly;# answer
    
    # build lookup table
    @seen{@$b} = ();

    foreach my $item (@$a) {
	push(@aonly, $item) unless exists $seen{$item};
    }
    return @aonly;
}

#
# If there are no virtual nodes, then there is no port sharing, and it
# makes no difference, as long as there are no collisions on a
# node. If there are virtual nodes, then assign a port range for the
# experiment, and all port allocations need to be shared within that
# range on each phys node. That is, if there are 2 virtual nodes on
# physical node, then must allocated from the one range.  There is
# never any overlap between experiements of course.
# 
sub SetPortRange($)
{
    my ($self) = @_;

    #
    # No virtual nodes, fall back to simple approach.
    #
    return 0
	if (! scalar(keys(%{ $self->solution_v2v() })));

    #
    # Use existing port range when updating, or else find a free slot.
    #
    my ($newlow,$newhigh) = $self->experiment()->GetPortRange();
    if (!defined($newlow)) {
	#
	# It is okay to do this in impotent mode; it is harmless.
	#
	($newlow,$newhigh) = $self->experiment()->SetPortRange(0);
    }
    if (!defined($newlow)) {
	tberror("Could not set the portrange!\n");
	return -1;
    }
    $self->printdb("SetPortRange: $newlow,$newhigh\n");

    #
    # Now set the port range for those nodes hosting virtual nodes.
    # This prevents overlap with other vnodes from other experiments
    # on that nodes. Since you cannot share a node unless you are using
    # virtual nodes, there is no need to worry about phys nodes that
    # are dedicated. That might change of course. 
    #
    foreach my $vnodename (keys(%{ $self->solution_v2v() })) {
	my $vpnodename = $self->solution_v2v()->{$vnodename};
	my $vpnode     = $self->pnodes()->{$vpnodename};
	my $pnodename  = $self->solution_v2p()->{$vnodename};
	my $pnode      = $self->pnodes()->{$pnodename};

	$vpnode->_portlow($newlow);
	$vpnode->_porthigh($newhigh);
	$pnode->_portlow($newlow);
	$pnode->_porthigh($newhigh);

	my $portarray1 = [];
	my $portarray2 = [];

	#
	# XXX This attempts to keep the sshd port the same across
	# swapmod. We need a better (more general) way to do this.
	#
	my $sshdport;
	if (exists($self->current_v2v()->{$vnodename}) &&
		$vpnode->sshdport() != 11000) {

	    $sshdport = $vpnode->sshdport();
	    #$self->printdb("reserving sshdport $sshdport on $vpnode\n");
	}
	
	for (my $i = 0, my $port = $pnode->_portlow();
	     $i < $pnode->_porthigh() - $pnode->_portlow(); $i++,$port++) {
	    
	    $portarray1->[$i] = ($i < 10 ? $port : 0 - $port);
	    $portarray2->[$i] = ($i < 10 ? $port : 0 - $port);

	    if (defined($sshdport) && $port == $sshdport) {
		$portarray1->[$i] = $sshdport;
	    }
	}
	$pnode->_portarray($portarray1);
	$vpnode->_portarray($portarray2);

	# We only set the vpnodes. tmcd sends that to the client.
	DBQueryWarn("update nodes set ipport_low=$newlow, ".
		    " ipport_next=ipport_low+1, ipport_high=$newhigh ".
		    "where node_id='$vpnodename'")
	    or return -1 if (!($self->impotent() || $self->alloconly()));
    }
    return 0;
}

#
# Bump and return the IP port number for a node. This is
# required for multiplexing virtual nodes on a physical node. 
#
sub nextipportnum($)
{
    my ($pnode, $default)  = @_;
    my $portarray = $pnode->_portarray();
    my $port = 0;

    if (!defined($portarray)) {
	#
	# Fall back to simple approach; no shared nodes.
	#
	$port = $pnode->_portnext();
	$pnode->_portnext($port + 2);
	return $port;
    }

    for (my $i = 0; $i < $pnode->_porthigh() - $pnode->_portlow(); $i++) {
	if ($portarray->[$i] < 0) {
	    $port = 0 - $portarray->[$i];
	    $portarray->[$i] = $port;
	    last;
	}
    }
    if (!$port) {
	tberror("No more dynamic ports available for $pnode!\n");
	return -1;
    }
    return $port;
}

#############################################################################
# XML support that will move elsewhere. Note that this code is entirely
# derived from the code that Tarun wrote to convert top files in XML.
# It is currently operating in the same fashion; parsing the text lines
# that are created above. This is silly extra work, but I do not want to
# diverge too far from the original code yet.
#

#
# Creates a child node with name "nodeName" whose parent is "parent"
# in the XML document "document"
#
sub addNodeRspec ($$$)
{
    my ($doc, $root, $name) = @_;
    my $newnode = $doc->createElement($name);
    $root->appendChild($newnode);
    return $newnode;
}

#
# Process a node and emits RSPEC v2
#
sub processNodeRspec ($$$$)
{
    my ($self, $doc, $root, $node) = @_;
    
    # Check if the node has been fixed
    my $fixedto = '';
    foreach my $fixednode (@{$self->rspec()->{'fixed'}}) {
	if ($fixednode->{'vnode'} eq $node->{'virtual_id'}) {
	    $fixedto = $fixednode->{'pnode'};
	    last;
	}
    }

    my $rspecnode = addNodeRspec ($doc, $root, 'node');
    $rspecnode->setAttribute('client_id', $node->{'virtual_id'});
    $rspecnode->setAttribute('component_manager_id', $node->{'manager_urn'});
    if ($fixedto ne '') {
	my ($authority,undef,undef) = GeniHRN::Parse($node->{'manager_urn'});
	$rspecnode->setAttribute('component_id',
			 GeniHRN::Generate($authority, "node", $fixedto));
    }

    my $isnodestatic = $node->{'node_static'};
    my $nodetypename = $node->{'node_type'};
    my $nodetypeslots = $node->{'type_slots'};
    
    # Determine hardware type and sliver type from nodetype
    # The formula for this is to check for the substring "vm" in the type name
    # If the substring is found, the rest of the string becomes the hardware 
    # type and the sliver type is "openvz". If the substring "vm" is not found,
    # the sliver type is "raw-pc" and the type name is the hardware type
    # eg: typename = pcvm600 =>{ hardwaretype = "pc600", slivertype = "openvz"}
    # eg: typename = pc600 => { hardwaretype = "pc600", slivertype = "raw-pc"}
    my $slivertype = "raw-pc";
    my $hardwaretype = $nodetypename;
    my $vmloc = index($nodetypename, "vm");
    if ($vmloc != -1) {
	$slivertype = "openvz";
	$hardwaretype = substr($nodetypename, 0, $vmloc) 
	                 . substr($nodetypename, $vmloc+2); 
    }

    # Create hardware node with Emulab extensions
    my $hardwarenode = addNodeRspec($doc, $rspecnode, 'hardware_type');
    $hardwarenode->setAttribute('name', $hardwaretype);
    my $typecount = addNodeRspec($doc, $hardwarenode, 'emulab:node_type');
    $typecount->setAttribute('type_slots', $nodetypeslots);
    if ($isnodestatic == 1) {
	$typecount->setAttribute('static', 'true');
    }

    # Create sliver type
    my $slivernode = addNodeRspec($doc, $rspecnode, 'sliver_type');
    $slivernode->setAttribute('name', $slivertype);
    my $diskimagenode = addNodeRspec($doc, $slivernode, 'disk_image');

# XXX: This is NOT correct at all. The disk image name should be a URN
# composed of the project name, and the name of the disk image obtained from
# the osinfo structure. It should NOT be the osid. This has been done merely 
# as a placeholder to ensure that the vtop still validates.
    $diskimagenode->setAttribute('name', 'diskimageurn');

    # Deal with the disallow_trivial_mix flag
    if (exists($node->{'disallow_trivial_mix'})) {
	addNodeRspec($doc, $rspecnode, 'emulab:disallow_trivial_mix');
    }

    # Deal with the subnode_of flag
    if (exists($node->{'subnode'})) {
	my $relation = addNodeRspec($doc, $rspecnode, 'relation');
	$relation->setAttribute('type', 'subnode');
	my $subnode = addNodeRspec($doc, $relation, 'emulab:subnode_of');
	$subnode->SetAttribute('parent', $node->{'subnode'});
    }

    # Add interfaces to the node
    foreach my $interface (@{$node->{'interfaces'}}) {
	my $iface = $interface->{'virtual_id'};
	my $fixed = $interface->{'component_id'};
	
	my $interfacedecl = addNodeRspec($doc, $rspecnode, 'interface');
	$interfacedecl->setAttribute('client_id', $iface);
	if (defined($fixed)) {
	    my $fixediface = addNodeRspec($doc, $interfacedecl, 
					  'emulab:fixedinterface');
	    $fixediface->setAttribute('name', $fixed);
	}
    }

    # Add all the desires as extensions
    while ( my ($desire, $desireval) = each (%{$node->{'desires'}})) {
	my $desirenode = addNodeRspec($doc, $rspecnode, 'emulab:fd');
	my $operator = $desireval->[0];
	$desirenode->setAttribute('name', $desire);
	$desirenode->setAttribute('weight', $desireval->[1]);
	if ($desireval->[1] >= 1.000000) {
	    $desirenode->setAttribute('violatable', 'true');
	}
	if ($operator eq "?+") {
	    $desirenode->setAttribute('local_operator', '+');
	}
	elsif ($operator eq "*&") {
	    $desirenode->setAttribute('global_operator', 'FirstFree');
	}
	elsif ($operator eq '*!') {
	    $desirenode->setAttribute('global_operator', 'OnceOnly');
	}
    }
}

sub processLinkRspec ($$$$)
{
# TODO: Deal with fixed interfaces correctly
    my ($self, $doc, $root, $link) = @_;
	
    my $rspeclink = addNodeRspec($doc, $root, 'link');
    $rspeclink->setAttribute('client_id', $link->{'plink'});
    
    my $cmnode = addNodeRspec($doc, $rspeclink, 'component_manager');
    $cmnode->setAttribute('name', $link->{'manager_urn'});

    my $linktype = addNodeRspec($doc, $rspeclink, 'link_type');
    $linktype->setAttribute('name', $link->{'link_type'});

    if (exists ($link->{'nodelay'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:nodelay');
    }
    if (exists($link->{'emulated'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:multiplex_ok');
    }
    if (exists($link->{'trivial_ok'})) {
	addNodeRspec($doc, $rspeclink, 'emulab:trivial_ok');
    }

    # Add the interface refs
    my $interface_ref = addNodeRspec($doc, $rspeclink, 'interface_ref');
    $interface_ref->setAttribute('client_id', $link->{'interface_ref'}->[0]);

    $interface_ref = addNodeRspec($doc, $rspeclink, 'interface_ref');
    $interface_ref->setAttribute('client_id', $link->{'interface_ref'}->[1]);

    # The forward link
    my $property = addNodeRspec($doc, $rspeclink, 'property');
    $property->setAttribute('source_id', $link->{'interface_ref'}->[0]);
    $property->setAttribute('dest_id', $link->{'interface_ref'}->[1]);
    $property->setAttribute('capacity', $link->{'capacity'});
    $property->setAttribute('latency', $link->{'latency'});
    $property->setAttribute('packet_loss', $link->{'packet_loss'});

    # The reverse link
    $property = addNodeRspec($doc, $rspeclink, 'property');
    $property->setAttribute('source_id', $link->{'interface_ref'}->[1]);
    $property->setAttribute('dest_id', $link->{'interface_ref'}->[0]);
    $property->setAttribute('capacity', $link->{'capacity'});
    $property->setAttribute('latency', $link->{'latency'});
    $property->setAttribute('packet_loss', $link->{'packet_loss'});
}

sub processVClassRspec($$$$)
{
    my ($self, $doc, $root, $vclass) = @_;
    my $vclassNode = addNodeRspec($doc, $root, 'emulab:vclass');

    my $name = $vclass->{'name'};
    my $weight = $vclass->{'weight'};

    # XXX: We don't have hard vclass support yet     
    $vclassNode->setAttribute('name', $name);
    $vclassNode->setAttribute('weight', $weight);

    foreach my $physType (@{$vclass->{'members'}}) {
	my $physNode = addNodeRspec($doc, $vclassNode, 'emulab:physical_type');
	$physNode->setAttribute('name', $physType);
    }
}

###############################################################################
# Print the solution as an rspec. 
#
sub addNode($$$)
{
    my ($document, $parent, $nodeName) = @_;
    
    my $newNode = $document->createElement($nodeName);
    $parent->appendChild($newNode);
    return $newNode;
}

sub PrintSolution($$)
{
    my ($self, $output) = @_;
    $output = *STDOUT
	if (!defined($output));

    my $pid = $self->experiment()->pid();
    my $eid = $self->experiment()->eid();

    my $doc = XML::LibXML::Document->new();

    my $root = $doc->createElement("rspec");
    $root->setAttribute("pid", "$pid");
    $root->setAttribute("eid", "$eid");
    $root->setAttribute("xmlns:rspec",
			"http://www.protogeni.net/resources/rspec/0.1");
    $doc->setDocumentElement($root);

    foreach my $pnodename (keys(%{ $self->solution_p2v() })) {
	my @vnodenames = @{ $self->solution_p2v()->{$pnodename} };
	my $pnode = $self->pnodes()->{$pnodename};

	foreach my $vnodename (@vnodenames) {
	    my $vnode   = $self->vnodes()->{$vnodename};
	    my $newNode = addNode($doc, $root, "node");

	    if (defined($vnode) && $vnode->_isvirtnode()) {
		$pnode = $vnode->_pnode();
	    }
	    
	    $newNode->setAttribute("virtual_id", $vnodename);
	    $newNode->setAttribute("component_uuid", $pnode->uuid());
	}
    }
    foreach my $virtlan (values(%{ $self->vlans() })) {
	my $vlanname = $virtlan->vname();

	my $newLink = addNode($doc, $root, "link");
	$newLink->setAttribute("virtual_id", $vlanname);
	    
	foreach my $member ($virtlan->memberlist()) {
	    # Will this happen?
	    next
		if (!exists($self->solution_portmap()->{$member}));
		
	    my $vnode  = $member->vnode();
	    my $vport  = $member->vport();
	    my $pport  = $member->_pport();

	    my $newMember = addNode($doc, $newLink, "interface_ref");
	    $newMember->setAttribute("virtual_node_id", $vnode);
	    $newMember->setAttribute("virtual_port_id", $vport);
	    #
	    # XXX Ignore for now. Need to fix.
	    #
	    $newMember->setAttribute("component_id", $pport)
		if (defined($pport));
	}
    }
    print $output $doc->toString(1) . "\n";

    return 0;
}

#
# Little helper routine to map a vname to the physnode. See libGeni.
#
sub VnameToNode($$)
{
    my ($self, $vname) = @_;
    my $nodeid;

    if (exists($self->solution_v2v()->{$vname})) {
	$nodeid = $self->solution_v2v()->{$vname};
    }
    elsif (exists($self->solution_v2p()->{$vname})) {
	$nodeid = $self->solution_v2p()->{$vname};
    }
    return undef
	if (!defined($nodeid));

    return Node->Lookup($nodeid);
}

#
# A switchpath is "SW1:SW2 SW2:SW3 ..." This function takes an
# existing path, and adds new ones from the list, while watching for
# duplicates.  We assume the new path is already unique since it came
# right out of assign. Note that assign might spit out either SW1:SW2
# or SW2:SW1, so have to watch for that too.
#
sub AddToSwitchPath($$)
{
    my ($cur, $new) = @_;

    return $new
	if (!defined($cur));

    my @cur = split(" ", $cur);
    my @new = split(" ", $new);
    foreach my $n (@new) {
	my ($s1,$s2) = split(":", $n);

	push(@cur, $n)
	    if (! ((grep {$_ eq $n} @cur) ||
		   (grep {$_ eq "$s2:$s1"} @cur)));
    }
    return join(" ", @cur);
}

1;
