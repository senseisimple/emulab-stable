#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;

# XXX: handle error cases for update? (backup the db?)
# XXX: Shouldn't do idempotent stuff twice for update.
# XXX: repush/calc routing for update??? (tbprerun)
# XXX: previz for update???              (tbprerun)
# XXX: make snmpit faster for update.
#
# XXX: for update, expt is swapped out on os_setup fail.
#      (we only recover if assign fails)

sub usage()
{
    print STDERR "Usage: $0 { in | out [-force] | update [-reboot] } pid eid\n";
    exit(-1);
}

#
# Configure variables
#
my $TBROOT         = "@prefix@";
my $TESTMODE       = @TESTMODE@;
my $DISABLE_EVENTS = "@DISABLE_EVENT_SCHED@";

# Untaint the path
$ENV{'PATH'} = "/usr/bin:$TBROOT/libexec:$TBROOT/libexec/ns2ir" . 
    ":$TBROOT/sbin:$TBROOT/bin";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;
require exitonwarn; # exitonwarn isn't really a module, so just require it

#
# Actual swap-in and swap-out functions, defined below.
#
sub doSwapout($);
sub doSwapin($);

sub REAL()    { return 4; }
sub CLEANUP() { return 3; }
sub RETRY()   { return 2; }
sub UPDATE()  { return 1; }
sub UPDATE_RECOVER()  { return 0; }

#
# Turn off line buffering on output
#

$| = 1;

my $updateReboot = 0;
my $force  = 0;
my $errors = 0;
my $assignWrapperErrorCode = 0;

my $state;

my $os_setup_pid;
my $cleanvlans;

#
# First argument is either "in", "out", or "update";
# this value goes into $swapop.
#

my $swapop = shift;	

if (!$swapop || 
    (($swapop ne "in") && 
     ($swapop ne "out") &&
     ($swapop ne "update"))) {
    usage();
}

#
# Get other arguments.
#

while ($#ARGV > 1) {
    $arg = shift;
    if ($arg eq "-force") {
	$force = 1;
    } elsif ($arg eq "-reboot") {
	$updateReboot = 1;
    } else {
	usage();
    }
}
if ($#ARGV < 1) {
    usage();
}
my ($pid,$eid) = @ARGV;

TBDebugTimeStampsOn();

#
# Print starting message.
#

print "Beginning swap-$swapop for $pid/$eid. " . TBTimeStamp() . "\n";
TBDebugTimeStamp("tbswap $swapop started");

#
# Get experiment state; verify that experiment exists.
#

if (! ($state = ExpState($pid, $eid))) {
    print STDERR "*** No such experiment $pid/$eid\n";
    $errors = 1;
}

#
# Figure out which state we're looking for 
# and which state we're going to set according to the operation.
#

my $desiredState;
my $nextState;
my $suggestion;
my $suggestUseOfForce;

if ($swapop eq "in") {
    $desiredState = EXPTSTATE_SWAPPED;
    $nextState    = EXPTSTATE_ACTIVATING;
    $suggestion   = "Must be swapped out.";
    $suggestUseOfForce = 0;
} elsif ($swapop eq "out") {
    if (! $TESTMODE) {
	$desiredState = EXPTSTATE_ACTIVE;
	$suggestion   = "Must be running.";
    } else {
	$desiredState = EXPTSTATE_TESTING;
	$suggestion   = "Must be in testing state.";
    }
    $nextState    = EXPTSTATE_SWAPPING;
    $suggestUseOfForce = 1;
} elsif ($swapop eq "update") {
    $desiredState = EXPTSTATE_ACTIVE;
    $nextState    = EXPTSTATE_ACTIVATING; # XXX add an updating state?
    $suggestion   = "Must be running.";
    $suggestUseOfForce = 0;
}

#
# Check that experiment is in correct state.
# If it is not, print appropriate error message.
#

if (! $errors) {
    if ($state ne $desiredState) {
	if (! $force) {
	    if ($state eq EXPTSTATE_SWAPPED) {
		print STDERR "*** Experiment is already swapped out. $suggestion\n";
	    } elsif ($state eq EXPTSTATE_ACTIVE) {
		print STDERR "*** Experiment is already running. $suggestion\n";
	    } else {
		print STDERR "*** Experiment is in the wrong state: $state. $suggestion\n";
	    }
	    if ($suggestUseOfForce) {
		print STDERR "    Try using -force to ignore improper state.\n";
	    }
	    $errors = 1;
	} else {
	    print STDERR "*** WARNING: Ignoring improper state: $state.\n";
	}
    }
}

#
# Set intermediate experiment state.
#

if (! $errors) {
    if (! SetExpState($pid, $eid, $nextState)) {
	print STDERR "*** Failed to set intermediate experiment state.\n";
	$errors = 1;
    }
}

#
# Do actual swapping
#

undef $nextState;

if (! $errors) {
    if ($swapop eq "out") {
	#
	# Swap out
	#
	$errors = doSwapout(REAL);
	if (! $errors) {
	    $nextState = EXPTSTATE_SWAPPED;
	} else {
	    # leave $nextState undefined
	    # experiment will stay in SWAPPING.
	}

	#
	# Update Accounting Information
	#
	TBSetExpSwapTime($pid, $eid);
    }
}

#
# Update, Phase One -- swap experiment partially out.
#
if (! $errors) {
    if ($swapop eq "update") {
	print STDERR "Backing up physical state...\n";
	TBExptBackupPhysicalState($pid,$eid,$$);

	$errors = doSwapout(UPDATE);
	if (! $errors) {
	    # leave $nextState undefined. 
	    # (this will get defined below.)
	} else {
	    # Error; Clean up and put experiment in SWAPPED.
	    print STDERR "Cleaning up after errors.\n";
	    doSwapout(CLEANUP);
	    $nextState = EXPTSTATE_SWAPPED;
	}
	
	#
	# Update Accounting Information
	#
	TBSetExpSwapTime($pid, $eid);
    }
}

#
# Update, Phase Two -- swap experiment back in.
#
if (! $errors) { 
    if ($swapop eq "update") {
	#
	# Update
	#
	$errors = doSwapin(UPDATE);

	if (! $errors) {
	    #
	    # Update Accounting Information
	    #
	    TBSetExpSwapTime($pid, $eid);

	    #
	    # Swapin worked; exp is now ACTIVE.
	    # (or TESTING) 
	    #
	    if ($TESTMODE) {
		$nextState = EXPTSTATE_TESTING;
	    } else {
		$nextState = EXPTSTATE_ACTIVE;
	    }
	} else {
	    #
	    # There were errors; see if we can recover.
	    #
	    my $canStillRecover = 1;

	    if ($errors != 7) {
		print STDERR "Update failure occurred _after_ assign phase; ";
		$canStillRecover = 0;
	    }

	    if ($canStillRecover) {
		print STDERR "Recovering physical state...\n";
		my $recoverErrors = TBExptRestorePhysicalState($pid,$eid,$$);
		if ($recoverErrors) {
		    print STDERR "Could not restore backed-up physical state; ";
		    $canStillRecover = 0;
		}
	    }

	    if ($canStillRecover) {
		print STDERR "Doing a recovery swap-in of old state...\n";
		$recoverErrors = doSwapin(UPDATE_RECOVER);
		if ($recoverErrors) {
		    print STDERR "Could not swap in old physical state; ";
		    $canStillRecover = 0;
		}
	    }

	    if ($canStillRecover) {
		print STDERR "Update recovery successful.\n";
		$nextState = EXPTSTATE_ACTIVE;
	    } else {
		print STDERR "update recovery aborted!\n".
		             "Swapping experiment out...\n";
		doSwapout(CLEANUP);

		$nextState = EXPTSTATE_SWAPPED;
	    }
	}
    }
}

if (! $errors) {
    if ($swapop eq "in") {
	#
	# Swap in
	#
	$errors = doSwapin(REAL);

	my $retries = 2;

	#
	# Attempt a retry if: 
	#   a) there were errors, 
	#   b) doswapin() indicated (via return code 3) a retry is appropriate,
	#   c) we haven't tried too many times already.
	#
	# NOTE that if $TESTMODE == 1, retries are impossible, since
        # $retry will never get set to 1.
	#
	while ($errors == 3 && $retries ) {
	    $retries--;

	    print STDERR "Cleaning up after errors; will try again.\n";
	    doSwapout(RETRY);

	    print STDERR "Trying again...\n";
	    $errors = doSwapin(RETRY);
	}

	if (! $errors) {
	    #
	    # Update Accounting Information
	    #
	    TBSetExpSwapTime($pid, $eid);

	    #
	    # Swapin worked; exp is now ACTIVE.
	    # (or TESTING)
	    #
	    if ($TESTMODE) {
		$nextState = EXPTSTATE_TESTING;
	    } else {
		$nextState = EXPTSTATE_ACTIVE;
	    }
	} else {
	    print STDERR "Cleaning up after errors.\n";
	    doSwapout(CLEANUP);

	    #
	    # Regardless of how well cleanup swapout worked,
	    # send exp to SWAPPED.
	    #
	    $nextState = EXPTSTATE_SWAPPED; 
	}
    }
}

if (defined $nextState) {
    if (! SetExpState($pid, $eid, $nextState)) {
	print STDERR "*** Failed to set experiment state.\n";
	#
	# Don't obliterate a meaningful error code if this happens.
	#
	if (! $errors) { $errors = 1; }
    }
}

#
# Write appropriate message and exit.
#

if ($errors) {
    print "Failingly finished swap-$swapop for $pid/$eid. " . TBTimeStamp() . "\n";
    TBDebugTimeStamp("tbswap $swapop finished (failed)");

    # pass this info along.
    $errors |= $assignWrapperErrorCode;
} else {
    print "Successfully finished swap-$swapop for $pid/$eid. " . TBTimeStamp() . "\n";
    TBDebugTimeStamp("tbswap $swapop finished (succeeded)");
}

exit($errors);

#################################

##
#
# doSwapout - Swaps experiment out.
#
#             If in REAL or CLEANUP,
#             this function will free all nodes for the 
#             experiment.
#
#             If in RETRY or UDPATE,
#             only nodes not in RES_READY will be freed.
#
#             Returns 0 on success, >0 on failure.
#
##

sub doSwapout($) {
    my $type = shift; # REAL==4, CLEANUP==3, RETRY==2, UPDATE==1.
    my $swapout_errors = 0;

    #
    # wait for os_setup;
    # this only applies if called after a failed doswapin.
    #
    if ($os_setup_pid) {
	print "Waiting for os_setup to finish\n";
	waitpid($os_setup_pid, 0);
	undef $os_setup_pid;
    }

    if (! $TESTMODE) { 
	if (! $DISABLE_EVENTS) {
	    if ($type >= RETRY) {
		print "Stopping the event system\n";
		if (system("eventsys_control stop $pid $eid")) {
		    print STDERR "*** Failed to stop the event system.\n";
		    $swapout_errors = 1;
		}
	    }
	}

	#
	# Clean up any VLANs in experiment.
	#
	TBDebugTimeStamp("snmpit started");
	print STDERR "Removing VLANs.\n";
	if (system("snmpit -r $pid $eid")) {
	    print STDERR "*** Failed to reset VLANs\n";
	    $swapout_errors = 1;
	} else {
	    $cleanvlans = 0;
	}
	TBDebugTimeStamp("snmpit finished");

	#
	# This is a hack. We need a more general os_teardown, but for now
	# we just kill off the vnode stuff. 
	# (don't kill off vnodes when UPDATEing.)
	#
	if ($type >= RETRY) {
	    print "Tearing down virtual nodes.\n";
	    TBDebugTimeStamp("vnode_setup -k started");
	    if (system("vnode_setup -d -k $pid $eid")) {
		print STDERR "*** Failed to tear down vnodes.\n";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("vnode_setup finished");
	}
    }

    if ($type >= CLEANUP) {
	#
	# We're not attempting a retry; 
	# remove all nodes from the experiment.
	# (nfree will send them to RES_FREE_DIRTY)
	#
	print STDERR "Freeing nodes.\n";
	TBDebugTimeStamp("nfree started");
	if (system("nfree $pid $eid")) {
	    print STDERR "*** Could not free nodes.\n";
	    $swapout_errors = 1;
	}
	TBDebugTimeStamp("nfree finished");

	#
	# Since this is an actual swapout, 
	# reset our count of swap out nag emails sent.
	#
	DBQueryWarn("update experiments set swap_requests='' ".
		    "where eid='$eid' and pid='$pid'");
    } else {
	#
	# $type == RETRY or $type == UPDATE.
	# Therefore, don't deallocate nodes which have been successfully
	# incorporated into the experiment (i.e., are RES_READY).
	# (nfree will send deallocated nodes to RES_FREE_DIRTY)
	#

	my @failedNodes = ();
	print STDERR "Freeing failed nodes.\n";
	$db_result =
	    DBQueryFatal("select rv.node_id, n.allocstate ".
                         "from reserved as rv ".
			 "left join nodes as n on ".
			 "n.node_id = rv.node_id ".
			 "where rv.pid='$pid' and rv.eid='$eid'");

	while (($node,$allocstate) = $db_result->fetchrow_array) {
	    if ($allocstate ne TBDB_ALLOCSTATE_RES_READY()) {
		push(@failedNodes, $node);
	    }
	}

	# XXX reboot nodes [e.g., put them in RES_DIRTY()] 
	# if doing an update -restart.

	if (@failedNodes > 0) {
	    TBDebugTimeStamp("nfree started");
	    #
	    # Specify -x switch so when a physical node gets freed,
	    # any virtual nodes (owned by this experiment)
	    # sitting on top of it are freed as well.
	    #
	    if (system("nfree -x $pid $eid " . join(" ", @failedNodes))) {
		print STDERR "*** Could not free nodes.\n";
		$swapout_errors = 1;
	    }
	    TBDebugTimeStamp("nfree finished");
	}
    }

    if (! $TESTMODE) {
	#
	# All of these errors are non-fatal on swapout. We find out about them
	# via email sent from the individual scripts.
	#

	#
	# Only reset mountpoints if this is an actual swapout, and
	# not a failed swapin(cleanup), update, or retry.
	#
	if ($type == REAL) {
	    print "Resetting mountpoints.\n";
	    TBDebugTimeStamp("exports started");
	    if (system("exports_setup")) {
		print STDERR "*** Failed to reset mountpoints.\n";
	    }
	    TBDebugTimeStamp("exports finished");
	}

	#
	# Resetting named maps and email lists is fast and idempotent,
	# so whatever.
	#
	print "Resetting named maps.\n";
	TBDebugTimeStamp("named started");
	if (system("named_setup")) {
	    print "*** WARNING: Failed to reset named map.\n";
	}
	TBDebugTimeStamp("named finished");

	print "Resetting email lists.\n";
	TBDebugTimeStamp("genelists started");
	if (system("genelists")) {
	    print "*** WARNING: Failed to reset email lists.\n";
	}
	TBDebugTimeStamp("genelists finished");
    }

    #
    # Wipe the DB clean.
    #

    print STDERR "Resetting DB.\n";
    TBExptRemovePhysicalState( $pid, $eid );

    return $swapout_errors;
}

##
#
# doSwapin - Swaps experiment in.
#
#            Returns:
#              0 - successful swapin
#              1 - failed swapin; cleanup required.
#              3 - failed swapin; cleanup required; can retry.
#              7 - failed swapin; assign failed; no cleanup.
#
#            Will set $retry = 1 if os_setup failed.
#
##

sub doSwapin($) {
    my $type = shift; # REAL==4, RETRY==2, UPDATE==1, UPDATE_RECOVER=0. 

    #
    # assign_wrapper does all the virtual to physical mapping 
    # and updating the DB state.
    #

    if ($type > UPDATE_RECOVER) {
	print "Mapping to physical reality ...\n";
	TBDebugTimeStamp("assign_wrapper started");

	#
	# Pass the -u (update) switch into assign_wrapper,
	# So any nodes already in the experiment are
	# fixed.
	#
	my $exitcode;
	if ($exitcode = system("assign_wrapper -u $pid $eid")) {
	    print STDERR "*** Failed to map to reality.\n";

	    #
	    # save this off so it will get passed back later.
	    #
	    $assignWrapperErrorCode = $exitcode;
	    if ((($exitcode >> 8) & 64) != 0) {
		# so batchexp doesn't choke.
		$assignWrapperErrorCode -= 64;
		return 7;
	    } else {
		return 1;
	    }
	}
	TBDebugTimeStamp("assign_wrapper finished");

	print "Mapped to physical reality!\n";
    }

    # Exit here if we are testing.
    if ($TESTMODE) {
	print "Testing run - Stopping here.\n";
	return 0;
    }

    #
    # These things need to get started before the nodes come up, so we'll
    # do them before the os_setup. Everything else can done in parallel with
    # os_setup. (Actually, these probably can too, since they should finish
    # long before the nodes reboot, but better safe than sorry)
    #
    print "Setting up mountpoints.\n";
    TBDebugTimeStamp("mountpoints started");
    if (system("exports_setup")) {
	print STDERR "*** Failed to setup mountpoints.\n";
	return 1;
    }
    TBDebugTimeStamp("mountpoints finished");

    TBDebugTimeStamp("named started");
    print "Setting up named maps.\n";
    if (system("named_setup")) {
	print STDERR "*** WARNING: Failed to add node names to named map.\n";
	#
	# This is a non-fatal error.
	#
    }
    TBDebugTimeStamp("named finished");


    #
    # If user specified -reboot to update,
    # then mark all nodes in experiment
    # so os_setup will reboot them.
    #
    if (($type == UPDATE ||
         $type == UPDATE_RECOVER) && $updateReboot) {
	print STDERR "Marking nodes for reboot.\n";
	$db_result =
	    DBQueryFatal("select rv.node_id ".
                         "from reserved as rv ".
			 "left join nodes as n on ".
			 "n.node_id = rv.node_id ".
			 "where rv.pid='$pid' and rv.eid='$eid'");

	while (($node) = $db_result->fetchrow_array) {
	    TBSetNodeAllocState( $node, TBDB_ALLOCSTATE_RES_INIT_DIRTY() );
	}
    }

    #
    # Since it'll take a while for the nodes to reboot, we'll start now, and
    # wait for the os_setup to finish, down below
    #
    print "Resetting OS and rebooting.\n";
    TBDebugTimeStamp("os_setup started");
    if (!($os_setup_pid = fork())) { 
	exec("os_setup $pid $eid") or return 1;
    } elsif ($os_setup_pid == -1) {
	print STDERR "*** Fork failed.\n";
	return 1;
    }

    #
    # XXX: Don't add any steps between here and the waitpid() call below without
    # verifying that 1) It's OK for nodes to come up before the step has
    # completed and 2) It's OK for the command to run in parallel with os_setup
    # (no DB dependencies, etc.)
    #

    print "Setting up VLANs.\n";
    TBDebugTimeStamp("snmpit started");
    if (system("snmpit -t $pid $eid")) {
	print STDERR "*** Failed to set up VLANs.\n";
	return 1;
    }
    TBDebugTimeStamp("snmpit finished");

    #
    # An error now means that the VLANS need to be cleaned up.
    #
    $cleanvlans = 1;

    print "Setting up email lists.\n";
    TBDebugTimeStamp("genelists started");
    if (system("genelists")) {
	print STDERR "*** WARNING: Failed to update email lists.\n";
	#
	# This is a non-fatal error.
	# 
    }
    TBDebugTimeStamp("genelists finished");

    #
    # Don't clear port counters on UPDATE.
    # (XXX should clear new nodes' port counters.)

    if ($type >= RETRY) {
	print "Clearing port counters.\n";
	TBDebugTimeStamp("portstats started");
	if (system("portstats -z -a -q $pid $eid")) {
	    print STDERR "*** WARNING: Failed to clear port counters.\n";
	    #
	    # This is a non-fatal error.
	    # 
	}
	TBDebugTimeStamp("portstats finished");
    }

    #
    # OK, let's see how that os_setup did
    #
    $kid = waitpid($os_setup_pid,0);
    if ($kid == $os_setup_pid) {
	undef $os_setup_pid; # Make sure doswapout() doesn't wait for it.
	if ($CHILD_ERROR) {
	    print STDERR "*** Failed to reset OS and reboot nodes.\n";
	    #
	    # Use returncode from os_setup process to
	    # set global $retry flag, indicating to caller
	    # that it may be beneficial to attempt
	    # a doSwapin() again.
	    #
            if (($CHILD_ERROR >> 8) == 1) {
		return 3;
	    } else {
		print STDERR "Not retrying due to error type.\n";
		return 1;
	    }
	}
    } else {
	undef $os_setup_pid;
	print STDERR "*** Error waiting for os_setup to finish.\n";
	return 1;
    }
    TBDebugTimeStamp("os_setup finished");

    #
    # Okay, start the event system now that we know all the nodes have
    # rebooted (os_setup is done). This only takes a moment (puts itself
    # in the background), so its not enough of a delay to worry about.
    # Don't do this during an update, since we didn't kill the 
    # event system previously, so starting it again will fail!
    # 
    if (! $DISABLE_EVENTS) {
	if ($type != UPDATE && $type != UPDATE_RECOVER) {
	    print "Starting the event system.\n";
	    TBDebugTimeStamp("eventsys_control started");
	    if (system("eventsys_control start $pid $eid")) {
		print STDERR "*** Failed to start the event system.\n";
		return 1;
	    }
	    TBDebugTimeStamp("eventsys_control finished");
	}
    }

    return 0;
}
