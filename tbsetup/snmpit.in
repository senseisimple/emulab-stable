#!/usr/bin/perl -w
#
# EMULAB-LGPL
# Copyright (c) 2000-2009 University of Utah and the Flux Group.
# All rights reserved.
#

#
# snmpit - A tool for setting up VLANs on SNMP-controllable switches
#

#
# Configure variables
#

use lib '@prefix@/lib';
my $TESTMODE   = @TESTMODE@;
my $ELABINELAB = @ELABINELAB@;
my $NOSTACKMIB = @NOSTACKMIB@;
my $TB = '@prefix@';

use libdb;
use User;
use Experiment;
use snmpit_lib;
use snmpit_remote;
use libtblog;

use English;
use Getopt::Long;
use strict;

# Protos
sub parseStatusString($);
sub debug($);
sub doListVlans($);
sub doListPorts($);
sub doPortStatus($@);
sub doGetStats($);
sub doVlansFromTables($$@);
sub syncVlansFromTables($$);
sub doReset($@);
sub doMakeVlan($$@);
sub doDeleteVlan($@);
sub doVlanNumber($$);
sub doPortControl($$@);
sub doRecreateVlans($);
sub doTrunkEnable($$$@);
sub doTrunkDisable($$);
sub doRestorePortStatus($@);
sub doSynchLeader($);
sub CreateOneVlan($$@);

#
# Defaults
#
my $debug = 0;
my $quiet = 0;

######################################################################
# Step 1 - Process command-line arguments
#
# We have a fairly complex set of command line arguments, and we
# need to make sure that the user only specifies one command at a
# time.
######################################################################
sub usage {
    print << "END";
Usage: $0 [-h] [-v level] [-q] [-n] [-i device] [-S stack]
	  [-l] [-s] [-g] [-O]
	  [-m name pid eid [ports]]
	  [-T port name]
	  [-U port]
	  [-o name pid eid]
          [-N name]
          [-r pid eid]
	  [-t pid eid]
	  [-d ports] [-e ports] [-a ports]
	  [-p <10|100|1000> ports] [-u <half|full> ports]
	  [-c]
General:
  -h          Display this help message
  -v <level>  Verbose mode
  -q          Quiet mode
  -n          Test mode - don't actually make any changes
  -i <device> Operate on <device>, overriding default device list. Can be
                  given multiple times
  -S <stack>  Operate on the given stack, instead of the default of the
                  experimental network

VLAN Control:
  -t <pid> <eid>    Create all VLANs for an experiment
  -r <pid> <eid>    Remove all VLANs for an experiment
                        (you can provide an optional list of vlan ids)
  -l                List all VLANs associated with experiments.
                        A second -l will list ALL vlans.
  -w                Used with -l, includes device-specific VLAN number
  -M                Used with -l, print MAC addresses instead of port numbers
  -O                Used with -l, list only orphaned VLANs
  -L <out#in[,o2#i2,...]> stylized -l for snmpit.proxy of specific vlans
  -m <name> <pid> <eid> [ports]
                    Create a new VLAN with name <name>, if it doesn't exist,
                        and put [ports] in it. The new VLAN will be
                        associated with the priject and experiment given
  -y <type>         When used with -m, the new VLAN becomes a private VLAN
                        of type <type>
  -x <primary>      When used with -y, assocates the new private VLAN with
                        the primary VLAN named <primary>
  -z <port>         Used with -y and -x, to specify which port is to be used
                        with the private VLAN
  -o <name> <pid> <eid>
                    Delete the VLAN with name <name>, which is associated with
                        the given experiment
  -N <name>         Print out the VLAN number for the named VLAN
  -c                Delete ALL VLANs, and recreate from the database. ** USE
                        WITH EXTREME CAUTION **
  -F                Create all vlans in the given stack on the leader for
		    use in leader->{ALLVLANSONLEADER} (Internal use only)

Port Control:
  -s                     List all ports, and show configuration information
  -g                     Get port statistics
  -d <ports>             Disable <ports>
  -e <ports>             Enable <ports>
  -a <ports>             Enable auto-negotiation of port speed/duplex
  -p <10|100> <ports>    Set speed of <ports> to 10 or 100 Mbps
  -u <half|full> <ports> Set duplex of <ports> to half or full
  -T <port> <names>      Enable trunking on the given <port>, and allow VLANs
                             with the given <names> across it
  -E <port> <names>      Like -T, but "Equal" mode; PVID is also tagged
  -U <port>              Turn off trunking for the given <port>
  -b <ports>             Print out port status for a set of ports
  -B <statstring>        Pass in a stat string from -b to restore status
  -D <pid> <eid>         Disable all control net ports for an experiment
  -R <pid> <eid>         (Re)enable all control net ports for an experiment

More than one operation can be specified - However, beware that the order in
which operations will occur is undefined, and some combinations of operations
(ie. -d and -e) are non-sensical.
END

    return 1;
}


my %opt = ();
Getopt::Long::Configure("no_ignore_case");
GetOptions(\%opt,
    'a','c','d','e','b','B=s@','g','h','i=s@','l+','m=s@','M','n',
    'N=s@','o=s@','p=s','q','r','s', 'S=s@','t','E=s','T=s','u=s','U','v=s','w',
    'y=s','x=s','z=s','F','L=s','O', 'D', 'R', 'f', 'X');
# Unused: f,j

if ($opt{h}) {
    exit &usage;
}

if ($opt{v}) {
    $debug = $opt{v};
    print "Debug level is $debug\n";
}

if ($opt{q}) {
    $quiet = 1;
}

#
# Values that may have been passed on the command line
#
my $pid;
my $eid;
my $experiment;
my @ports;
my @optvlanids = ();
my $equaltrunking = 0;
my $this_user;

#
# Verify user and get his DB uid for later. 
#
if ($UID) {
    $this_user = User->ThisUser();
    if (! defined($this_user)) {
	die("*** $0:\n".
	    "    You ($UID) do not exist!\n");
    }
}

#
# Some operations have mandatory agruments - for others, make sure that
# the user didn't give any extraneous arguments
#
if ($opt{m} || $opt{o}) {
    if (@ARGV < 2 ||
	($opt{m} && ($ARGV[0] =~ /:/ || $ARGV[1] =~ /:/)) ||
	($opt{o} && ($ARGV[0] =~ /^\d+$/ || $ARGV[1] =~ /^\d+$/))) {
	if (! $opt{f}) {
	    tberror "pid/eid reqired!";
	    exit(usage());
	}
    }
    else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
}
if ($opt{t} || $opt{r} || $opt{D} || $opt{R} || $opt{X}) {
    #
    # Options that take 'pid eid'
    #
    if (@ARGV < 2) {
	tberror "pid/eid reqired!";
	exit &usage;
    } else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
    if (@ARGV) {
	@optvlanids = @ARGV;
    }
} elsif ($opt{d} || $opt{e} || $opt{a} || $opt{p} || $opt{u} || $opt{m}
         || $opt{U} || $opt{b}) {
    #
    # Options that take a list of ports
    #
    @ports = @ARGV;
} elsif ($opt{T} || $opt{E}) {
    #
    # Options that take both a port and a list of VLANs - we require at least
    # one VLAN to be given
    #
    if ($opt{E}) { $opt{T} = $opt{E}; $equaltrunking = 1;}
    elsif (!@ARGV) {
	tberror "At least one VLAN required";
	exit &usage;
    }
    @optvlanids = @ARGV;

    #
    # Set the @ports array so that we'll do proper permission checking on it
    #
    @ports = ($opt{T});
} else {
    #
    # Everything else
    #
    if (@ARGV) {
	tberror({type => 'primary', severity => SEV_ERROR,
		 error => ['too_many_arguments']},
		"Too many arguments!");
	exit &usage;
    }
}

#
# Determine which operation we're performing. This is just for convenience,
# so that we can use switch-like constructs later. While we're at it, we
# pull out any arguments that were given in the $opt{} values.
#
my @commands;

#
# Simple commands
#
if ($opt{l}) { push @commands, ["listvlans"]; }
if ($opt{L}) { push @commands, ["listvlans"]; }
if ($opt{s}) { push @commands, ["listports"]; }
if ($opt{g}) { push @commands, ["getstats"]; }
if ($opt{t}) { push @commands, ["tables"]; }
if ($opt{r}) { push @commands, ["reset"]; }
if ($opt{X}) { push @commands, ["synctables"]; }
if ($opt{c}) { push @commands, ["recreate"]; }
if ($opt{U}) { push @commands, ["trunkdisable"]; }
if ($opt{b}) { push @commands, ["portstatus"]; }
if ($opt{F}) { push @commands, ["synchleader"]; }

#
# Commands that can appear once, and take an argument
#
if ($opt{d}) { push @commands, ["portcontrol","disable"]; }
if ($opt{e}) { push @commands, ["portcontrol","enable"]; }
if ($opt{a}) { push @commands, ["portcontrol","auto"]; }
if ($opt{D}) { push @commands, ["expcnetcontrol", "disable"]; }
if ($opt{R}) { push @commands, ["expcnetcontrol", "enable"]; }
if ($opt{T}) { push @commands, ["trunkenable", $opt{T}]; }

#
# Commands that can occur more than once
#
if ($opt{m}) {
    foreach my $name (@{$opt{m}}) {
	push @commands, ["make",$name];
    }
}

if ($opt{o}) {
    foreach my $name (@{$opt{o}}) {
	push @commands, ["remove",$name];
    }
}

if ($opt{N}) {
    foreach my $name (@{$opt{N}}) {
	push @commands, ["vlannumber",$name];
    }
}

if ($opt{B}) {
    foreach my $statstring (@{$opt{B}}) {
	push @commands, ["restorestatus",$statstring];
        # Set up the @ports variable so that we get permissions checking. Note,
        # though, that we re-parse the strings again later, this is just for
        # permissions
        my %args = parseStatusString($statstring);
        if (!$args{port}) {
            tbdie "No port given in status string";
        }
        if ($args{port}) {
            push @ports, convertPortsFromIfaces($args{port});
        }
    }
}

#
# Commands that require 'translation' of their arguments
#
if ($opt{p}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{p} =~ /^1000/) {
	push @commands, ["portcontrol","1000mbit"];
    } elsif ($opt{p} =~ /^100/) {
	push @commands, ["portcontrol","100mbit"];
    } elsif ($opt{p} =~ /^10/) {
	push @commands, ["portcontrol","10mbit"];
    } else {
	tbreport(SEV_ERROR, 'bad_data', 'port_speed', $opt{p});
	die "Bad port speed: $opt{p}. Valid values are 10, 100, and 1000\n";
    }
}
if ($opt{u}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{u} =~ /half/) {
	push @commands, ["portcontrol","half"];
    } elsif ($opt{u} =~ /full/) {
	push @commands, ["portcontrol","full"];
    } else {
	die "Bad port duplex: $opt{u}. Valid values are full and half\n";
    }
}

if (!@commands) {
    tbreport(SEV_ERROR, 'no_operation');
    die "No operation given\n";
}

#
# Options that affect other commands
#

#
# User-supplied switch lists
#
my @supplied_switches = ();
my @supplied_stacks = ();
my $supplied_switches = 0; # Whether -i or -S was given
if ($opt{i}) {
    $supplied_switches = 1;
    push @supplied_switches, @{$opt{i}};
}
if ($opt{S}) {
    foreach my $stack (@{$opt{S}}) {
	if ($ELABINELAB) {
	    # We are going to pass the stack argument through in the rpc call.
	    push(@supplied_stacks, $stack);
	}
	else {
	    $supplied_switches = 1;
	    my @switches = getSwitchesInStack($stack);
	    if (@switches) {
		push @supplied_stacks, $stack;
	    } else {
		tbdie({type => 'primary', severity => SEV_ERROR,
		       error => ['invalid_switch_stack', $stack]},
		      "No such switch stack: $stack");
	    }
	}
    }
}

#
# Arguments for making private VLANs
#
# Build up a list of extra arguments to be passed to createVlan()
my @pvlanArgs = ();
if ($opt{y}) {
    #
    # Make sure the private VLAN type they gave is valid, and make sure they
    # gave the other required arugments for certain types
    #
    if ($opt{y} ne "primary" && $opt{y} ne "isolated" &&
	$opt{y} ne "community") {
	die "Unknown private VLAN type $opt{y}\n";
    }
    @pvlanArgs = $opt{y};
    if ($opt{y} ne "primary") {
	if (!$opt{x} || !$opt{z}) {
	    tberror "-x and -z must be given when -y is $opt{y}!";
	    exit &usage;
	}
	#
	# Fix up ports given in the module/port format, like we do below for
	# ports from @ARGV
	#
	if ($opt{z} =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$opt{z} = $opt{i}->[0] . "." . $opt{z};
	    } else {
		tbdie "The module/port format is only legal if exactly one -i " .
		    "argument has been given";
	    }
	}
	push @pvlanArgs,$opt{x},$opt{z};
    }
}

######################################################################
# Step 3 - Set up the stack objects
#
# Determine which devices to talk to, and make the appropriate
# stack objects
######################################################################

#
# If this is an operation on an experiment, make sure that they have permission
# to modify that experiment
#
if ($pid && $eid) {
    #
    # First, make sure the experiment exists
    #
    $experiment = Experiment->Lookup($pid,$eid);
    if (!defined($experiment)) {
	die "There is no experiment $eid in project $pid\n";
    }
    if (defined($this_user) &&
	!$experiment->AccessCheck($this_user, TB_EXPT_MODIFY)) {
	die "You do not have permission to modify experiment $pid/$eid\n";
    }
}

#
# If their operation involves a set of ports, make sure that the caller has
# access to the nodes that the ports are on
#

# Convert ports into the correct format
if (@ports) {
    @ports = convertPortsFromIfaces(@ports);
}

if (@ports) {
    #
    # Allow ports to be given in one of two forms: node:port, or switch.port.
    # Only admins can do the latter, of course...
    #
    my (@nodes, @switchports);
    foreach my $port (@ports) {
	if ($port =~ /^([^:]+):\d+$/) {
	    push @nodes, $1;
	} elsif ($port =~ /^([^.]+)\.\d+(\/\d+)?$/) {
	    push @switchports, $port;
	} elsif ($port =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$port = $opt{i}->[0] . "." . $port;
		push @switchports, $port;
	    } else {
		die "The module/port format is only legal if exactly one -i " .
		    "argument has been given\n";
	    }
	} else {
	    tbreport(SEV_ERROR, 'bad_data', 'port', $port);
	    die "Bad format for port $port\n"
	}
    }

    if ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_MODIFYVLANS,@nodes)) {
	tbreport(SEV_ERROR, 'insufficient_permissions');
	die "You do not have permission to modify some or all of the nodes\n" .
		"that will be affected by the operation you requested\n";
    }

    if (@switchports && !TBAdmin()) {
	die "Only admins are allowed to modify switch ports directly\n";
    }
}

if ($TESTMODE) {
    print "Test mode, exiting without touching hardware\n";
    exit(0);
}

#
# snmpit_lib fills out some hashes for speed of lookup later. Initialize
# them now
#
snmpit_lib::init($debug);

my $exitval = 0;
COMMAND: foreach my $command (@commands) {

    #
    # Pull the operation and the arugments to it.
    #
    my ($operation,@args) = @$command;

    debug("Operation is $operation\n");

    #
    # Discover the set of devices we need to talk to. This differs depending
    # on the operation which we're performing. We also get a list of all ports
    # and vlan IDs involved in this operation, if appropriate. We use this
    # opportunity to bail out of the command if it appears we have no work
    # to do
    #
    my @devicenames;
    my @vlans;
    SWITCH: for ($operation) {
	(/listvlans/ || /getstats/ || /vlannumber/ || /synchleader/) && do {
	    @devicenames = $supplied_switches?
			   @supplied_switches : getTestSwitches();
	    last;
	};
	(/listports/) && do {
	    @devicenames = $supplied_switches? @supplied_switches :
	    (@ports? getDeviceNames(@ports) : getTestSwitches());
	    last;
	};
	( /make/ ) && do {
            if ($supplied_switches) {
                @devicenames = @supplied_switches;
            } elsif (@ports) {
                # Have to operate on whole stacks so that trunks work
                @devicenames =
                    getSwitchesInStacks(getStacksForSwitches(getDeviceNames(@ports)));
            } else {
                @devicenames = getTestSwitches();
            }
	    last;
	};
        (/remove/) && do {
            # Three levels of possible sources for device names (in order):
            #   passed in on command line
            #   stack name recorded in database
            #   if others fail, default to experimental switches
	    my ($vlan_name) = @args;
            my ($vlanobj, $stack);
            if ($supplied_switches) {
                debug("Remove: using supplied switches\n");
                @devicenames = @supplied_switches;
            } elsif (defined($vlanobj = VLan->Lookup($experiment,$vlan_name)) &&
                     defined($stack = $vlanobj->GetStack())) {
                debug("Remove: found stack $stack in database\n");
                @devicenames = getSwitchesInStack($stack);
            } else {
                debug("Remove: using test switches\n");
                @devicenames = getTestSwitches();
            }
            last;
        };
        (/^tables$/) && do {
            # Grab all stacks that any ports in the experiment are members
            # of.
            # (We need the entire stack, since the VLAN may have to traverse
            # devices that don't explicitly have a port in the VLAN.)
            @vlans = getExperimentVlans($pid,$eid,@optvlanids);
            if (!@vlans) {
                print "snmpit: $pid/$eid has no VLANs to create, skipping\n";
                next COMMAND;
            }
            if ($supplied_switches) {
                debug("Tables: using supplied switches\n");
                @devicenames = @supplied_switches;
            } else {
                @devicenames =
                    getSwitchesInStacks(getPlannedStacksForVlans(@vlans));
                debug("Tables: list from database: " . join(",",@devicenames) .
                    "\n");
            }
            if (scalar(@devicenames == 0)) {
                debug("Tables: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
            last;
        };
	(/reset/) && do {
	    #
            # We operate on all stacks that we have recorded as having VLANs
            # that belong to this experiment.
	    #
	    @vlans = getExperimentVlans($pid,$eid,@optvlanids);
            if (!@vlans) {
                print "snmpit: $pid/$eid has no VLANs, skipping\n";
                next COMMAND;
            }
            @vlans = filterPlannedVlans(@vlans);
            if (!@vlans) {
                print "snmpit: $pid/$eid has VLANs, but none have been " .
                    "created on switches\n  ... skipping\n";
                next COMMAND;
            }
            if ($supplied_switches) {
                debug("Reset: using supplied switches\n");
                @devicenames = @supplied_switches;
            } else {
                @devicenames =
                    getSwitchesInStacks(getActualStacksForVlans(@vlans));
                debug("Reset: list from database: " . join(",",@devicenames) .
                    "\n");
            }

            # Fallthrough - if we haven't found any switches yet, operate
            # on the whole experimetnal net
            if (scalar(@devicenames) == 0) {
                debug("Reset: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
	    last;
	};
	(/synctables/) && do {
            # We operate on all stacks on which we think VLANs do, or should,
            # exist
            if ($supplied_switches) {
                debug("Sync: using supplied switches\n");
                @devicenames = @supplied_switches;
            } else {
                # Get both the VLANs that do exist and the VLANs that should
                # exist
                my @newvlans = getExperimentVlans($pid,$eid,@optvlanids);
                @devicenames =
                    getSwitchesInStacks(getPlannedStacksForVlans(@newvlans));
                debug("Sync: New devices are " . join(",",@devicenames) .
                    "\n");

                my @oldvlans;
                VLan->StaleVlanList($experiment,\@oldvlans);
                my @oldports;
                foreach my $oldvlan (@oldvlans) {
                    push @oldports, getExperimentVlanPorts($oldvlan);
                }
                push @devicenames,
                    getSwitchesInStacks(getStacksForSwitches(getDeviceNames(@oldports)));
                debug("Sync: With old devices, list is " .
                    join(",",@devicenames) .  "\n");

                @devicenames = uniq(@devicenames);
            }

            # Fallthrough - if we haven't found any switches yet, operate
            # on the whole experimetnal net
            if (scalar(@devicenames) == 0) {
                debug("Reset: falling back to test swtiches\n");
                @devicenames = getTestSwitches();
            }
	    last;
	};
	(/portcontrol/ || /trunkdisable/ || /portstatus/) && do {
	    @devicenames = $supplied_switches?
	    		   @supplied_switches : getDeviceNames(@ports);
	    last;
	};
	(/expcnetcontrol/) && do {
	    @ports = getExperimentControlPorts($pid, $eid);
	    @devicenames = getDeviceNames(@ports);
	};
	(/recreate/) && do {
	    #
	    # Safety check - cannot be used with -i . We have to operate on
	    # all experimental switches
	    #
	    if ($supplied_switches) {
		die "-c and -i or -S cannot be used together\n";
	    }
	    @devicenames = getTestSwitches();
	    last;
	};
	(/trunkenable/) && do {
	    @devicenames = $supplied_switches?
	    		   @supplied_switches : getDeviceNames(@ports);
	    @vlans = @optvlanids;
	    last;
	};
        (/restorestatus/) && do {
            # We start by parsing out the options string, then we'll reset
            # @args
            my ($statusarg) = @args;
            my %args = parseStatusString($statusarg);
            if (!$args{port}) {
                tbdie "No port given in status string";
            }
            @ports = convertPortsFromIfaces($args{port});
            if ($args{vlan}) {
                @vlans = ($args{vlan});
            }
            @devicenames = $supplied_switches?
                           @supplied_switches : getDeviceNames(@ports);

            @args = %args;
            last;
        };
    }

    debug("Device names: " . join(",",@devicenames) . "\n");
    debug("Ports: " . join(",",@ports) . "\n");
    if (@vlans) { debug("VLANs: " . join(",",@vlans) . "\n") };

    my %stacks = ();
    if (! $ELABINELAB) {
	#
	# First, look at the device names we've got and map them to stacks 
	#
	foreach my $devicename (@devicenames) {
	    my $stack = getSwitchPrimaryStack($devicename);
	    if (defined($stack)) {
		push @{$stacks{$stack}}, $devicename;
	    }
	}
	#
	# Next, add in stacks that were specified as a whole
	#
	foreach my $stack (@supplied_stacks) {
	    # We checked for non-existent stacks above
	    my @switches = getSwitchesInStack($stack);
	    push @{$stacks{$stack}}, @switches;
	}
    }

    #
    # Now, make the object for each stack that we discovered
    #
    my @stacks;
    my %stack_ids;
    foreach my $stack_id (keys %stacks) {
	my ($stack_type, $supports_private, $single_domain, $community)
		= getStackType($stack_id);
	#
	# Safety check - make sure the stack supports private VLANs if -y was
	# given
	#
	if ($opt{y} && !$supports_private) {
	    die "Switch stack $stack_id does not support private VLANs\n";
	}

	my $stack;
	debug("Stack $stack_id has type $stack_type\n");
	SWITCH: for ($stack_type) {
	    (/cisco/ || /catalyst/) && do {
		require snmpit_cisco_stack;
		$stack = new snmpit_cisco_stack($stack_id,$debug,$quiet,
						$single_domain,
						@{$stacks{$stack_id}});
		last;
	    }; # /cisco/
	    /intel/ && do {
		require snmpit_intel_stack;
		$stack = new snmpit_intel_stack($stack_id,$debug,
						@{$stacks{$stack_id}});
		last;
	    };
	    /generic/ && do {
		require snmpit_stack;
		$stack = new snmpit_stack($stack_id,$debug,$quiet,
					  @{$stacks{$stack_id}});
		last;
	    }; # /generic/

	    # 'default' case
	    die "Unknown stack type $stack_type for stack $stack_id\n";
	}

	#
	# Check for error in object creation and bail
	#
	if (!$stack) {
	    die "Unable to connect to one or more switches, exiting\n";
	} else {
	    push @stacks, $stack;
	    $stack_ids{$stack_id} = $stack;
	}
    }


    #
    # If we were given ports, make sure that the stack(s) that got created
    # cover all of them
    #
    if (@ports && !$ELABINELAB) {
	my %devicemap = mapPortsToDevices(@ports);
	my @devices = keys %devicemap;
	foreach my $device (@devices) {
	    my @stack_ids = getSwitchStacks($device);
	    my $matched = 0;
	    foreach my $stack_id (@stack_ids) {
		if ($stack_id && $stack_ids{$stack_id}) {
		    $matched = 1;
		}
	    }
	    if (!$matched) {
		tbdie({type => 'primary', severity => SEV_ERROR,
		       error => ['device_not_in_stack', $device]},
		      "One or more ports are on $device, but no " .
		      "stack containing it was specified!");
	    }
	}
    }
    if ($ELABINELAB) {
	#
	# Okay, now that we skipped all that stack stuff ...
	#
	@stacks = @supplied_stacks;
    }

######################################################################
# Step 4 - Actually perfrom the operation
#
# Finally, we just call the helper function for the operation that
# is to be performed.
######################################################################
    if ($opt{n}) {
	print "Test mode, skipping operation\n";
	next;
    }

    SWITCH: for ($operation) {
	/listvlans/ && do {
	    $exitval += doListVlans(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/synchleader/ && do {
	    $exitval += doSynchLeader(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/listports/ && do {
	    $exitval += doListPorts(\@stacks);
	    last;
	}; # /listports/ && do
	/getstats/ && do {
	    $exitval += doGetStats(\@stacks);
	    last;
	}; # /ports/ && do
	/^tables$/ && do {
	    $exitval += doVlansFromTables($experiment,\@stacks,@vlans);
	    last;
	}; # /tables/ && do
	/synctables/ && do {
	    $exitval += syncVlansFromTables($experiment,\@stacks);
	    last;
	}; # /tables/ && do
	/reset/ && do {
	    $exitval += doReset(\@stacks,@vlans);
	    last;
	};
	/make/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doMakeVlan(\@stacks,$vlan_name,@ports);
	    last;
	};
	/remove/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doDeleteVlan(\@stacks,$vlan_name);
	    last;
	};
	/portcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/expcnetcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/recreate/ && do {
	    $exitval += doRecreateVlans(\@stacks);
	    last;
	};
	/trunkenable/ && do {
	    $exitval += doTrunkEnable(\@stacks,$ports[0],
				      $equaltrunking,@vlans);
	    last;
	}; # /trunkenable/ && do
	/trunkdisable/ && do {
	    $exitval += doTrunkDisable(\@stacks,$ports[0]);
	    last;
	}; # /trunkdisable/ && do
	/portstatus/ && do {
	    $exitval += doPortStatus(\@stacks,@ports);
	    last;
	}; # /portstatus/ && do
	/vlannumber/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doVlanNumber(\@stacks,$vlan_name);
	    last;
	}; # /portstatus/ && do
	/restorestatus/ && do {
	    $exitval += doRestorePortStatus(\@stacks,@args);
	    last;
	}; # /portstatus/ && do
    }
}

exit $exitval;

######################################################################
# Subs
######################################################################

#
# Print given message to STDERR, only if debug mode is on
#
sub debug($) {
    if ($debug) {
	print STDERR @_;
    }
}

#
# Parse a port status string. Returns a key-value hash pair
#
sub parseStatusString($) {
    my ($string) = @_;
    chomp $string;

    my %pairs;
    foreach my $pair (split /;/, $string) {
        my ($key, $value) = split /=/,$pair,2;
        if (!$key || !$value) {
            tbdie "Bad port status string: $string";
        } else {
            $pairs{$key} = $value;
        }
    }

    return %pairs;
}

#
# Lists all vlans on all stacks
#
sub doListVlans ($) {

    my $stacks = shift;
    my %vlans;
    my @vlanList;

    #
    # We need to 'coallate' the results from each stack by putting together
    # the results from each stack, based on the VLAN identifier
    #
if ($ELABINELAB) {
    #
    # Sklower deliberately uglified this.  The intent is that eventually
    # $stack->listVlans() will call a $<remotedevobj>->listVlans() and
    # it will just work.  For now, we dup the code.
    #
    @vlanList = RemoteDoList();
    foreach my $vlan (@vlanList) {
	my ($id,$ddep,$memberref) = @$vlan;
	${$vlans{$id}}[0] = $ddep;
	push @{${$vlans{$id}}[1]}, @$memberref;
    }
} else {
    foreach my $stack (@$stacks) {
	@vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
	    ${$vlans{$id}}[0] = $ddep;
	    push @{${$vlans{$id}}[1]}, @$memberref;
	}
    }
}

    #
    # less code to do this for snmpit.proxy than for it to popen snmpit
    # parse the output, and glue it back together.
    #
    if ($opt{L}) {
	my @results;
	foreach my $pair (split ',', $opt{L}) {
	    my ($out,$in) = split "#", $pair;
	    my $vlan = "$in#" . ${$vlans{$out}}[0] . "#" .
				    join(' ', @{${$vlans{$out}}[1]});
	    push @results, $vlan;
	}
	print join(',', @results);
	exit(0);
    }
    #
    # These need to be declared here for the benefit of the format string
    # See perlform(1) for help with formats
    #
    my ($vlan_id,$ddep,$pideid,$vname,$members);
    #
    # Check to see if they want device-specific VLAN numbers, which makes the
    # display more cramped, but is useful for debugging
    #
    if (!$opt{w}) { 
	print << "END";
VLAN     Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist =
@<<<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$pideid,           $vname,   $members
~~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $members
.
	$FORMAT_NAME = 'vlanlist';
    } else {
    	print << "END";
VLAN     Number Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist2 =
@<<<<<<< @<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$ddep, $pideid,           $vname,   $members
~~                                           ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                             $members
.
	$FORMAT_NAME = 'vlanlist2';
}

    foreach my $vid (sort {tbsort($a,$b)} keys %vlans) {
        $vlan_id = $vid;
	my $memberref;
	($ddep,$memberref) = @{$vlans{$vid}};
        
        my $vlan = VLan->Lookup($vlan_id);
        if (!defined($vlan)) {
	    &debug("No such VLAN $vlan_id in lans table\n");
	    next
		if ($opt{l} == 1);
	    $vname = $vlan_id;
	    $experiment = undef;
        }
	else {
	    $vname         = $vlan->vname();
	    $experiment    = $vlan->GetExperiment();
	}

	#
	# Permissions check - people only get to see their own VLANs
	#
	if (!defined($experiment)) {
            # If only printing orphaned VLANs, consider only ones that have IDs
            # that look like the ones we assign in the database
            if ($opt{O} && $vid !~ /^\d+$/) {
                next;
            }
	    if (!TBAdmin()) {
		&debug("Failed TBAdmin check\n");
		next;
	    }
	} else {
            # If only printing orphaned VLANs, skip ones for which we know the
            # pid and ied
            if ($opt{O}) {
                next;
            }
            if ($UID &&
		!$experiment->AccessCheck($this_user, TB_EXPT_READINFO)) {
                &debug("$this_user failed access check to $experiment\n");
                next;
            }
        }


	if (!$vname) { $vname = ""; }

	#
	# Check to see if we were supposed to print out MAC addresses
	#
	if ($opt{M}) {
	    # Rather than node:port, print out node:MAC (if we know the MAC)
	    $members = join(" ", map
		{
		    macport($_)? (split /:/)[0] . ":" . macport($_) : $_
		} @$memberref);
	} else {
	    $members = join(" ",@$memberref);
	}

	#
	# Setup $pideid for a more compact display
	#
	if (defined($experiment)) {
	    $pideid = $experiment->pid() . "/" . $experiment->eid();
	} else {
	    $pideid = "";
	}
	write;
    }

    return 0;
}

#
# This routine does a number of illegal things.  It is used
# to make sure the leader of a stack contains all vlans on all switches
# in the stack and is only useful for moving a stack back and forth
# between types "cisco" and "generic" (where $stack->{ALLVLANSONLEADER} must be
# set to 1.
#
sub doSynchLeader ($) {

    my $stacks = shift;
    my $errors = 0;
    if (!TBAdmin()) {
	die "Only admins are allowed to synchronize stacks\n";
    }

    foreach my $stack (@$stacks) {
	my $leader = $stack->{LEADER};
	my %vlans = $stack->findVlans();
	while (my ($id,$num) = each %vlans) {
	    if (($num >= $leader->{MIN_VLAN}) &&
		($num <= $leader->{MAX_VLAN}) &&
		!($leader->vlanNumberExists($num))) {
			$errors += $leader->createVlan($id, $num);
	    }
	}
    }
    return $errors;
}

#
# Lists all ports on all stacks
#
sub doListPorts($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # See perlform(1) for help with formats
    #
    my ($port,$enabled,$up,$speed,$duplex);
    print << "END";
Port      Enabled Up   Speed      Duplex
--------------------------------------------
END
    format portlist =
@<<<<<<<< @<<<<<< @<<< @<<<<<<<<< @<<<<<<<<<
$port,    $enabled,$up,$speed,$duplex
.
    $FORMAT_NAME = 'portlist';
    foreach my $line (sort {tbsort($$a[0],$$b[0])} @portList) {
	($port,$enabled,$up,$speed,$duplex) = @$line;
	#
	# Only let people see information about ports in their experiments
	#
	$port =~ /^(.+):/;
	my $node = $1;

	&debug("node is $node\n");
	if (!$node) {
	    if (!TBAdmin($UID)) {
		next;
	    }
	} elsif ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_READINFO,$node)) {
	    next;
	}
	write;
    }

    return 0;
}

#
# Get information on a particular port - the idea is that this string can later
# be passed back to us to restore the status of the port.
# This is inefficient, because it gets information about all ports and only
# uses it for one (or a few). BUT, it doesn't require changes to the
# vendor-specific modules, so I think it's worth it for portability.
#
sub doPortStatus($@) {

    my $stacks = shift;
    my @port = @_;

    my $errors = 0;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # Find the port(s) we're looking for in the portlist
    #
    my %ports = ();
    foreach my $port (@ports) {
        $ports{$port} = undef;
    }
    foreach my $portrecord (@portList) {
	my ($port,$enabled,$up,$speed,$duplex) = @$portrecord;
        if (exists $ports{$port}) {
            $ports{$port} = "enabled=$enabled";
            $ports{$port} .= ";speed=$speed";
            if ($speed ne "autoDetect") {
                $ports{$port} .= ";duplex=$duplex";
            }
        }
    }

    #
    # Now find out what VLAN it's in
    #
    foreach my $stack (@$stacks) {
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            # Now we have to look through the memberref for our ports
            foreach my $port (@$memberref) {
                if ($ports{$port}) {
                    $ports{$port} .= ";vlan=$id";
                }
            }
	}
    }

    #
    # XXX - This is gonna be a mess if the port is a trunk port, or otherwise
    # somehow more complicated. For now, we just ignore this, I guess
    #

    #
    # Check to see if we missed any
    #
    foreach my $port (keys %ports) {
        if (!$ports{$port}) {
	    tberror({type => 'primary', severity => SEV_ERROR,
		     error => ['get_port_status_failed', $port]},
		    "Unable to get status information for $port!");
            $errors++;
        } else {
            print "port=$port;$ports{$port}\n";
        }
    }

    if ($errors) {
        return $errors;
    }

}

#
# Restore port status. Takes a single argument, which is an array that will be
# turned back into a param hash
#
sub doRestorePortStatus($@) {

    my $stacks = shift;
    my %params = @_; # Yes, this does work

    my $port = $params{port};
    if (!$port) {
        tbdie "No port passed to -B option";
    }

    if (@$stacks > 1) {
	die "Port restoration accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    my $errors = 0;

    # Put the port in the specified VLAN
    # If they didn't give us a VLAN, we assume that means they want it removed
    # from its vlan
    my $vlan = $params{vlan};
    if (!$vlan) { $vlan = "default"; }
    $errors += $stack->setPortVlan($vlan,$port);
    if ($errors) { return $errors; }

    # Enable or disable the port
    # If they didn't tell us either way, we assume they wanted it disabled
    my $enabled = $params{enabled};
    # If they are putting the port into the default VLAN, force it to be
    # disabled, so that a user cannot use this method to break into that VLAN
    if ($vlan eq "default") { $enabled = "no"; }
    if ($enabled eq "yes") {
        $errors = $stack->portControl("enable",$port);
    } else {
        $errors = $stack->portControl("disable",$port);
    }

    #
    # Set the speed and duplex on the port if given
    #
    my $speed = $params{speed};
    if ($speed && $speed ne " ") {
        if ($speed eq "autoDetect") {
            $errors = $stack->portControl("auto",$port);
        } else {
            #
            # Check for a valid speed - convert Mbps to mbit if necessary
            #
            if ($speed =~ /(\d+)(Mbps|mbit)/) {
                $errors = $stack->portControl("${1}mbit",$port);
            } else {
                tbwarn "Bad speed given for $port: $speed";
                $errors++;
            }
        }
    }
    my $duplex = $params{duplex};
    if ($duplex && $duplex ne " ") {
        if ($duplex eq "half") {
            $errors = $stack->portControl("half",$port);
        } elsif ($duplex eq "full") {
            $errors = $stack->portControl("full",$port);
        } else {
            tbwarn "Bad duplex given for $port: $duplex";
            $errors++;
        }
    }
    return $errors;
}

#
# Get statistics for all ports on all stacks
#
sub doGetStats($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @statList = ();
    foreach my $stack (@$stacks) {
	push @statList, $stack->getStats();
    }

    my ($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
        $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	$outerr,$outq);
    #
    # See perlform(1) for help with formats
    #
    print << "END";
          In         InUnicast  InNUnicast In         In         Unknown    Out        OutUnicast OutNUcast  Out       Out         OutQueue
Port      Octets     Packets    Packets    Discards   Errors     Protocol   Octets     Packets    Packets    Discards  Errors      Length
---------------------------------------------------------------------------------------------------------------------------------------------
END
    format stats =
@<<<<<<<< @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> 
$port,    $inoctets, $inunicast,$innunicast,$indiscards,$inerr,  $inunk,    $outoctets,$outunicast,$outnunicast,$outdiscards,$outerr,$outq
.
    $FORMAT_NAME = 'stats';
    foreach my $line (sort {tbsort($a,$b)} @statList) {
	($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
	 $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	 $outerr, $outq) = @$line;
	write;
    }

    return 0;
}

#
# Creates all VLANs given. Looks up identifiers in the database to determine
# the membership.
#
sub doVlansFromTables($$@) {
    my $experiment = shift;
    my $stacks  = shift;
    my @vlanids = @_;
    my %vlans   = ();

    my $errors = 0;
    my $vlan_number;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    
    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoVlansFromTables($experiment, @vlanids);
    }

    my ($stack) = @$stacks;
    my @trunkedPorts = getExperimentTrunks($pid,$eid);
    my %trunkedPorts = map { $_ => $_ } @trunkedPorts;

    #
    # Look for a lan that requires dual mode trunking. The ports in that
    # lan need to be trunked after the native lan is created, so that we
    # can call doTrunkEnable with dual mode instead of equalmode. This is
    # not a general solution to this, but I have not found a solution I am
    # really happy with. 
    #
    foreach my $id (@vlanids) {
	my $vlan = VLan->Lookup($id);
	if (!defined($vlan)) {
	    die("Could not locate vlan $id in the DB\n");
	}
	$vlans{"$id"} = $vlan;
    }
    foreach my $vlan (values(%vlans)) {
	my $vlanid = $vlan->id();
	my $trunk_mode;
	$vlan->GetAttribute("trunk_mode", \$trunk_mode);

	# This is set in libvtop.
	if (defined($trunk_mode) && $trunk_mode eq "dual") {
	    my @ports = getVlanPorts($vlanid);
	    
	    # Create this vlan now.
	    if (CreateOneVlan($stack, $vlanid, @ports))  {
		die("Could not create dual trunked $vlan\n");
	    }
	    # Trunk these ports, removing from list.
	    foreach my $port (@ports) {
		if (doTrunkEnable($stacks,$port,0,$vlanid)) {
		    die("Could not put $port ($vlan) into dual trunk mode\n");
		}
		delete($trunkedPorts{$port});
	    }
	    # Delete this vlan from the list that will be created below.
	    delete($vlans{"$vlanid"});
	}
    }
    # Do the rest of the trunked ports in equalmode.
    foreach my $port (keys(%trunkedPorts)) {
	$errors += doTrunkEnable($stacks,$port,1);
    }

    #
    # Sanity check: make sure that this experiment does not use more VLANs than
    # we can put on the stack. Note that we don't try to check how many are
    # available (ie. total - used), because getting the 'used' value is not
    # trivial.
    #
    my $leader = getStackLeader($stack->{STACKID});
    if (!defined $leader) {
        tberror "Unable to get stack leader for $stack->{STACKID}";
        return 1;
    }
    my $switch_options = getDeviceOptions($leader);
    if (!defined $switch_options) {
        tberror "Unable to get stack leader for $stack->{STACKID}";
        return 1;
    }
    my $vlan_count = $switch_options->{'max_vlan'} -
                     $switch_options->{'min_vlan'};
    my $expt_vlan_count = scalar(keys(%vlans));
    if ($expt_vlan_count > $vlan_count) {
        tberror "Too many VLANs in experiment: $expt_vlan_count requested, " .
                "$vlan_count available";
        return 1;
    }

    foreach my $vlan (values(%vlans)) {
	my $vlanid = $vlan->id();
	my @ports  = getVlanPorts($vlanid);

	$errors += CreateOneVlan($stack, $vlanid, @ports);
    }
    return $errors;
}

#
# Create a single vlan.
#
sub CreateOneVlan($$@)
{
    my $stack  = shift();
    my $vlanid = shift();
    my @ports  = @_;
    my $errors = 0;

    if ($stack->vlanExists($vlanid)) {
	print "  VLAN $vlanid already exists\n"
	    if (!$quiet);
	if ($stack->setPortVlan($vlanid,@ports)) {
	    $errors++;
	}
	else {
	    # Convert the ports to node:iface for the next call.
	    my @conports = map { portiface($_) } @ports;

	    VLan->RecordVLanModification($vlanid, \@conports, undef);
	}
    }
    else {
	my $vlan_number = $stack->createVlan($vlanid,\@ports);
	if (!$vlan_number) {
	    tberror({type => 'secondary', severity => SEV_SECONDARY,
		     error => ['create_vlan_failed', $vlanid]},
		    "Failed to create VLAN with id $vlanid");
	    #
	    # Don't try to put ports in a VLAN if it couldn't be created
	    #
	    $errors++;
	}
	else {
	    setVlanTag($vlanid, $vlan_number);
	    VLan->RecordVlanInsertion($experiment, $vlanid,$stack->{STACKID});
	}
    }
    return $errors
	if ($errors);

    #
    # Set the speed and duplex of each interface depending on the
    # value in the database
    #
    if (!$NOSTACKMIB) {
	foreach my $port (@ports) {
	    my ($speed,$duplex) = getInterfaceSettings($port);
	    #
	    # If either is not set, we do nothing. We could make
	    # a 0 mean 'auto'
	    #
	    # For now, we ignore it if the switch doesn't support the
	    # commands.
	    #
	    if ($speed) {
		my $cmd = $speed . "mbit";
		my $rv = $stack->portControl($cmd, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	    if ($duplex) {
		my $rv = $stack->portControl($duplex, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	}
    }
    return $errors;
}

#
# Remove all VLANs given from every switch in the stack. All ports in the
# VLANs are removed, irrespective of what the database says membership should
# be
#
sub doReset($@) {
    my $stacks = shift;
    my @vlans = @_;

    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoReset($experiment, scalar(@optvlanids) == 0, @vlans);
    }

    my $errors = 0;
    my @trunkedPorts = getExperimentTrunks($pid,$eid);
    foreach my $port (@trunkedPorts) {
	$errors += doTrunkDisable($stacks,$port);
    }

    #
    # Just remove the VLAN from every stack on which it exists. We keep a
    # list and do them all at once for efficiency.
    #
    foreach my $stack (@$stacks) {
	my @existant_vlans = $stack->existantVlans(@vlans);
	if (!$stack->removeVlan(@existant_vlans)) {
	    $errors++;
	}
	foreach my $vlan (@existant_vlans) {
	    setVlanTag($vlan, 0);
	    VLan->RecordVLanDeletion($vlan);
	}
    }
    return $errors;
}

#
# Sync vlans from the DB for a single experiment. This is a swapmod helper
# to avoid churning the switches.
#
sub syncVlansFromTables($$) {
    my $experiment = shift;
    my $stacks     = shift;
    my %expvlans   = ();
    my %curvlans   = ();
    my %stale      = ();
    my $impotent   = 0;
    my $errors     = 0;
    my $vlan_number;

    $debug = 1;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;
    my @needTrunking = getExperimentTrunks($pid,$eid);
    my %needTrunking = map { $_ => $_ } @needTrunking;

    debug("Trunk Ports: @needTrunking\n");

    #
    # Get list of vlans that should exist.
    #
    my @tmp;
    VLan->ExperimentVLans($experiment, \@tmp) == 0 or
	die("Could not get current vlans for $experiment\n");
    foreach my $vlan (@tmp) {
	$expvlans{$vlan->id()} = $vlan;
    }
    debug("Experiment vlans: " . join(" ", keys(%expvlans)) . "\n");;

    #
    # Get list of vlans that we think are on the switch (vlans table).
    #
    @tmp = ();
    VLan->StaleVlanList($experiment, \@tmp) == 0 or
	die("Could not get stale vlans for $experiment\n");
    foreach my $vlanid (@tmp) {
	$curvlans{$vlanid} = 1;
	
	# Not in the new set; must delete.
	$stale{$vlanid} = 1
	    if (!exists($expvlans{$vlanid}));
    }
    debug("Existing vlans: @tmp\n");
    debug("Stale vlans: " . join(" ", keys(%stale)) . "\n");

    #
    # Get a list of interfaces that are currently trunked.
    #
    my @currentTrunks = getExperimentCurrentTrunks($pid,$eid);
    my %currentTrunks = map { $_ => $_ } @currentTrunks;

    #
    # Okay, kill off stale vlans.
    #
    if (keys(%stale)) {
	my @existant_vlans = $stack->existantVlans(keys(%stale));

	if (@existant_vlans) {
	    debug("Removing stale vlans @existant_vlans\n");

	    if (!$impotent) {
		foreach my $vlanid (@existant_vlans) {
		    my @curports   = getExperimentVlanPorts($vlanid);
		    my @trunkports = ();

		    foreach my $port (@curports) {
			if (exists($currentTrunks{$port})) {
			    push(@trunkports, $port);
			}
		    }
		    if (@trunkports) {
			$stack->removeSomePortsFromTrunk($vlanid, @trunkports)
			    or goto bad;

			# Convert the ports to node:iface for the next call.
			@trunkports = map { portiface($_) } @trunkports;

			VLan->RecordVLanModification($vlanid,
						     undef, \@trunkports)
			    == 0 or goto bad;
		    }
		    if (!$stack->removeVlan($vlanid)) {
			print STDERR "Could not remove vlan: $vlanid\n";
			goto bad;
		    }
		    VLan->RecordVLanDeletion($vlanid) == 0
			or goto bad;
		}
	    }
	}
    }

    #
    # Remove stale ports from existing vlans. 
    #
    foreach my $vlanid (keys(%expvlans)) {
	# This one will be built later.
	next
	    if (!exists($curvlans{$vlanid}));
	    
	my @expports   = getVlanPorts($vlanid);
	my @curports   = getExperimentVlanPorts($vlanid);
	my @staleports = ();
	my @staletrunks= ();

	#
	# As a simplification for the backend, keep trunked ports separate
	# from regular ports. Better then the backend figuring it out.
	#
	foreach my $port (@curports) {
	    if (! grep {$_ eq $port} @expports) {
		if (exists($currentTrunks{$port})) {
		    push(@staletrunks, $port);
		}
		else {
		    push(@staleports, $port);
		}
	    }
	}
	next
	    if (! (@staleports || @staletrunks));
	    
	if (@staleports) {
	    debug("Removing stale ports from vlan $vlanid: @staleports\n");

	    if (!$impotent) {
		$stack->removeSomePortsFromVlan($vlanid, @staleports)
		    or goto bad;

		# Convert the ports to node:iface for the next call.
		@staleports = map { portiface($_) } @staleports;

		VLan->RecordVLanModification($vlanid, undef, \@staleports) == 0
		    or goto bad;
	    }
	}
	if (@staletrunks) {
	    debug("Removing stale trunked ports from vlan $vlanid: @staletrunks\n");
	    
	    if (!$impotent) {
		$stack->removeSomePortsFromTrunk($vlanid, @staletrunks)
		    or goto bad;

		# Convert the ports to node:iface for the next call.
		@staletrunks = map { portiface($_) } @staletrunks;

		VLan->RecordVLanModification($vlanid, undef, \@staletrunks) == 0
		    or goto bad;
	    }
	}
    }

    #
    # Now untrunk the ports that are no longer trunked.
    #
    foreach my $port (keys(%currentTrunks)) {
	if (!exists($needTrunking{$port})) {
	    debug("Disabling trunking on $port\n");
	    
	    next
		if ($impotent);
	
	    doTrunkDisable($stacks, $port) == 0
		or goto bad;

	    delete($currentTrunks{$port});
	}
    }

    #
    # Look for special vlans that need dual trunking.
    #
    foreach my $vlanid (keys(%expvlans)) {
	my $vlan = $expvlans{$vlanid};
	my $trunk_mode;
	$vlan->GetAttribute("trunk_mode", \$trunk_mode);

	# This is set in libvtop.
	if (defined($trunk_mode) && $trunk_mode eq "dual") {
	    my @ports = getVlanPorts($vlanid);
	    my @saveports = @ports;

	    #
	    # If the vlan exists, still want to call CreateOneVlan(),
	    # but only if some ports are not yet in the vlan.
	    #
	    if (exists($curvlans{$vlanid})) {
		my @curports = getExperimentVlanPorts($vlanid);
		my @newports = ();

		foreach my $port (@ports) {
		    push(@newports, $port)
			if (! grep {$_ eq $port} @curports);
		}
		@ports = @newports;
	    }
	    
	    # Create this vlan now. 
	    debug("Creating dual mode trunking vlan $vlanid: @ports\n")
		if (@ports);
		
	    if (!$impotent && @ports &&
		CreateOneVlan($stack, $vlanid, @ports))  {
		print STDERR "Could not create dual trunked $vlan\n";
		goto bad;
	    }
	    # So it is not created below.
	    $curvlans{$vlanid} = 1;
	    
	    # Trunk ports.
	    foreach my $port (@saveports) {
		if (!exists($currentTrunks{$port})) {
		    debug("Enabling dual mode trunking on $port:$vlanid\n");
		    
		    if (!$impotent &&
			doTrunkEnable($stacks,$port,0,$vlanid)) {
			print STDERR
			    "Could not put $port ($vlanid) into ".
			    "dual trunk mode\n";
			goto bad;
		    }
		}
		# Mark is as being trunked.
		$currentTrunks{$port} = $port;
	    }
	}
    }

    #
    # And add trunking on any port that needs it.
    #
    foreach my $port (keys(%needTrunking)) {
	if (!exists($currentTrunks{$port})) {
	    debug("Enabling trunking on $port\n");
	    
	    next
		if ($impotent);
	
	    doTrunkEnable($stacks, $port, 1) == 0
		or goto bad;

	    # Mark is as being trunked.
	    $currentTrunks{$port} = $port;
	}
    }

    #
    # Now add ports to existing vlans.
    #
    foreach my $vlanid (keys(%expvlans)) {
	# This one will be built later.
	next
	    if (!exists($curvlans{$vlanid}));
	    
	my @expports   = getVlanPorts($vlanid);
	my @curports   = getExperimentVlanPorts($vlanid);
	my @newports   = ();

	foreach my $port (@expports) {
	    push(@newports, $port)
		if (! grep {$_ eq $port} @curports);
	}
	next
	    if (!@newports);
	    
	debug("Adding new ports to vlan $vlanid: @newports\n");

	next
	    if ($impotent);
	
	if (CreateOneVlan($stack, $vlanid, @newports)) {
	    goto bad;
	}
    }

    #
    # Now create vlans that did not exist.
    #
    foreach my $vlanid (keys(%expvlans)) {
	next
	    if (exists($curvlans{$vlanid}));
	    
	my @ports  = getVlanPorts($vlanid);

	debug("Creating new vlan $vlanid: @ports\n");

	next
	    if ($impotent);
	
	if (CreateOneVlan($stack, $vlanid, @ports)) {
	    goto bad;
	}
    }
    return 0;

 bad:
    return -1;
}

#
# Create a vlan with name $vlan_name. It is not an error to try to create a
# VLAN that already exists, as this can be used to add ports to an existing
# VLAN. If ports are given, they are put into the VLAN.
#
sub doMakeVlan($$@) {
    my $stacks = shift;
    my $vlan_name = shift;
    my @ports = @_;
    my $errors = 0;
    my $target_vlan;
    my $source_vlan;
    my $vlan_id = $vlan_name;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    #
    # We require a target VLan object for all vlans related to experiments,
    # unless we are moving ports back into the control network. There are
    # probably other special caes as well, but this is all we need at the
    # moment. 
    #
    if (defined($experiment)) {
	my $stackid = ($ELABINELAB ? $stack : $stack->{STACKID});

	if (defined($stackid) &&
	    $stackid eq "Control" && $vlan_name eq "Control") {
	    #
	    # These ports should be in another vlan object. If not,
	    # something went wrong, not sure what though.
	    #
	    foreach my $port (@ports) {
		my $vlan = VLan->FindVlanByPort($experiment, $port);
		if (!defined($vlan)) {
		    print STDERR "$port is not in a vlan object\n";
		    # Tell caller. 
		    exit(2);
		}
		if (defined($source_vlan) && !$vlan->SameVlan($source_vlan)) {
		    die("Ports must be in a single vlan\n");
		}
		$source_vlan = $vlan;
	    }
	}
	else {
	    #
	    # Sanity check; should this port exist in another vlan object?
	    # Perhaps, but cannot think of any situation right now. 
	    #
	    foreach my $port (@ports) {
		if (VLan->FindVlanByPort($experiment, $port)) {
		    die("$port already in vlan\n");
		}
	    }
	    
	    $target_vlan = VLan->Lookup($experiment, $vlan_name);
	    if (!defined($target_vlan)) {
		#
		# Create a new vlan object and put the ports into it.
		#
		$target_vlan = VLan->Create($experiment, $vlan_name);
		if (!defined($target_vlan)) {
		    die("Could not create VLan object for $vlan_name\n");
		}
		$target_vlan->MarkManual();
                # XXX: Need a better way to figure out whether class is
                # Experimental or Control
                if ($stackid eq "Control") {
                    $target_vlan->SetClass("Control");
                } else {
                    $target_vlan->SetClass("Experimental");
                }
	    }
	    $vlan_id = $target_vlan->id();
	    # This will add the port *only* if not already in the vlan.
	    foreach my $port (@ports) {
		$target_vlan->AddPort($port);
	    }
	}
    }

    #
    # Pass to outer boss.
    #
    if ($ELABINELAB) {
	if ($target_vlan) {
	    return RemoteDoVlansFromTables($experiment, $target_vlan->id());
	}
	else {
	    return RemoteMakeVlan($stack, $vlan_id, @ports);
	}
    }

    #
    # Create it if it doesn't already exist
    #
    if ($stack->vlanExists($vlan_id)) {
	print "VLAN $vlan_name already exists\n"
	    if (!$quiet);

	#
	# Put requested ports into the VLAN
	#
	if (@ports) {
	    print "Putting ports in VLAN ...\n"
		if (!$quiet);
	    my $perrors = $stack->setPortVlan($vlan_id,@ports);
	    if (!$quiet) {
		print "VLAN change ";
		print $perrors? "failed":"succeeded",".\n";
	    }
	    $errors += $perrors;
	}
    } else {
	print "Creating VLAN $vlan_name ...\n"
	    if (!$quiet);
	my $vlan_number = $stack->createVlan($vlan_id,\@ports,@pvlanArgs);
	if (!$quiet) {
	    print "VLAN creation ";
	    print $vlan_number? "succeeded":"failed",".\n";
	}
	if (!$vlan_number) {
	    $errors++;
	}
	$target_vlan->SetTag($vlan_number)
	    if (!$errors && defined($target_vlan));
    }
    if (!$errors) {
	if (defined($source_vlan)) {
	    VLan->RecordVLanDeletion($source_vlan->id());
	}
	if (defined($target_vlan)) {
	    VLan->RecordVlanInsertion($experiment, $target_vlan->id(),
                $stack->{STACKID});
	}
    }
    return $errors;
}

#
# Delete the given VLAN, if it exists
#
sub doDeleteVlan($@) {
    my $stacks = shift;
    my @vlan_names = @_;
    my %vlans  = ();
    my $errors = 0;
    my %notdeleted = ();
    my %vlan_ids = ();

    #
    # We require a VLan object for all vlans related to experiments.
    #
    if (defined($experiment)) {
	foreach my $vlan_name (@vlan_names) {
	    my $vlan = VLan->Lookup($experiment, $vlan_name);
	    if (!defined($vlan)) {
		die("VLan object for $vlan_name does not exist\n");
	    }
	    $vlans{$vlan_name} = $vlan;
	    $vlan_ids{$vlan_name} = $vlan->id();
	}
    }
    elsif ($ELABINELAB) {
	die("Must provide an experiment for this operation\n");
    }
    else {
	foreach my $vlan_name (@vlan_names) {
	    $vlan_ids{$vlan_name} = $vlan_name;
	}
    }

    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	foreach my $vlan (values(%vlans)) {
	    if (RemoteDeleteVlan($vlan) == 0) {
		if ($vlan->Destroy() != 0) {
		    print STDERR "*** Could not destroy $vlan\n";
		}
	    }
	    else {
		$errors++;
	    }
	}
	return $errors;
    }

    my %exists = ();
    foreach my $stack (@$stacks) {
	my @existant_vlans;
	foreach my $vlan_name (@vlan_names) {
	    if ($stack->vlanExists($vlan_ids{$vlan_name})) {
		$exists{$vlan_name} = 1;
		push @existant_vlans, $vlan_name;
	    }
	}
	if (@existant_vlans) {
	    print "Deleting VLAN(s) " . join(",",@existant_vlans) . " ...\n"
		if (!$quiet);
	    my $ok = $stack->removeVlan(map { $vlan_ids{$_} } @existant_vlans);
	    if (!$quiet) {
		print "VLAN deletion ";
		print $ok? "succeeded":"failed",".\n";
	    }
	    if (!$ok) {
		# Be nice if the stack module told us what was not removed?
		foreach my $vlan_name (@existant_vlans) {
		    if ($stack->vlanExists($vlan_name)) {
			print "  $vlan_name was not deleted.\n";
			$notdeleted{$vlan_name} = 1;
		    }
		}
		$errors++;
	    }
	}
    }
    foreach my $vlan_name (@vlan_names) {
	my $vlan_id = $vlan_ids{$vlan_name};

	# Do not throw an error on this. No point, confuses callers.
	if (!$exists{$vlan_name}) {
	    print "VLAN $vlan_name does not exist on any switch\n";
	}	
	
	#
	# Skip if this was not deleted
	#	
	next
	    if ($errors && exists($notdeleted{$vlan_name}));

	# Always delete from the vlans table.
	VLan->RecordVLanDeletion($vlan_id) == 0
	    or $errors++;

	next
	    if (!exists($vlans{$vlan_name}));
	my $vlan = $vlans{$vlan_name};

	if ($vlan->IsManual()) {
	    $vlan->Destroy() == 0
		or $errors++;
	}
    }
    return $errors;
}

#
# Print the device-dependant VLAN number for a given named VLAN
#
sub doVlanNumber ($$) {

    my $stacks = shift;
    my $name = shift;
    my $found = 0;

    #
    # Allow the user to give us multiple stacks
    #
    foreach my $stack (@$stacks) {
        #
        # TODO: This is horrendously inefficient! But, it allows me to write
        # this function without requiring more from the switch/stack modules.
        # Once a specialized function has been added to the switch/stack API,
        # we should use it here.
        #
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            if ($id eq $name) {
                $found = 1;
                print "$name $stack->{STACKID} $ddep\n";
            }
	}
    }

    if ($found) {
        return 0; 
    } else {
        return 1;
    }

}

#
# Send $command to @ports.
# TODO: List of commands
#
sub doPortControl($$@) {
    my $stacks = shift;
    my $command = shift;
    my @ports = @_;
    my $errors;

    if ($ELABINELAB) {
	# As below, only one stack.
	my ($stack) = @$stacks;
	$errors = RemoteDoPortControl($stack,$command,@ports);
	goto finish;
    }

    if (@$stacks > 1) {
	die "Port control accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(", ",map {$_->{STACKID}} @$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    print "Applying command '$command' to ports " . join(",",@ports) . " ...\n"
	if (!$quiet);
    $errors = $stack->portControl($command,@ports);
    if (!$quiet) {
	print "Port command ";
	print $errors? "failed":"succeeded",".\n";
    }
  finish:
    return $errors
	if ($errors);
    if ($command eq "enable" || $command eq "disable") {
	foreach my $port (@ports) {
	    setPortEnabled($port, ($command eq "enable" ? 1 : 0));
	}
    }
    return $errors;

}

#
# Remove all VLANs from the switch, and re-create them from the database
# tables.
#
sub doRecreateVlans($) {
    my $stacks = shift;

    #
    # Make sure the user REALLY wants to do this
    #

    if (!TBAdmin()) {
	warn "Sorry, only admins get to use this function\n";
	return 0;
    }

    warn "WARNING: Using this function will cause all VLANS to be\n";
    warn "deleted and re-created. This will cause temporary disruption,\n";
    warn "and you will lose all hand-created VLANs. This function operates\n";
    warn "on ALL experimental switches.\n";
    warn "\nAre you SURE you want to do this? (yes/no)\n";

    my $doit = <>;

    if (!($doit =~ /^y/i)) {
	warn "Not recreating VLANs\n";
	return 0;
    } else {
	warn "Okay, recreating VLANs\n";
    }

    #
    # Get a list of all VLANs on all of the given switches, so that we can
    # nuke them.
    #
    my @vlansToNuke = ();
    foreach my $stack (@$stacks) {
	my @stackVlans = $stack->listVlans();
	foreach my $vlan (@stackVlans) {
	    my $id = $$vlan[0];
	    #
	    # Special case - don't try to delete the 'switch-control' VLAN,
	    # because that's the one we're talking to the switches on.
	    #
	    if ($id ne 'switch-control') {
		push (@vlansToNuke,$id);
	    }
	}
    }

    debug("Going to nuke " . join(',',@vlansToNuke) . "\n");

    doDeleteVlan($stacks,@vlansToNuke);

    #
    # Get a list of all experiments, so that we can re-create their VLANs
    #
    my @experiments = Experiment->AllActive();
    foreach my $experiment (@experiments) {
	my @vlans = getExperimentVlans($experiment->pid(), $experiment->eid());
	
	doVlansFromTables($experiment, $stacks, @vlans)
	    if (@vlans);
    }
    return 1;
}

#
# Enable trunking on a port, and enable a set of VLANs on it 
#
sub doTrunkEnable($$$@) {
    my $stacks = shift;
    my $port = shift;
    my $equaltrunking = shift;
    my @vlans = @_;
    my $errors = 0;


    if ($ELABINELAB) {
	my $mode = $equaltrunking ? "-E" : "-T";
	# As below, only one stack.
	my ($stack) = @$stacks;
	$errors = RemoteDoTrunking($stack,$mode,$port,@vlans);
	goto finish;
    }
    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Enabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    print "Enabling trunking (tagging) on $port ...\n"
	if (!$quiet);
    if (!$stack->enableTrunking2($port,$equaltrunking,@vlans)) {
	$errors++;
    }
  finish:
    setPortTagged($port, 1)
	if (!$errors);
    return $errors;
}

#
# Disable trunking on a port
#
sub doTrunkDisable($$) {
    my $stacks = shift;
    my $port = shift;
    my $errors = 0;

    if ($ELABINELAB) {
	my @vlans=();
	# As below, only one stack.
	my ($stack) = @$stacks;
	$errors = RemoteDoTrunking($stack,"-U",$port,@vlans);
	goto finish;
    }
    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Disabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    print "Disabling trunking (tagging) on port $port ...\n"
	if (!$quiet);
    if (!$stack->disableTrunking($port)) {
	$errors++;
    }
  finish:
    setPortTagged($port, 0)
	if (!$errors);
    return $errors;
}
