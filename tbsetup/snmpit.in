#!/usr/bin/perl -w
#
# EMULAB-LGPL
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#

#
# snmpit - A tool for setting up VLANs on SNMP-controllable switches
#

#
# Configure variables
#

use lib '@prefix@/lib';
my $TESTMODE = @TESTMODE@;
my $ELABINELAB = @ELABINELAB@;
my $TB = '@prefix@';

use libdb;
use snmpit_lib;
use snmpit_remote;
use libtblog;

use English;
use Getopt::Long;
use strict;

# Protos
sub parseStatusString($);
sub debug($);
sub doListVlans($);
sub doListPorts($);
sub doPortStatus($@);
sub doGetStats($);
sub doVlansFromTables($@);
sub doReset($@);
sub doMakeVlan($$@);
sub doDeleteVlan($@);
sub doVlanNumber($$);
sub doPortControl($$@);
sub doRecreateVlans($);
sub doTrunkEnable($$@);
sub doTrunkDisable($$);
sub doRestorePortStatus($@);
sub doSynchLeader($);

#
# Defaults
#
my $debug = 0;
my $quiet = 0;

######################################################################
# Step 1 - Process command-line arguments
#
# We have a fairly complex set of command line arguments, and we
# need to make sure that the user only specifies one command at a
# time.
######################################################################
sub usage {
    print << "END";
Usage: $0 [-h] [-v] [-q] [-n] [-i device] [-S stack]
	  [-l] [-s] [-g]
	  [-m name [ports]]
	  [-T port name]
	  [-U port]
	  [-o name]
          [ -N name]
          [-r pid eid]
	  [-t pid eid]
	  [-d ports] [-e ports] [-a ports]
	  [-p <10|100|1000> ports] [-u <half|full> ports]
	  [-c]
General:
  -h          Display this help message
  -v          Verbose mode
  -q          Quiet mode
  -n          Test mode - don't actually make any changes
  -i <device> Operate on <device>, overriding default device list. Can be
                  given multiple times
  -S <stack>  Operate on the given stack, instead of the default of the
                  experimental network

VLAN Control:
  -t <pid> <eid>    Create all VLANs for an experiment
  -r <pid> <eid>    Remove all VLANs for an experiment
                        (you can provide an optional list of vlan ids)
  -l                List all VLANs
  -w                Used with -l, includes device-specific VLAN number
  -M                Used with -l, print MAC addresses instead of port numbers
  -m <name> [ports] Create a new VLAN with name <name>, if it doesn't exist,
                        and put [ports] in it
  -y <type>         When used with -m, the new VLAN becomes a private VLAN
                        of type <type>
  -x <primary>      When used with -y, assocates the new private VLAN with
                        the primary VLAN named <primary>
  -z <port>         Used with -y and -x, to specify which port is to be used
                        with the private VLAN
  -o <name>         Delete the VLAN with name <name>
  -N <name>         Print out the VLAN number for the named VLAN
  -c                Delete ALL VLANs, and recreate from the database. ** USE
                        WITH EXTREME CAUTION **
  -F                Create all vlans in the given stack on the leader for
		    use in leader->{ALLVLANSONLEADER} (Internal use only)

Port Control:
  -s                     List all ports, and show configuration information
  -g                     Get port statistics
  -d <ports>             Disable <ports>
  -e <ports>             Enable <ports>
  -a <ports>             Enable auto-negotiation of port speed/duplex
  -p <10|100> <ports>    Set speed of <ports> to 10 or 100 Mbps
  -u <half|full> <ports> Set duplex of <ports> to half or full
  -T <port> <names>      Enable trunking on the given <port>, and allow VLANs
                             with the given <names> across it
  -E <port> <names>      Like -T, but "Equal" mode; PVID is also tagged
  -U <port>              Turn off trunking for the given <port>
  -b <ports>             Print out port status for a set of ports
  -B <statstring>        Pass in a stat string from -b to restore status

More than one operation can be specified - However, beware that the order in
which operations will occur is undefined, and some combinations of operations
(ie. -d and -e) are non-sensical.
END

    return 1;
}


my %opt = ();
Getopt::Long::Configure("no_ignore_case");
GetOptions(\%opt, 'a','c','d','e','b','B=s@','g','h','i=s@','l','m=s@','M','n',
    'N=s@','o=s@','p=s','q','r','s', 'S=s@','t','E=s','T=s','u=s','U','v=s','w',
    'y=s','x=s','z=s','F');
# Unused: f,j

if ($opt{h}) {
    exit &usage;
}

if ($opt{v}) {
    $debug = $opt{v};
    print "Debug level is $debug\n";
}

if ($opt{q}) {
    $quiet = 1;
}

#
# Values that may have been passed on the command line
#
my $pid;
my $eid;
my @ports;
my @optvlanids = ();
my $equaltrunking = 0;

#
# Some operations have mandatory agruments - for others, make sure that
# the user didn't give any extraneous arguments
#
if ($opt{t} || $opt{r}) {
    #
    # Options that take 'pid eid'
    #
    if (@ARGV < 2) {
	tberror "pid/eid reqired!";
	exit &usage;
    } else {
	($pid, $eid) = (shift @ARGV, shift @ARGV);
    }
    if (@ARGV) {
	@optvlanids = @ARGV;
    }
} elsif ($opt{d} || $opt{e} || $opt{a} || $opt{p} || $opt{u} || $opt{m}
         || $opt{U} || $opt{b}) {
    #
    # Options that take a list of ports
    #
    @ports = @ARGV;
} elsif ($opt{T} || $opt{E}) {
    #
    # Options that take both a port and a list of VLANs - we require at least
    # one VLAN to be given
    #
    if ($opt{E}) { $opt{T} = $opt{E}; $equaltrunking = 1;}
    elsif (!@ARGV) {
	tberror "At least one VLAN required";
	exit &usage;
    }
    @optvlanids = @ARGV;

    #
    # Set the @ports array so that we'll do proper permission checking on it
    #
    @ports = ($opt{T});
} else {
    #
    # Everything else
    #
    if (@ARGV) {
	tberror({type => 'primary', severity => SEV_ERROR,
		 error => ['too_many_arguments']},
		"Too many arguments!");
	exit &usage;
    }
}

#
# Determine which operation we're performing. This is just for convenience,
# so that we can use switch-like constructs later. While we're at it, we
# pull out any arguments that were given in the $opt{} values.
#
my @commands;

#
# Simple commands
#
if ($opt{l}) { push @commands, ["listvlans"]; }
if ($opt{s}) { push @commands, ["listports"]; }
if ($opt{g}) { push @commands, ["getstats"]; }
if ($opt{t}) { push @commands, ["tables"]; }
if ($opt{r}) { push @commands, ["reset"]; }
if ($opt{c}) { push @commands, ["recreate"]; }
if ($opt{U}) { push @commands, ["trunkdisable"]; }
if ($opt{b}) { push @commands, ["portstatus"]; }
if ($opt{F}) { push @commands, ["synchleader"]; }

#
# Commands that can appear once, and take an argument
#
if ($opt{d}) { push @commands, ["portcontrol","disable"]; }
if ($opt{e}) { push @commands, ["portcontrol","enable"]; }
if ($opt{a}) { push @commands, ["portcontrol","auto"]; }
if ($opt{T}) { push @commands, ["trunkenable", $opt{T}]; }

#
# Commands that can occur more than once
#
if ($opt{m}) {
    foreach my $name (@{$opt{m}}) {
	push @commands, ["make",$name];
    }
}

if ($opt{o}) {
    foreach my $name (@{$opt{o}}) {
	push @commands, ["remove",$name];
    }
}

if ($opt{N}) {
    foreach my $name (@{$opt{N}}) {
	push @commands, ["vlannumber",$name];
    }
}

if ($opt{B}) {
    foreach my $statstring (@{$opt{B}}) {
	push @commands, ["restorestatus",$statstring];
        # Set up the @ports variable so that we get permissions checking. Note,
        # though, that we re-parse the strings again later, this is just for
        # permissions
        my %args = parseStatusString($statstring);
        if (!$args{port}) {
            tbdie "No port given in status string";
        }
        if ($args{port}) {
            push @ports, convertPortsFromIfaces($args{port});
        }
    }
}

#
# Commands that require 'translation' of their arguments
#
if ($opt{p}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{p} =~ /^1000/) {
	push @commands, ["portcontrol","1000mbit"];
    } elsif ($opt{p} =~ /^100/) {
	push @commands, ["portcontrol","100mbit"];
    } elsif ($opt{p} =~ /^10/) {
	push @commands, ["portcontrol","10mbit"];
    } else {
	tbreport(SEV_ERROR, 'bad_data', 'port_speed', $opt{p});
	die "Bad port speed: $opt{p}. Valid values are 10, 100, and 1000\n";
    }
}
if ($opt{u}) {
    #
    # We'll put the argument in the form needed by the portControl function
    #
    if ($opt{u} =~ /half/) {
	push @commands, ["portcontrol","half"];
    } elsif ($opt{u} =~ /full/) {
	push @commands, ["portcontrol","full"];
    } else {
	die "Bad port duplex: $opt{u}. Valid values are full and half\n";
    }
}

if (!@commands) {
    tbreport(SEV_ERROR, 'no_operation');
    die "No operation given\n";
}

#
# Options that affect other commands
#

#
# User-supplied switch lists
#
my @supplied_switches = ();
my @supplied_stacks = ();
my $supplied_switches = 0; # Whether -i or -S was given
if ($opt{i}) {
    $supplied_switches = 1;
    push @supplied_switches, @{$opt{i}};
}
if ($opt{S}) {
    foreach my $stack (@{$opt{S}}) {
	$supplied_switches = 1;
	my @switches = getSwitchesInStack($stack);
	if (@switches) {
	    push @supplied_stacks, $stack;
	} else {
	    tbdie({type => 'primary', severity => SEV_ERROR,
		   error => ['invalid_switch_stack', $stack]},
		  "No such switch stack: $stack");
	}
    }
}

#
# Arguments for making private VLANs
#
# Build up a list of extra arguments to be passed to createVlan()
my @pvlanArgs = ();
if ($opt{y}) {
    #
    # Make sure the private VLAN type they gave is valid, and make sure they
    # gave the other required arugments for certain types
    #
    if ($opt{y} ne "primary" && $opt{y} ne "isolated" &&
	$opt{y} ne "community") {
	die "Unknown private VLAN type $opt{y}\n";
    }
    @pvlanArgs = $opt{y};
    if ($opt{y} ne "primary") {
	if (!$opt{x} || !$opt{z}) {
	    tberror "-x and -z must be given when -y is $opt{y}!";
	    exit &usage;
	}
	#
	# Fix up ports given in the module/port format, like we do below for
	# ports from @ARGV
	#
	if ($opt{z} =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$opt{z} = $opt{i}->[0] . "." . $opt{z};
	    } else {
		tbdie "The module/port format is only legal if exactly one -i " .
		    "argument has been given";
	    }
	}
	push @pvlanArgs,$opt{x},$opt{z};
    }
}

######################################################################
# Step 3 - Set up the stack objects
#
# Determine which devices to talk to, and make the appropriate
# stack objects
######################################################################

#
# If this is an operation on an experiment, make sure that they have permission
# to modify that experiment
#
if ($pid && $eid) {
    #
    # First, make sure the experiment exists
    #
    if (!ExpState($pid,$eid)) {
	die "There is no experiment $eid in project $pid\n";
    }
    if ($UID && !TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_MODIFY)) {
	die "You do not have permission to modify experiment $pid/$eid\n";
    }
}

#
# If their operation involves a set of ports, make sure that the caller has
# access to the nodes that the ports are on
#

# Convert ports into the correct format
if (@ports) {
    @ports = convertPortsFromIfaces(@ports);
}

if (@ports) {
    #
    # Allow ports to be given in one of two forms: node:port, or switch.port.
    # Only admins can do the latter, of course...
    #
    my (@nodes, @switchports);
    foreach my $port (@ports) {
	if ($port =~ /^([^:]+):\d+$/) {
	    push @nodes, $1;
	} elsif ($port =~ /^([^.]+)\.\d+(\/\d+)?$/) {
	    push @switchports, $port;
	} elsif ($port =~ /^\d+\/\d+?$/) {
	    if ($opt{i} && @{$opt{i}} == 1) {
		$port = $opt{i}->[0] . "." . $port;
		push @switchports, $port;
	    } else {
		die "The module/port format is only legal if exactly one -i " .
		    "argument has been given\n";
	    }
	} else {
	    tbreport(SEV_ERROR, 'bad_data', 'port', $port);
	    die "Bad format for port $port\n"
	}
    }

    if ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_MODIFYVLANS,@nodes)) {
	tbreport(SEV_ERROR, 'insufficient_permissions');
	die "You do not have permission to modify some or all of the nodes\n" .
		"that will be affected by the operation you requested\n";
    }

    if (@switchports && !TBAdmin()) {
	die "Only admins are allowed to modify switch ports directly\n";
    }
}

if ($TESTMODE) {
    print "Test mode, exiting without touching hardware\n";
    exit(0);
}

#
# snmpit_lib fills out some hashes for speed of lookup later. Initialize
# them now
#
snmpit_lib::init($debug);

my $exitval = 0;
foreach my $command (@commands) {

    #
    # Pull the operation and the arugments to it.
    #
    my ($operation,@args) = @$command;

    debug("Operation is $operation\n");

    #
    # Discover the set of devices we need to talk to. This differs depending
    # on the operation which we're performing. We also get a list of all ports
    # and vlan IDs involved in this operation, if appropriate
    #
    my @devicenames;
    my @vlans;
    SWITCH: for ($operation) {
	(/listvlans/ || /getstats/ || /make/ || /remove/ || /vlannumber/ || /synchleader/) && do {
	    @devicenames = $supplied_switches?
			   @supplied_switches : getTestSwitches();
	    last;
	};
	(/listports/) && do {
	    @devicenames = $supplied_switches? @supplied_switches :
	    (@ports? getDeviceNames(@ports) : getTestSwitches());
	    last;
	};
	(/tables/) && do {
	    @vlans = getExperimentVlans($pid,$eid,@optvlanids);
	    @ports = getVlanPorts(@vlans);
	    @devicenames = $supplied_switches?
			   @supplied_switches : getTestSwitches();
	    last;
	};
	(/reset/) && do {
	    #
	    # When we reset, we operate on all test switches, just to be safe
	    #
	    @vlans = getExperimentVlans($pid,$eid,@optvlanids);
	    @devicenames = $supplied_switches?
			   @supplied_switches : getTestSwitches();
	    last;
	};
	(/portcontrol/ || /trunkdisable/ || /portstatus/) && do {
	    @devicenames = $supplied_switches?
	    		   @supplied_switches : getDeviceNames(@ports);
	    last;
	};
	(/recreate/) && do {
	    #
	    # Safety check - cannot be used with -i . We have to operate on
	    # all experimental switches
	    #
	    if ($supplied_switches) {
		die "-c and -i or -S cannot be used together\n";
	    }
	    @devicenames = getTestSwitches();
	    last;
	};
	(/trunkenable/) && do {
	    @devicenames = $supplied_switches?
	    		   @supplied_switches : getDeviceNames(@ports);
	    @vlans = @optvlanids;
	    last;
	};
        (/restorestatus/) && do {
            # We start by parsing out the options string, then we'll reset
            # @args
            my ($statusarg) = @args;
            my %args = parseStatusString($statusarg);
            if (!$args{port}) {
                tbdie "No port given in status string";
            }
            @ports = convertPortsFromIfaces($args{port});
            if ($args{vlan}) {
                @vlans = ($args{vlan});
            }
            @devicenames = $supplied_switches?
                           @supplied_switches : getDeviceNames(@ports);

            @args = %args;
            last;
        };
    }

    debug("Device names: " . join(",",@devicenames) . "\n");
    debug("Ports: " . join(",",@ports) . "\n");
    if (@vlans) { debug("VLANs: " . join(",",@vlans) . "\n") };

    my %stacks = ();
    if (! $ELABINELAB) {
	#
	# First, look at the device names we've got and map them to stacks 
	#
	foreach my $devicename (@devicenames) {
	    my $stack = getSwitchPrimaryStack($devicename);
	    if (defined($stack)) {
		push @{$stacks{$stack}}, $devicename;
	    }
	}
	#
	# Next, add in stacks that were specified as a whole
	#
	foreach my $stack (@supplied_stacks) {
	    # We checked for non-existent stacks above
	    my @switches = getSwitchesInStack($stack);
	    push @{$stacks{$stack}}, @switches;
	}
    }

    #
    # Now, make the object for each stack that we discovered
    #
    my @stacks;
    my %stack_ids;
    foreach my $stack_id (keys %stacks) {
	my ($stack_type, $supports_private, $single_domain, $community)
		= getStackType($stack_id);
	#
	# Safety check - make sure the stack supports private VLANs if -y was
	# given
	#
	if ($opt{y} && !$supports_private) {
	    die "Switch stack $stack_id does not support private VLANs\n";
	}

	my $stack;
	debug("Stack $stack_id has type $stack_type\n");
	SWITCH: for ($stack_type) {
	    (/cisco/ || /catalyst/) && do {
		require snmpit_cisco_stack;
		$stack = new snmpit_cisco_stack($stack_id,$debug,$single_domain,
		    @{$stacks{$stack_id}});
		last;
	    }; # /cisco/
	    /intel/ && do {
		require snmpit_intel_stack;
		$stack = new snmpit_intel_stack($stack_id,$debug,
		    @{$stacks{$stack_id}});
		last;
	    };
	    /generic/ && do {
		require snmpit_stack;
		$stack = new snmpit_stack($stack_id,$debug,
		    @{$stacks{$stack_id}});
		last;
	    }; # /generic/

	    # 'default' case
	    die "Unknown stack type $stack_type for stack $stack_id\n";
	}

	#
	# Check for error in object creation and bail
	#
	if (!$stack) {
	    die "Unable to connect to one or more switches, exiting\n";
	} else {
	    push @stacks, $stack;
	    $stack_ids{$stack_id} = $stack;
	}
    }


    #
    # If we were given ports, make sure that the stack(s) that got created
    # cover all of them
    #
    if (@ports && !$ELABINELAB) {
	my %devicemap = mapPortsToDevices(@ports);
	my @devices = keys %devicemap;
	foreach my $device (@devices) {
	    my @stack_ids = getSwitchStacks($device);
	    my $matched = 0;
	    foreach my $stack_id (@stack_ids) {
		if ($stack_id && $stack_ids{$stack_id}) {
		    $matched = 1;
		}
	    }
	    if (!$matched) {
		tbdie({type => 'primary', severity => SEV_ERROR,
		       error => ['device_not_in_stack', $device]},
		      "One or more ports are on $device, but no " .
		      "stack containing it was specified!");
	    }
	}
    }

######################################################################
# Step 4 - Actually perfrom the operation
#
# Finally, we just call the helper function for the operation that
# is to be performed.
######################################################################
    if ($opt{n}) {
	print "Test mode, skipping operation\n";
	next;
    }

    SWITCH: for ($operation) {
	/listvlans/ && do {
	    $exitval += doListVlans(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/synchleader/ && do {
	    $exitval += doSynchLeader(\@stacks);
	    last;
	}; # /listvlans/ && do 
	/listports/ && do {
	    $exitval += doListPorts(\@stacks);
	    last;
	}; # /listports/ && do
	/getstats/ && do {
	    $exitval += doGetStats(\@stacks);
	    last;
	}; # /ports/ && do
	/tables/ && do {
	    $exitval += doVlansFromTables(\@stacks,@vlans);
	    last;
	}; # /tables/ && do
	/reset/ && do {
	    $exitval += doReset(\@stacks,@vlans);
	    last;
	};
	/make/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doMakeVlan(\@stacks,$vlan_name,@ports);
	    last;
	};
	/remove/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doDeleteVlan(\@stacks,$vlan_name);
	    last;
	};
	/portcontrol/ && do {
	    my ($portcommand) = @args;
	    $exitval += doPortControl(\@stacks,$portcommand,@ports);
	    last;
	};
	/recreate/ && do {
	    $exitval += doRecreateVlans(\@stacks);
	    last;
	};
	/trunkenable/ && do {
	    my ($port) = @args;
	    $exitval += doTrunkEnable(\@stacks,$port,@vlans);
	    last;
	}; # /trunkenable/ && do
	/trunkdisable/ && do {
	    $exitval += doTrunkDisable(\@stacks,$ports[0]);
	    last;
	}; # /trunkdisable/ && do
	/portstatus/ && do {
	    $exitval += doPortStatus(\@stacks,@ports);
	    last;
	}; # /portstatus/ && do
	/vlannumber/ && do {
	    my ($vlan_name) = @args;
	    $exitval += doVlanNumber(\@stacks,$vlan_name);
	    last;
	}; # /portstatus/ && do
	/restorestatus/ && do {
	    $exitval += doRestorePortStatus(\@stacks,@args);
	    last;
	}; # /portstatus/ && do
    }
}

exit $exitval;

######################################################################
# Subs
######################################################################

#
# Print given message to STDERR, only if debug mode is on
#
sub debug($) {
    if ($debug) {
	print STDERR @_;
    }
}

#
# Parse a port status string. Returns a key-value hash pair
#
sub parseStatusString($) {
    my ($string) = @_;
    chomp $string;

    my %pairs;
    foreach my $pair (split /;/, $string) {
        my ($key, $value) = split /=/,$pair,2;
        if (!$key || !$value) {
            tbdie "Bad port status string: $string";
        } else {
            $pairs{$key} = $value;
        }
    }

    return %pairs;
}

#
# Lists all vlans on all stacks
#
sub doListVlans ($) {

    my $stacks = shift;
    
    my %vlans;

    #
    # We need to 'coallate' the results from each stack by putting together
    # the results from each stack, based on the VLAN identifier
    #
    foreach my $stack (@$stacks) {
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
	    ${$vlans{$id}}[0] = $ddep;
	    push @{${$vlans{$id}}[1]}, @$memberref;
	}
    }

    #
    # These need to be declared here for the benefit of the format string
    # See perlform(1) for help with formats
    #
    my ($vlan_id,$ddep,$pideid,$vname,$members);
    #
    # Check to see if they want device-specific VLAN numbers, which makes the
    # display more cramped, but is useful for debugging
    #
    if (!$opt{w}) { 
	print << "END";
VLAN     Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist =
@<<<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$pideid,           $vname,   $members
~~                                    ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                      $members
.
	$FORMAT_NAME = 'vlanlist';
    } else {
    	print << "END";
VLAN     Number Project/Experiment VName     Members
--------------------------------------------------------------------------------
END
	format vlanlist2 =
@<<<<<<< @<<<<< @<<<<<<<<<<<<<<<<< @<<<<<<<< ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$vlan_id,$ddep, $pideid,           $vname,   $members
~~                                           ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
                                             $members
.
	$FORMAT_NAME = 'vlanlist2';
}

    foreach my $vid (sort {tbsort($a,$b)} keys %vlans) {
        $vlan_id = $vid;
	my $memberref;
	($ddep,$memberref) = @{$vlans{$vid}};

	#
	# Find which, if any, experiment this VLAN belongs to.
	#
	my $result = DBQueryFatal("select pid, eid, virtual from " .
				  "vlans where id='$vid'");
	my ($eid,$pid);
	($pid,$eid,$vname) = $result->fetchrow();

	#
	# Permissions check - people only get to see their own VLANs
	#
	if ((!$eid) || (!$pid)) {
	    if (!TBAdmin()) {
		&debug("Failed TBAdmin check\n");
		next;
	    }
	} elsif ($UID && !TBExptAccessCheck($UID,$pid,$eid,TB_EXPT_READINFO)) {
	    &debug("Failed TBExptAccessCheck($UID,$pid,$eid)\n");
	    next;
	}


	if (!$vname) { $vname = ""; }

	#
	# Check to see if we were supposed to print out MAC addresses
	#
	if ($opt{M}) {
	    # Rather than node:port, print out node:MAC (if we know the MAC)
	    $members = join(" ", map
		{
		    macport($_)? (split /:/)[0] . ":" . macport($_) : $_
		} @$memberref);
	} else {
	    $members = join(" ",@$memberref);
	}

	#
	# Setup $pideid for a more compact display
	#
	if ($eid && $pid) {
	    $pideid = "$pid/$eid";
	} else {
	    $pideid = "";
	}
	write;
    }

    return 0;
}

#
# This routine does a number of illegal things.  It is used
# to make sure the leader of a stack contains all vlans on all switches
# in the stack and is only useful for moving a stack back and forth
# between types "cisco" and "generic" (where $stack->{ALLVLANSONLEADER} must be
# set to 1.
#
sub doSynchLeader ($) {

    my $stacks = shift;
    my $errors = 0;
    if (!TBAdmin()) {
	die "Only admins are allowed to synchronize stacks\n";
    }

    foreach my $stack (@$stacks) {
	my $leader = $stack->{LEADER};
	my %vlans = $stack->findVlans();
	while (my ($id,$num) = each %vlans) {
	    if (($num >= $leader->{MIN_VLAN}) &&
		($num <= $leader->{MAX_VLAN}) &&
		!($leader->vlanNumberExists($num))) {
			$errors += $leader->createVlan($id, $num);
	    }
	}
    }
    return $errors;
}

#
# Lists all ports on all stacks
#
sub doListPorts($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # See perlform(1) for help with formats
    #
    my ($port,$enabled,$up,$speed,$duplex);
    print << "END";
Port      Enabled Up   Speed      Duplex
--------------------------------------------
END
    format portlist =
@<<<<<<<< @<<<<<< @<<< @<<<<<<<<< @<<<<<<<<<
$port,    $enabled,$up,$speed,$duplex
.
    $FORMAT_NAME = 'portlist';
    foreach my $line (sort {tbsort($$a[0],$$b[0])} @portList) {
	($port,$enabled,$up,$speed,$duplex) = @$line;
	#
	# Only let people see information about ports in their experiments
	#
	$port =~ /^(.+):/;
	my $node = $1;

	&debug("node is $node\n");
	if (!$node) {
	    if (!TBAdmin($UID)) {
		next;
	    }
	} elsif ($UID && !TBNodeAccessCheck($UID,TB_NODEACCESS_READINFO,$node)) {
	    next;
	}
	write;
    }

    return 0;
}

#
# Get information on a particular port - the idea is that this string can later
# be passed back to us to restore the status of the port.
# This is inefficient, because it gets information about all ports and only
# uses it for one (or a few). BUT, it doesn't require changes to the
# vendor-specific modules, so I think it's worth it for portability.
#
sub doPortStatus($@) {

    my $stacks = shift;
    my @port = @_;

    my $errors = 0;

    #
    # Get a listing from all stacks
    #
    my @portList = ();
    foreach my $stack (@$stacks) {
	push @portList, $stack->listPorts;
    }

    #
    # Find the port(s) we're looking for in the portlist
    #
    my %ports = ();
    foreach my $port (@ports) {
        $ports{$port} = undef;
    }
    foreach my $portrecord (@portList) {
	my ($port,$enabled,$up,$speed,$duplex) = @$portrecord;
        if (exists $ports{$port}) {
            $ports{$port} = "enabled=$enabled";
            $ports{$port} .= ";speed=$speed";
            if ($speed ne "autoDetect") {
                $ports{$port} .= ";duplex=$duplex";
            }
        }
    }

    #
    # Now find out what VLAN it's in
    #
    foreach my $stack (@$stacks) {
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            # Now we have to look through the memberref for our ports
            foreach my $port (@$memberref) {
                if ($ports{$port}) {
                    $ports{$port} .= ";vlan=$id";
                }
            }
	}
    }

    #
    # XXX - This is gonna be a mess if the port is a trunk port, or otherwise
    # somehow more complicated. For now, we just ignore this, I guess
    #

    #
    # Check to see if we missed any
    #
    foreach my $port (keys %ports) {
        if (!$ports{$port}) {
	    tberror({type => 'primary', severity => SEV_ERROR,
		     error => ['get_port_status_failed', $port]},
		    "Unable to get status information for $port!");
            $errors++;
        } else {
            print "port=$port;$ports{$port}\n";
        }
    }

    if ($errors) {
        return $errors;
    }

}

#
# Restore port status. Takes a single argument, which is an array that will be
# turned back into a param hash
#
sub doRestorePortStatus($@) {

    my $stacks = shift;
    my %params = @_; # Yes, this does work

    my $port = $params{port};
    if (!$port) {
        tbdie "No port passed to -B option";
    }

    if (@$stacks > 1) {
	die "Port restoration accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    my $errors = 0;

    # Put the port in the specified VLAN
    # If they didn't give us a VLAN, we assume that means they want it removed
    # from its vlan
    my $vlan = $params{vlan};
    if (!$vlan) { $vlan = "default"; }
    $errors += $stack->setPortVlan($vlan,$port);
    if ($errors) { return $errors; }

    # Enable or disable the port
    # If they didn't tell us either way, we assume they wanted it disabled
    my $enabled = $params{enabled};
    # If they are putting the port into the default VLAN, force it to be
    # disabled, so that a user cannot use this method to break into that VLAN
    if ($vlan eq "default") { $enabled = "no"; }
    if ($enabled eq "yes") {
        $errors = $stack->portControl("enable",$port);
    } else {
        $errors = $stack->portControl("disable",$port);
    }

    #
    # Set the speed and duplex on the port if given
    #
    my $speed = $params{speed};
    if ($speed && $speed ne " ") {
        if ($speed eq "autoDetect") {
            $errors = $stack->portControl("auto",$port);
        } else {
            #
            # Check for a valid speed - convert Mbps to mbit if necessary
            #
            if ($speed =~ /(\d+)(Mbps|mbit)/) {
                $errors = $stack->portControl("${1}mbit",$port);
            } else {
                tbwarn "Bad speed given for $port: $speed";
                $errors++;
            }
        }
    }
    my $duplex = $params{duplex};
    if ($duplex && $duplex ne " ") {
        if ($duplex eq "half") {
            $errors = $stack->portControl("half",$port);
        } elsif ($duplex eq "full") {
            $errors = $stack->portControl("full",$port);
        } else {
            tbwarn "Bad duplex given for $port: $duplex";
            $errors++;
        }
    }
    return $errors;
}

#
# Get statistics for all ports on all stacks
#
sub doGetStats($) {

    my $stacks = shift;

    #
    # Get a listing from all stacks
    #
    my @statList = ();
    foreach my $stack (@$stacks) {
	push @statList, $stack->getStats();
    }

    my ($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
        $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	$outerr,$outq);
    #
    # See perlform(1) for help with formats
    #
    print << "END";
          In         InUnicast  InNUnicast In         In         Unknown    Out        OutUnicast OutNUcast  Out       Out         OutQueue
Port      Octets     Packets    Packets    Discards   Errors     Protocol   Octets     Packets    Packets    Discards  Errors      Length
---------------------------------------------------------------------------------------------------------------------------------------------
END
    format stats =
@<<<<<<<< @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> @>>>>>>>>> 
$port,    $inoctets, $inunicast,$innunicast,$indiscards,$inerr,  $inunk,    $outoctets,$outunicast,$outnunicast,$outdiscards,$outerr,$outq
.
    $FORMAT_NAME = 'stats';
    foreach my $line (sort {tbsort($a,$b)} @statList) {
	($port, $inoctets, $inunicast, $innunicast, $indiscards, $inerr,
	 $inunk, $outoctets, $outunicast, $outnunicast, $outdiscards,
	 $outerr, $outq) = @$line;
	write;
    }

    return 0;
}

#
# Creates all VLANs given. Looks up identifiers in the database to determine
# the membership.
#
sub doVlansFromTables($@) {
    my $stacks = shift;
    my @vlans = @_;

    my $errors = 0;
    my $vlan_number;
    my $oEopt = $equaltrunking;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoVlansFromTables(@vlans);
    }

    my @trunkedPorts = getExperimentTrunks($pid,$eid);
    $equaltrunking = 1;
    foreach my $port (@trunkedPorts) {
	$errors += doTrunkEnable($stacks,$port);
    }
    $equaltrunking = $oEopt;

    foreach my $vlan (@vlans) {
	my @ports = getVlanPorts($vlan);
	if ($stack->vlanExists($vlan)) {
	    print "  VLAN $vlan already exists\n"
		if (!$quiet);
	    $errors += $stack->setPortVlan($vlan,@ports);
	} else {
	    $vlan_number = $stack->createVlan($vlan,\@ports);
	    if (!$vlan_number) {
		tberror({type => 'secondary', severity => SEV_SECONDARY,
			 error => ['create_vlan_failed', $vlan]},
			"Failed to create VLAN with id $vlan");
		#
		# Don't try to put ports in a VLAN if it couldn't be created
		#
		$errors++;
	    } else { setVlanTag($vlan, $vlan_number); }
	}

	#
	# Set the speed and duplex of each interface depending on the
	# value in the database
	#
	foreach my $port (@ports) {
	    my ($speed,$duplex) = getInterfaceSettings($port);
	    #
	    # If either is not set, we do nothing. We could make
	    # a 0 mean 'auto'
	    #
	    # For now, we ignore it if the switch doesn't support the commands.
	    if ($speed) {
		my $cmd = $speed . "mbit";
		my $rv = $stack->portControl($cmd, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}

	    }
	    if ($duplex) {
		my $rv = $stack->portControl($duplex, $port);
		if ($rv > 0) {
		    $errors += $rv;
		}
	    }
	}
    }

    return $errors;
}

#
# Remove all VLANs given from every switch in the stack. All ports in the
# VLANs are removed, irrespective of what the database says membership should
# be
#
sub doReset($@) {
    my $stacks = shift;
    my @vlans = @_;

    #
    # Hand over to outer boss.
    # 
    if ($ELABINELAB) {
	return RemoteDoReset(@vlans);
    }

    my $errors = 0;
    my @trunkedPorts = getExperimentTrunks($pid,$eid);
    foreach my $port (@trunkedPorts) {
	$errors += doTrunkDisable($stacks,$port);
    }
    #
    # Just remove the VLAN from evey stack on which it exists. We keep a
    # list and do them all at once for efficiency.
    #
    foreach my $stack (@$stacks) {
	my @existant_vlans = $stack->existantVlans(@vlans);
	if (!$stack->removeVlan(@existant_vlans)) {
	    $errors++;
	}
	foreach my $vlan (@existant_vlans) {
	    setVlanTag($vlan, 0);
	}
    }
    return $errors;
}

#
# Create a vlan with name $vlan_name. It is not an error to try to create a
# VLAN that already exists, as this can be used to add ports to an existing
# VLAN. If ports are given, they are put into the VLAN.
#
sub doMakeVlan($$@) {
    my $stacks = shift;
    my $vlan_name = shift;
    my @ports = @_;

    my $errors = 0;

    if (@$stacks > 1) {
	die "VLAN creation accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    #
    # Create it if it doesn't already exist
    #
    if ($stack->vlanExists($vlan_name)) {
	print "VLAN $vlan_name already exists\n"
	    if (!$quiet);
	#
	# Put requested ports into the VLAN
	#
	if (@ports) {
	    print "Putting ports in VLAN ...\n"
		if (!$quiet);
	    my $perrors = $stack->setPortVlan($vlan_name,@ports);
	    if (!$quiet) {
		print "VLAN change ";
		print $perrors? "failed":"succeeded",".\n";
	    }
	    $errors += $perrors;

	}
    } else {
	print "Creating VLAN $vlan_name ...\n"
	    if (!$quiet);
	my $ok = $stack->createVlan($vlan_name,\@ports,@pvlanArgs);
	if (!$quiet) {
	    print "VLAN creation ";
	    print $ok? "succeeded":"failed",".\n";
	}
	if (!$ok) {
	    $errors++;
	}
    }

    return $errors;
}

#
# Delete the given VLAN, if it exists
#
sub doDeleteVlan($@) {
    my $stacks = shift;
    my @vlan_names = @_;

    my $errors = 0;

    my %exists = ();
    foreach my $stack (@$stacks) {
	my @existant_vlans;
	foreach my $vlan_name (@vlan_names) {
	    if ($stack->vlanExists($vlan_name)) {
		$exists{$vlan_name} = 1;
		push @existant_vlans, $vlan_name;
	    }
	}
	if (@existant_vlans) {
	    print "Deleting VLAN(s) " . join(",",@existant_vlans) . " ...\n"
		if (!$quiet);
	    my $ok = $stack->removeVlan(@existant_vlans);
	    if (!$quiet) {
		print "VLAN deletion ";
		print $ok? "succeeded":"failed",".\n";
	    }
	    if (!$ok) {
		$errors++;
	    }
	}
    }

    foreach my $vlan_name (@vlan_names) {
	if (!$exists{$vlan_name}) {
	    print "VLAN $vlan_name does not exist\n";
	    $errors++;
	}
    }

    return $errors;
}

#
# Print the device-dependant VLAN number for a given named VLAN
#
sub doVlanNumber ($$) {

    my $stacks = shift;
    my $name = shift;

    my $found = 0;

    #
    # Allow the user to give us multiple stacks
    #
    foreach my $stack (@$stacks) {
        #
        # TODO: This is horrendously inefficient! But, it allows me to write
        # this function without requiring more from the switch/stack modules.
        # Once a specialized function has been added to the switch/stack API,
        # we should use it here.
        #
	my @vlanList = $stack->listVlans();
	foreach my $vlan (@vlanList) {
	    my ($id,$ddep,$memberref) = @$vlan;
            if ($id eq $name) {
                $found = 1;
                print "$name $stack->{STACKID} $ddep\n";
            }
	}
    }

    if ($found) {
        return 0; 
    } else {
        return 1;
    }

}

#
# Send $command to @ports.
# TODO: List of commands
#
sub doPortControl($$@) {
    my $stacks = shift;
    my $command = shift;
    my @ports = @_;

    if (@$stacks > 1) {
	die "Port control accross multiple stacks is not yet supported\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }
    my ($stack) = @$stacks;

    print "Applying command '$command' to ports " . join(",",@ports) . " ...\n"
	if (!$quiet);
    my $errors = $stack->portControl($command,@ports);
    if (!$quiet) {
	print "Port command ";
	print $errors? "failed":"succeeded",".\n";
    }

    return $errors;

}

#
# Remove all VLANs from the switch, and re-create them from the database
# tables.
#
sub doRecreateVlans($) {
    my $stacks = shift;

    #
    # Make sure the user REALLY wants to do this
    #

    if (!TBAdmin()) {
	warn "Sorry, only admins get to use this function\n";
	return 0;
    }

    warn "WARNING: Using this function will cause all VLANS to be\n";
    warn "deleted and re-created. This will cause temporary disruption,\n";
    warn "and you will lose all hand-created VLANs. This function operates\n";
    warn "on ALL experimental switches.\n";
    warn "\nAre you SURE you want to do this? (yes/no)\n";

    my $doit = <>;

    if (!($doit =~ /^y/i)) {
	warn "Not recreating VLANs\n";
	return 0;
    } else {
	warn "Okay, recreating VLANs\n";
    }

    #
    # Get a list of all VLANs on all of the given switches, so that we can
    # nuke them.
    #
    my @vlansToNuke = ();
    foreach my $stack (@$stacks) {
	my @stackVlans = $stack->listVlans();
	foreach my $vlan (@stackVlans) {
	    my $id = $$vlan[0];
	    #
	    # Special case - don't try to delete the 'switch-control' VLAN,
	    # because that's the one we're talking to the switches on.
	    #
	    if ($id ne 'switch-control') {
		push (@vlansToNuke,$id);
	    }
	}
    }

    debug("Going to nuke " . join(',',@vlansToNuke) . "\n");

    doDeleteVlan($stacks,@vlansToNuke);

    #
    # Get a list of all experiments, so that we can re-create their VLANs
    #
    my @expts = ();
    my $result = DBQueryFatal("select pid,eid from experiments ".
    	"where state = '". EXPTSTATE_ACTIVE. "'");
    while (my ($pid,$eid) = $result->fetchrow()) {
	my @vlans = getExperimentVlans($pid,$eid);
	doVlansFromTables($stacks,@vlans);
    }

    return 1;

}

#
# Enable trunking on a port, and enable a set of VLANs on it 
#
sub doTrunkEnable($$@) {
    my $stacks = shift;
    my $port = shift;
    my @vlans = @_;

    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Enabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    print "Enabling trunking on $port ...\n"
	if (!$quiet);
    return !($stack->enableTrunking2($port,$equaltrunking,@vlans));
}

#
# Disable trunking on a port
#
sub doTrunkDisable($$) {
    my $stacks = shift;
    my $port = shift;

    #
    # Sanity checking
    #
    if (@$stacks != 1) {
	die "Disabling trunk ports should only involve one stack\n" .
	    "Stacks are " . join(",",@$stacks) . "\n";
    }

    #
    # Simple, just call the right function on the stack
    #
    my $stack = $$stacks[0];
    my $errors = 0;
    print "Disabling trunking on port $port ...\n"
	if (!$quiet);
    if (!$stack->disableTrunking($port)) {
	$errors++;
    }
    return $errors;
}
