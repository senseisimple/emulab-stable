#!/usr/bin/perl -wT

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Set groups for users. With just a pid all the users in the group
# are modified. Of course, since we might be removing groups, we actuall
# have to go through the entire set of users in the project. Hence, you
# can provide an optional list of users to operate on; the web interface
# uses this option since it know what users have been changed via the web
# form.
#
# Note that this script does not create accounts or groups. That should
# already have been done with other scripts.
#
sub usage()
{
    print STDOUT
	"Usage: setgroups -p <pid> [user ...]\n".
        "       setgroups [user ...]\n";

    exit(-1);
}

sub fatal($);

my $optlist = "dp:";
my $debug   = 0;
my $optarg  = "";

#
# Configure variables
#
my $TB      = "@prefix@";
my $TBOPS   = "@TBOPSEMAIL@";
my $TBLOGS  = "@TBLOGSEMAIL@";
my $CONTROL = "@USERNODE@";
my $BOSSNODE= "@BOSSNODE@";
my $ADMINGRP= "@TBADMINGROUP@";
my $ELABINELAB    = @ELABINELAB@;
my $WIKISUPPORT   = @WIKISUPPORT@;
my $BUGDBSUPPORT  = @BUGDBSUPPORT@;
my $SETWIKIGROUPS = "$TB/sbin/setwikigroups";
my $SETBUGDBGROUPS= "$TB/sbin/setbugdbgroups";

my $SSH     = "$TB/bin/sshtb";
my $USERMOD = "/usr/sbin/pw usermod";
my $SAVEUID = $UID;

my $dbuid;
my @userlist = ();
my $pid;
my $user_name;
my $user_email;
my $logname;
my @db_row;
my $query_result;

#
# Note hardwired control node.
#
my $control_node = $CONTROL;

#
# Untaint the path
#
$ENV{'PATH'} = "/bin:/usr/bin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff.
#
use lib "@prefix@/lib";
use libaudit;
use libdb;
use libtestbed;

#
# We do not want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

#
# This script is setuid, so please do not run it as root. Hard to track
# what has happened.
#
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root! Its already setuid!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug  = 1;
    $optarg = "-d";
}
if (defined($options{"p"})) {
    $pid = $options{"p"};

    #
    # Untaint,
    #
    if ($pid =~ /^([-\@\w]+)$/) {
	$pid = $1;
    }
    else {
	die("Bad data in pid: $pid.");
    }
}

#
# See if a userlist was provided. This is an optimization. The web interface
# knows which users actually changed, so its quicker to modify that set
# instead of the entire project set.
#
if (@ARGV) {
    # Untaint the users.
    foreach my $user ( @ARGV ) {
	if ($user =~ /^([\w]+)$/) {
	    $user = $1;
	}
	else {
	    die("Bad user name: $user.");
	}

	push(@userlist, $user);
    }
}

if (!defined($pid) && !scalar(@userlist)) {
    usage();
}

#
# Get user DB uid.
#
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
        "    You do not exist in the Emulab Database!\n");
}

#
# Get email info.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
        "    Cannot determine email info for you!\n");
}

#
# This script always does the right thing, so it does not matter who
# calls it.
#
# This script is always audited. Mail is sent automatically upon exit.
#
if (AuditStart(0)) {
    #
    # Parent exits normally
    #
    exit(0);
}

#
# All this stuff must be done as root (ssh).
#
$UID = $EUID;

#
# If no user list provided, we have to do this for the entire project
# member list since we have no idea who got changed.
#
if (! scalar(@userlist)) {
    $query_result =
	DBQueryFatal("select uid from group_membership ".
		     "where pid='$pid' and pid=gid");

    $query_result->numrows ||
	fatal("No project members for $pid!\n");

    while (@db_row = $query_result->fetchrow_array() ) {
	push(@userlist, $db_row[0]);
    }
}

#
# Loop through user set, building up the group set and issuing commands.
#
foreach my $uid (@userlist) {
    my @groupnames;
    my @grouplist;
    my $groupargument;
    my $project;

    $query_result = DBQueryFatal("select webonly from users ".
				 "where uid='$uid' and webonly=1");
    if ($query_result->numrows) {
	print "Skipping $uid; webonly account!\n";
	next;
    }

    #
    # Form a list of project (group) membership names. We do this in two
    # steps to ensure that we get the default group membership since we
    # want that to be the users primary group. Not sure this really matters
    # all that much, but might as well.
    #
    $query_result =
	DBQueryFatal("select g.unix_name from group_membership as m ".
		     "left join groups as g on m.pid=g.pid and m.gid=g.gid ".
		     "where m.uid='$uid' and m.pid=m.gid and m.trust!='none'");

    if (!$query_result->numrows) {
	#
	# See if an active user with no project membership. If so, then
	# set groups to just the guest group. If not active, skip
	# (non-fatal) since there can be group members not approved,
	# and this is called from the editgroups web page.
	#
	$query_result =
	    DBQueryFatal("select status from users ".
			 "where uid='$uid' and webonly=0 ".
			 " and status='" . USERSTATUS_ACTIVE . "'");

	if (!$query_result->numrows) {
	    print "Skipping $uid; not in any groups!\n";
	    next;
	}
	push(@groupnames, "guest");
	goto nogroups;
    }
    else {
	while (@db_row = $query_result->fetchrow_array() ) {
	    my $groupname = $db_row[0];

	    next
		if ($ELABINELAB && !getgrnam($groupname));

	    push(@groupnames, $groupname);
	}
    }

    #
    # Okay, pick up subgroup (pid!=gid) membership.
    #
    $query_result =
	DBQueryFatal("select g.unix_name from group_membership as m ".
		     "left join groups as g on m.pid=g.pid and m.gid=g.gid ".
		     "where m.uid='$uid' and m.pid!=m.gid ".
		     " and m.trust!='none'");

    while (@db_row = $query_result->fetchrow_array() ) {
	    my $groupname = $db_row[0];

	    next
		if ($ELABINELAB && !getgrnam($groupname));

	    push(@groupnames, $groupname);
    }

    if (0) {
    #
    # Okay, this join looks for project/group roots in the pid, and finds
    # any subgroups they are not members of. The intent is that project
    # and group roots in the pid, should be able to read files in the
    # subgroups, even if they are not actual members of the group in the DB.
    # The reason they do not want to be actual members in the DB is cause
    # we do *not* want to export home dirs to experimental nodes, or otherwise
    # hand out sensitive info.
    #
    # XXX Not in use cause NGROUPS=16. Too Low!
    #
    $query_result =
	DBQueryFatal("select distinct gn.pid,gn.gid,g.unix_name ".
		     "  from group_membership as gp ".
		     "left join group_membership as gn on ".
		     "     gn.pid=gp.pid and gn.pid!=gn.gid ".
		     "left join group_membership as go on go.uid=gp.uid and ".
		     "     go.pid=gn.pid and go.gid=gn.gid ".
		     "left join groups as g on gn.pid=g.pid and gn.gid=g.gid ".
		     "where go.uid is null and gn.uid is not null and ".
		     "      gp.uid='$uid' and gp.pid=gp.gid and ".
		     "      (gp.trust='group_root' or ".
		     "       gp.trust='project_root')");

    while (@db_row = $query_result->fetchrow_array() ) {
	print "Would also add $uid to $db_row[0]/$db_row[1]\n";
#	push(@groupnames, $db_row[0]);
    }
    }

  nogroups:
    print "Processing user $uid: @groupnames\n";
    #
    # Construct an appropriate group list for the pw commands. Main project
    # is the first on the list, and that becomes the primary group. The rest
    # (if any) of the groups become a comma separated list for the -G option.
    #
    $groupargument = " ";
    $project       = shift @groupnames;
    $grouplist     = join(",",@groupnames);

    #
    # Add special groups. These are listed in the DB so that special local
    # users can have more unix groups than just the projects/groups they are
    # in. These groups must already exist.
    #
    my @extragrouplist = TBUnixGroupList($uid);

    #
    # Add special admin group. Check to make sure that its not a dup
    # since the above mechanism could cause a duplicate entry. No big
    # deal to catch it.
    #
    if (TBAdmin($uid)) {
	if (! grep(/^${ADMINGRP}$/, @extragrouplist)) {
	    push(@extragrouplist, $ADMINGRP);
	}
    }

    if (@extragrouplist) {
	print "Adding extra groups to list: @extragrouplist\n";

	if ($grouplist) {
	    $grouplist = "$grouplist," . join(",", @extragrouplist);
	}
	else {
	    $grouplist = join(",", @extragrouplist);
	}
    }

    if ($grouplist) {
	$groupargument = "-G $grouplist";
    }
    else {
	$groupargument = "-G \"\"";
    }

    print "Updating user $uid record on local node.\n";

    #
    # MAKE SURE not to update anything else!
    #
    if (system("$USERMOD $uid -g $project $groupargument")) {
	fatal("Could not modify user $uid on local node.");
    }

    print "Updating user $uid record on $control_node.\n";

    if ($control_node ne $BOSSNODE) {
        if (system("$SSH -host $control_node ".
	           "'$USERMOD $uid -g $project $groupargument'")) {
	    fatal("Could not modify user $uid record on $control_node.");
	}
    }

    #
    # Now schedule account updates on all the nodes that this person has
    # an account on.
    #
    TBNodeUpdateAccountsByUID($uid);
}

$UID  = $SAVEUID;
$EUID = $UID;

# and the twiki.
if ($WIKISUPPORT || $BUGDBSUPPORT) {
    foreach $user (@userlist) {
	if ($WIKISUPPORT) {
	    system("$SETWIKIGROUPS $optarg $user") == 0 or
		fatal("$SETWIKIGROUPS $user failed!");
	}
	if ($BUGDBSUPPORT) {
	    system("$SETBUGDBGROUPS $optarg $user") == 0 or
		fatal("$SETBUGDBGROUPS $user failed!");
	}
    }
}

print "Group Update Completed!\n";
exit(0);

sub fatal($) {
    my($mesg) = $_[0];

    die("*** $0:\n".
	"    $mesg\n");
}
