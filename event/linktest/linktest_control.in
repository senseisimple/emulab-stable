#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2006 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;
use POSIX;

#
# Run the linktest code from experiment swapin; this script serves as
# a wrapper for run_linktest.pl. We store the pid in the DB, and allow
# for linktest cancelation from the webpage. This script is only run on
# boss; otherwise the user is running run_linktest.pl directly on ops or
# on a node, and can terminate linktest directly (via ^C or SIGTERM).
#
sub usage()
{
    print("Usage: linktest_control [-d] [-t timeout] [-k | -l <level>] ".
	  "[-o <file>] <pid> <eid>\n".
	  "-l   - Run linktest at a specific level; defaults to DB value.\n".
	  "-k   - Kill a currently running linktest.\n".
	  "-t   - Specify timeout in seconds.\n".
	  "-o   - Specify output file for linktest results.\n".
	  "-m   - Send email to swapper if linktest fails.\n".
	  "-r   - Report results only, don't flag errors.\n".
	  "-d   - Turn on debugging output.\n");
    exit(-1);
}
my $optlist  = "dkl:o:t:mfr";
my $debug    = 2;
my $cancel   = 0;
my $sendmail = 0;
my $hosed    = 0;
my $forcerun = 0;
my $reportonly = 0;
my $timeout;
my $level;
my $output;
my $expstate;
my $dbuid;
my $user_name;
my $user_email;
my $child_pid;			# Child run_linktest process.

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $CONTROL	= "@USERNODE@";
my $TBBASE	= "@TBBASE@";
my $SSH		= "$TB/bin/sshtb";

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

# un-taint path
$ENV{'PATH'} = '/bin:/usr/bin:/usr/local/bin';
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1; 

if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be root! Maybe its a development version?\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 2;
}
if (defined($options{"m"})) {
    $sendmail = 1;
}
if (defined($options{"r"})) {
    $reportonly = 1;
}
if (defined($options{"f"})) {
    $forcerun = 1;
}
if (defined($options{"k"})) {
    $cancel = 1;
}
if (defined($options{"t"})) {
    $timeout = $options{"t"};

    if ($timeout =~ /^(\d*)$/) {
	$timeout = $1;
    }
    else {
	die("Bad data in timeout: $timeout");
    }
}
if (defined($options{"l"})) {
    $level = $options{"l"};

    if ($level =~ /^(\d*)$/) {
	$level = $1;
    }
    else {
	die("Bad data in level: $level.");
    }
}
if (defined($options{"o"})) {
    $output = $options{"o"};

    # Note different taint check (allow /).
    if ($output =~ /^([-\w\.\/]+)$/) {
	$output = $1;
    }
    else {
	die("Bad data in output file: $output\n");
    }
}
if (@ARGV != 2) {
    usage();
}
my $pid = $ARGV[0];
my $eid = $ARGV[1];

#
# Untaint args.
#
if ($pid =~ /^([-\@\w]+)$/) {
    $pid = $1;
}
else {
    die("Bad data in pid: $pid.");
}
if ($eid =~ /^([-\@\w]+)$/) {
    $eid = $1;
}
else {
    die("Bad data in eid: $eid.");
}

#
# Check state. Only in the active state
#
if (! ($expstate = ExpState($pid, $eid))) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid!\n");
}
if ($expstate ne EXPTSTATE_ACTIVE && $expstate ne EXPTSTATE_ACTIVATING &&
    $expstate ne EXPTSTATE_MODIFY_RESWAP) {
    die("*** $0:\n".
	"    Experiment $pid/$eid must be active!\n");
}

# Need this to pass to boss.
if (! UNIX2DBUID($UID, \$dbuid)) {
    die("*** $0:\n".
	"    You do not exist in the Emulab Database!\n");
}

#
# Get email info for user.
#
if (! UserDBInfo($dbuid, \$user_name, \$user_email)) {
    die("*** $0:\n".
	"    Cannot determine your name and email address.\n");
}

#
# Check permission. Only people with permission to destroy the experiment
# can do this.
#
if (! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_DESTROY)) {
    die("*** $0:\n".
	"    You do not have permission to start/stop linktest for ".
	"$pid/$eid!\n");
}

# Need the unix_gid info to pass to boss.
my $gid = ExpGroup($pid, $eid);
my ($unix_gid, $unix_gidname);

if (! TBGroupUnixInfo($pid, $gid, \$unix_gid, \$unix_gidname)) {
    die("*** $0:\n".
	"    Could not get unix group info for $pid/$gid!\n");
}

my $errlog = TBExptUserDir($pid, $eid) . "/logs/linktest.log";

#
# Lets see if there is a linktest running already.
#
my $query_result =
    DBQueryFatal("select linktest_level,linktest_pid ".
		 "from experiments where eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid exists!\n");
}
my ($linktest_level, $linktest_pid) = $query_result->fetchrow_array();

if (defined($linktest_pid) && $linktest_pid) {
    if (! kill(0, $linktest_pid) && ($ERRNO == ESRCH)) {
	DBQueryFatal("update experiments set linktest_pid=0 ".
		     "where pid='$pid' and eid='$eid'");
	
	if ($cancel) {
	    print("Linktest has already exited on experiment $pid/$eid!\n");
	    exit(0);
	}
	else {
	    print("Clearing stale linktest pid from DB for $pid/$eid!\n");
	}
    }
    elsif (!$cancel) {
	die("*** $0:\n".
	    "    Linktest is already running on experiment $pid/$eid!\n");
    }
    else {
	if (! kill('TERM', $linktest_pid)) {
	    SENDMAIL($TBOPS,
		     "Failed to stop linktest daemon for $pid/$eid",
		     "Could not kill(TERM) process $linktest_pid: $? $!");

	    die("*** $0:\n".
		"    Failed to stop linktest daemon for $pid/$eid!\n");
	}
	exit(0);
    }
}
elsif ($cancel) {
    die("*** $0:\n".
	"    Linktest is not running on experiment $pid/$eid!\n")
}

#
# Okay, this is hacky. Before trying, lets make sure that all the nodes
# in the experiment are able to run linktest. This is defined by the
# "linktest" feature in the osfeatures list of the OSID, for each node.
#
$query_result =
    DBQueryFatal("select v.vname,o.osname,FIND_IN_SET('linktest',osfeatures) ".
		 "  from virt_nodes as v ".
		 "left join reserved as r on r.pid=v.pid and ".
		 "     r.eid=v.eid and r.vname=v.vname ".
		 "left join nodes as n on n.node_id=r.node_id ".
		 "left join os_info as o on o.osid=n.def_boot_osid ".
		 "where v.pid='$pid' and v.eid='$eid'");


while (my ($vname,$osname,$gotlinktest) = $query_result->fetchrow_array()) {
    if (! defined($gotlinktest) || !$gotlinktest) {
	print STDERR
	    "*** Node $vname is running an OSID ($osname) that does not ".
		"support linktest!\n";
	$hosed++;
    }
}
if ($hosed && !$forcerun) {
    die("*** $0:\n".
	"    Aborting linktest since not all nodes support it!\n");
}

#
# Okay, lets run linktest. First set up a handler so that we can catch
# a termination signal and kill ourselves off. 
#
sub cleanup()
{
    DBQueryFatal("update experiments set linktest_pid=0 ".
		 "where pid='$pid' and eid='$eid'");
}

sub handler($)
{
    $SIG{TERM} = 'IGNORE';
    $SIG{INT}  = 'IGNORE';

    if (defined($child_pid)) {
	kill('HUP', $child_pid);
	waitpid($child_pid, 0);
	undef($child_pid);
    }
    cleanup();
    die("*** $0:\n".
	"    Linktest has been canceled on experiment $pid/$eid!\n")
}

sub notify()
{
    my $lev = (defined($level) ? $level : $linktest_level);
    my $logname = undef;
    my $isopen;
    my $filespec = "";
    my $errbody = "";

    TBExptGetLogFile($pid, $eid, \$logname, \$isopen);
    if (defined($logname)) {
	$filespec = "\n\nfile://$logname\n";
    }
    
    if (-e $errlog) {
	$errbody = `/bin/cat $errlog`;
    }

    SENDMAIL($TBOPS,
	     "Linktest Failure: $pid/$eid",
	     "Failure in linktest (level $lev); ".
	     "returned non-zero status.\n".
	     "Activity log file at:\n\n".
	     "    $TBBASE/spewlogfile.php3?pid=${pid}&eid=${eid}\n".
	     "$filespec\n".
	     "\n".
	     $errbody,
	     "$user_name <$user_email>");
}

#
# Fork a child to run the actual linktest script. The parent just waits
# for child to exit, or to be signaled to terminate the child.
#
if (defined($output)) {
    $child_pid = TBBackGround($output);
}
else {
    $child_pid = fork();
}
if ($child_pid < 0) {
    die("*** $0:\n".
	"    Linktest could not fork a new process for $pid/$eid!\n");
}

if ($child_pid) {
    #
    # Parent. 
    #
    $SIG{TERM} = \&handler;
    $SIG{INT}  = \&handler;

    DBQueryFatal("update experiments set linktest_pid=$$ ".
		 "where pid='$pid' and eid='$eid'");
    
    waitpid($child_pid, 0);
    my $exitval = $? >> 8;
    if (-e $errlog) {
	system("/bin/cat $errlog");
    }
    cleanup();
    notify()
	if ($exitval && $sendmail);
    exit($exitval);
}

#
# Child execs an ssh to users.emulab.net where linktest is actually run.
# We tell ssh to allocate a tty so that we can kill it with TERM and have
# everything die off properly.
#
# XXX: "-t -t" to ssh is so that kill -TERM carries across to ops. 
#
my @cmdargs = ("$SSH", "-t", "-t", "-F", "/dev/null",
	       "-host", $CONTROL, "exec", "$TB/sbin/linktest.proxy");
push(@cmdargs, ("-d", "$debug"))
    if ($debug);
push(@cmdargs, ("-t", "$timeout"))
    if (defined($timeout));
push(@cmdargs, "-l");
push(@cmdargs, (defined($level) ? $level : $linktest_level));
push(@cmdargs, ("-g", $unix_gidname));
push(@cmdargs, ("-u", $dbuid));
push(@cmdargs, ("-e", "$pid/$eid"));
push(@cmdargs, ("-o", $errlog));
push(@cmdargs, "-r")
    if ($reportonly);

print "Running '@cmdargs'\n"
    if ($debug);

# For sshtb
$UID=0;
exec(@cmdargs);
die("*** $0:\n".
    "    Could not exec run_linktest.pl\n");
