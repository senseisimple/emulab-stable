/*
 * FILE : /users/ricci/testbed/event/lib/event_wrap.c
 * 
 * This file was automatically generated by :
 * Simplified Wrapper and Interface Generator (SWIG)
 * Version 1.1 (Patch 5)
 * 
 * Portions Copyright (c) 1995-1998
 * The University of Utah and The Regents of the University of California.
 * Permission is granted to distribute this file in any manner provided
 * this notice remains intact.
 * 
 * Do not make changes to this file--changes will be lost!
 *
 */


#define SWIGCODE
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#undef free
#undef malloc
#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */

#if defined(WIN32) || defined(__WIN32__)
#   if defined(_MSC_VER)
#	define SWIGEXPORT(a,b) __declspec(dllexport) a b
#   else
#	if defined(__BORLANDC__)
#	    define SWIGEXPORT(a,b) a _export b
#	else
#	    define SWIGEXPORT(a,b) a b
#	endif
#   endif
#else
#   define SWIGEXPORT(a,b) a b
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerl *pPerl = (CPerl *) this;
#define MAGIC_CAST   (int (CPerl::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif


/*****************************************************************************
 * $Header: /home/cvs_mirrors/cvs-public.flux.utah.edu/CVS/testbed/event/lib/event_wrap.c,v 1.7 2006-02-07 15:54:39 stack Exp $
 *
 * perl5ptr.swg
 *
 * This file contains supporting code for the SWIG run-time type checking
 * mechanism.  The following functions are available :
 *
 * SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *));
 *
 *      Registers a new type-mapping with the type-checker.  origtype is the
 *      original datatype and newtype is an equivalent type.  cast is optional
 *      pointer to a function to cast pointer values between types (this
 *      is only used to cast pointers from derived classes to base classes in C++)
 *      
 * SWIG_MakePtr(char *buffer, void *ptr, char *typestring);
 *     
 *      Makes a pointer string from a pointer and typestring.  The result is returned
 *      in buffer.
 *
 * char * SWIG_GetPtr(SV *obj, void **ptr, char *type)
 *
 *      Gets a pointer value from a Perl5 scalar value.  If there is a 
 *      type-mismatch, returns a character string to the received type.  
 *      On success, returns NULL.
 *
 *
 * You can remap these functions by making a file called "swigptr.swg" in
 * your the same directory as the interface file you are wrapping.
 *
 * These functions are normally declared static, but this file can be
 * can be used in a multi-module environment by redefining the symbol
 * SWIGSTATIC.
 *
 * $Log: event_wrap.c,v $
 * Revision 1.7  2006-02-07 15:54:39  stack
 * Change the _put_int32 prototype to use an int instead of an int32_t,
 * so swig generates proper code (i think).
 *
 * Revision 1.6  2006/02/01 01:08:49  stack
 * Get the perl event library to compile on fedora core.
 *
 * Revision 1.5  2003/11/10 17:20:04  ricci
 * New versions of the perl even library, to bring it up to date with
 * Leigh's recent security enhancements.
 *
 * Revision 1.1  1996/12/26 22:17:29  beazley
 * Initial revision
 *
 *****************************************************************************/

#include <stdlib.h>

#ifdef SWIG_GLOBAL
#ifdef __cplusplus
#define SWIGSTATIC extern "C"
#else
#define SWIGSTATIC
#endif
#endif

#ifndef SWIGSTATIC
#define SWIGSTATIC static
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATIC 
void SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
SWIGSTATIC
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
void _SWIG_RegisterMapping(CPerl *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATIC 
void SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Define for backwards compatibility */

#define _swig_make_hex   SWIG_MakePtr 

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATIC 
char *SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
SWIGSTATIC
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
char *_SWIG_GetPtr(CPerl *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (sv == &sv_undef) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start >= end) sp = 0;
      if (sp) {
	while (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	  /* Hmmm. Didn't find it this time */
 	  sp++;
	}
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

/* Compatibility mode */

#define _swig_get_hex  SWIG_GetPtr
/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerl *pPerl, SV *sv, char *name, int (CPerl::*set)(SV *, MAGIC *), int (CPerl::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_event

#define SWIG_name   "eventc::boot_event"
#define SWIG_varinit "eventc::var_event_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
#  ifdef pTHX_
SWIGEXPORT(void,boot_event)(pTHX_ CV* cv);
#  else
SWIGEXPORT(void,boot_event)(CV* cv);
#  endif
#else
SWIGEXPORT(void,boot_event)(CPerl *, CV *cv);
#endif

#define NO_EVENT_MACROS
#include "event.h"
#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerl *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

#ifndef PERL_OBJECT
#define swig_setpv(a,b) _swig_setpv(a,b)
static void _swig_setpv(char *name, char *value) { 
#else
#define swig_setpv(a,b) _swig_setpv(pPerl,a,b)
static void _swig_setpv(CPerl *pPerl, char *name, char *value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setpv(sv, value);
     SvREADONLY_on(sv);
}



	/*
	 * Queue of notifications that have been received
	 */
	struct callback_data {
		event_notification_t callback_notification;
		struct callback_data *next;
	};
	typedef struct callback_data *callback_data_t;

	callback_data_t callback_data_list;

	/*
	 * Simple wrappers, since we don't want to (maybe can't) call
	 * malloc/free from perl
	 */
	callback_data_t allocate_callback_data() {
		return (callback_data_t)malloc(sizeof(callback_data_t));
	}

	void free_callback_data(callback_data_t data) {
		free(data);
	}

	callback_data_t dequeue_callback_data() {
		callback_data_t data = callback_data_list;
		if (callback_data_list) {
			callback_data_list = callback_data_list->next;
		}
		return data;
	}

	void enqueue_callback_data(callback_data_t data) {
		callback_data_t *pos = &callback_data_list;
		while (*pos) {
			pos = &((*pos)->next);
		}
		*pos = data;
	}

	/*
	 * Stub callback that simply pushes a new entry onto the list
	 * of data for the perl callback function
	 */
	void perl_stub_callback(event_handle_t handle,
		event_notification_t notification, void *data) {
		callback_data_t new_data;

		new_data = allocate_callback_data();
		new_data->callback_notification =
			event_notification_clone(handle,notification);
		new_data->next = NULL;

		enqueue_callback_data(new_data);
	}

	/*
	 * Call event_subscribe using the stub function
	 */
	event_subscription_t stub_event_subscribe(event_handle_t handle,
			address_tuple_t tuple) {
		return event_subscribe(handle,perl_stub_callback,tuple,NULL);

       }


	/*
	 * We use a global buffer to avoid leaking memory - SWIG/XS/perl
	 * will take the return value of char* functions and convert them 
	 * to perl strings, which makes a copy of the string. So, if we
	 * return malloc()ed memory, it gets leaked. But, the event system
	 * requires us to pass in a buffer to fill....
	 */
	char event_string_buffer[1024];

	char *perl_event_notification_get_string(event_handle_t handle,
			event_notification_t notification, char *name) {

		int rv;

		rv = event_notification_get_string(handle,notification,name,
			event_string_buffer,sizeof(event_string_buffer));
		if (!rv) {
			return NULL;
		} else {
			return event_string_buffer;
		}
      }


	char *event_notification_get_site(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,"SITE");
	}

	char* event_notification_get_expt(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,"EXPT");
	}

	char* event_notification_get_group(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,"GROUP");
	}

	char *event_notification_get_host(event_handle_t handle,
			event_notification_t note) {
        	return perl_event_notification_get_string(handle,note,"HOST");
	}

	char *event_notification_get_objtype(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,
							  "OBJTYPE");
	}

	char *event_notification_get_objname(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,
							  "OBJNAME");
	}

	char* event_notification_get_eventtype(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,
							  "EVENTTYPE");
	}

	char* event_notification_get_arguments(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,"ARGS");
	}

	int event_notification_set_arguments(event_handle_t handle,
			event_notification_t note, char *buf) {
		return event_notification_put_string(handle,note,"ARGS", buf);
	}

	char *event_notification_get_sender(event_handle_t handle,
			event_notification_t note) {
		return perl_event_notification_get_string(handle,note,
	    						  "___SENDER___");
	}

	int event_notification_set_sender(event_handle_t handle,
			event_notification_t note, char *buf) {
		return event_notification_put_string(handle,note,
						     "___SENDER___",buf);
	}
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_event_var::
class _wrap_event_var : public CPerl {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_set_callback_data_list(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"callback_data")) {
        croak("Type error in value of callback_data_list. Expected callback_data.");
        return(1);
    }
    callback_data_list = (callback_data_t ) _temp;
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_callback_data_list(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) callback_data_list);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_event_string_buffer(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setpv((SV*) sv, event_string_buffer);
    return 1;
}



#ifdef PERL_OBJECT
};
#endif

XS(_wrap_address_tuple_alloc) {

    address_tuple_t  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: address_tuple_alloc();");
    _result = (address_tuple_t )address_tuple_alloc();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"address_tuple", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_address_tuple_free) {

    int  _result;
    address_tuple_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_free(address_tuple_t );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_free. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (int )address_tuple_free(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_register) {

    event_handle_t  _result;
    char * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_register(name,threaded);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _result = (event_handle_t )event_register(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_handle", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_register_withkeyfile) {

    event_handle_t  _result;
    char * _arg0;
    int  _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_register_withkeyfile(name,threaded,keyfile);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (event_handle_t )event_register_withkeyfile(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_handle", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_register_withkeydata) {

    event_handle_t  _result;
    char * _arg0;
    int  _arg1;
    unsigned char * _arg2;
    int  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_register_withkeydata(name,threaded,keydata,len);");
    _arg0 = (char *) SvPV(ST(0),na);
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned charPtr")) {
        croak("Type error in argument 3 of event_register_withkeydata. Expected unsigned charPtr.");
        XSRETURN(1);
    }
    _arg3 = (int )SvIV(ST(3));
    _result = (event_handle_t )event_register_withkeydata(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_handle", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_unregister) {

    int  _result;
    event_handle_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_unregister(handle);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_unregister. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (int )event_unregister(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_c_event_poll) {

    int  _result;
    event_handle_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: c_event_poll(handle);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of c_event_poll. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (int )event_poll(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_c_event_poll_blocking) {

    int  _result;
    event_handle_t  _arg0;
    unsigned int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: c_event_poll_blocking(handle,timeout);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of c_event_poll_blocking. Expected event_handle.");
        XSRETURN(1);
    }
    _arg1 = (unsigned int )SvIV(ST(1));
    _result = (int )event_poll_blocking(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_dont_use_this_function_because_it_does_not_work) {

    int  _result;
    event_handle_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: dont_use_this_function_because_it_does_not_work(handle);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of dont_use_this_function_because_it_does_not_work. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (int )event_main(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notify) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notify(handle,notification);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notify. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notify. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (int )event_notify(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_schedule) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    struct timeval * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_schedule(handle,notification,time);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_schedule. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_schedule. Expected event_notification.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"struct timevalPtr")) {
        croak("Type error in argument 3 of event_schedule. Expected struct timevalPtr.");
        XSRETURN(1);
    }
    _result = (int )event_schedule(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_alloc) {

    event_notification_t  _result;
    event_handle_t  _arg0;
    address_tuple_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_alloc(handle,tuple);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_alloc. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"address_tuple")) {
        croak("Type error in argument 2 of event_notification_alloc. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (event_notification_t )event_notification_alloc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_notification", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_free) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_free(handle,notification);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_free. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_free. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (int )event_notification_free(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_clone) {

    event_notification_t  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_clone(handle,notification);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_clone. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_clone. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (event_notification_t )event_notification_clone(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_notification", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_double) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    double * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_get_double(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_double. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_double. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtr")) {
        croak("Type error in argument 4 of event_notification_get_double. Expected doublePtr.");
        XSRETURN(1);
    }
    _result = (int )event_notification_get_double(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_int32) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int32_t * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_get_int32(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_int32. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_int32. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"int32_tPtr")) {
        croak("Type error in argument 4 of event_notification_get_int32. Expected int32_tPtr.");
        XSRETURN(1);
    }
    _result = (int )event_notification_get_int32(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_int64) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int64_t * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_get_int64(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_int64. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_int64. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"int64_tPtr")) {
        croak("Type error in argument 4 of event_notification_get_int64. Expected int64_tPtr.");
        XSRETURN(1);
    }
    _result = (int )event_notification_get_int64(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_opaque) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    void * _arg3;
    int  _arg4;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: event_notification_get_opaque(handle,notification,name,buffer,length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_opaque. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_opaque. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,(char *) 0 )) {
        croak("Type error in argument 4 of event_notification_get_opaque. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    _result = (int )event_notification_get_opaque(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_c_event_notification_get_string) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    char * _arg3;
    int  _arg4;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: c_event_notification_get_string(handle,notification,name,buffer,length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of c_event_notification_get_string. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of c_event_notification_get_string. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (char *) SvPV(ST(3),na);
    _arg4 = (int )SvIV(ST(4));
    _result = (int )event_notification_get_string(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_put_double) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    double  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_put_double(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_put_double. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_put_double. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (double ) SvNV(ST(3));
    _result = (int )event_notification_put_double(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_put_int32) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_put_int32(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_put_int32. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_put_int32. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (int )SvIV(ST(3));
    _result = (int )event_notification_put_int32(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_put_int64) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int64_t * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_put_int64(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_put_int64. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_put_int64. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"int64_tPtr")) {
        croak("Type error in argument 4 of event_notification_put_int64. Expected int64_tPtr.");
        XSRETURN(1);
    }
    _result = (int )event_notification_put_int64(_arg0,_arg1,_arg2,*_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_put_opaque) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    void * _arg3;
    int  _arg4;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: event_notification_put_opaque(handle,notification,name,buffer,length);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_put_opaque. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_put_opaque. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,(char *) 0 )) {
        croak("Type error in argument 4 of event_notification_put_opaque. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg4 = (int )SvIV(ST(4));
    _result = (int )event_notification_put_opaque(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_put_string) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    char * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_put_string(handle,notification,name,value);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_put_string. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_put_string. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _arg3 = (char *) SvPV(ST(3),na);
    _result = (int )event_notification_put_string(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_remove) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_notification_remove(handle,notification,name);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_remove. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_remove. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (int )event_notification_remove(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_c_event_subscribe) {

    event_subscription_t * _result;
    event_handle_t  _arg0;
    event_notify_callback_t  _arg1;
    address_tuple_t  _arg2;
    void * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: c_event_subscribe(handle,callback,tuple,data);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of c_event_subscribe. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notify_callback_t")) {
        croak("Type error in argument 2 of c_event_subscribe. Expected event_notify_callback_t.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"address_tuple")) {
        croak("Type error in argument 3 of c_event_subscribe. Expected address_tuple.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,(char *) 0 )) {
        croak("Type error in argument 4 of c_event_subscribe. Expected voidPtr.");
        XSRETURN(1);
    }
    _result = (event_subscription_t *) malloc(sizeof(event_subscription_t ));
    *(_result) = event_subscribe(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_subscription_tPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_insert_hmac) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_insert_hmac(handle,notification);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_insert_hmac. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_insert_hmac. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (int )event_notification_insert_hmac(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_pack) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    unsigned char * _arg2;
    int * _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_pack(handle,notification,data,len);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_pack. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_pack. Expected event_notification.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned charPtr")) {
        croak("Type error in argument 3 of event_notification_pack. Expected unsigned charPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"intPtr")) {
        croak("Type error in argument 4 of event_notification_pack. Expected intPtr.");
        XSRETURN(1);
    }
    _result = (int )event_notification_pack(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_unpack) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t * _arg1;
    unsigned char * _arg2;
    int  _arg3;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: event_notification_unpack(handle,notification,data,len);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_unpack. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification_tPtr")) {
        croak("Type error in argument 2 of event_notification_unpack. Expected event_notification_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"unsigned charPtr")) {
        croak("Type error in argument 3 of event_notification_unpack. Expected unsigned charPtr.");
        XSRETURN(1);
    }
    _arg3 = (int )SvIV(ST(3));
    _result = (int )event_notification_unpack(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_xmalloc) {

    void * _result;
    int  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: xmalloc(size);");
    _arg0 = (int )SvIV(ST(0));
    _result = (void *)xmalloc(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_xrealloc) {

    void * _result;
    void * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: xrealloc(p,size);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of xrealloc. Expected voidPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (void *)xrealloc(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_allocate_callback_data) {

    callback_data_t  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: allocate_callback_data();");
    _result = (callback_data_t )allocate_callback_data();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"callback_data", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_free_callback_data) {

    callback_data_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: free_callback_data(data);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of free_callback_data. Expected callback_data.");
        XSRETURN(1);
    }
    free_callback_data(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_dequeue_callback_data) {

    callback_data_t  _result;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: dequeue_callback_data();");
    _result = (callback_data_t )dequeue_callback_data();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"callback_data", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_enqueue_callback_data) {

    callback_data_t  _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: enqueue_callback_data(data);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of enqueue_callback_data. Expected callback_data.");
        XSRETURN(1);
    }
    enqueue_callback_data(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_perl_stub_callback) {

    event_handle_t  _arg0;
    event_notification_t  _arg1;
    void * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: perl_stub_callback(handle,notification,data);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of perl_stub_callback. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of perl_stub_callback. Expected event_notification.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,(char *) 0 )) {
        croak("Type error in argument 3 of perl_stub_callback. Expected voidPtr.");
        XSRETURN(1);
    }
    perl_stub_callback(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_stub_event_subscribe) {

    event_subscription_t * _result;
    event_handle_t  _arg0;
    address_tuple_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: stub_event_subscribe(handle,tuple);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of stub_event_subscribe. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"address_tuple")) {
        croak("Type error in argument 2 of stub_event_subscribe. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (event_subscription_t *) malloc(sizeof(event_subscription_t ));
    *(_result) = stub_event_subscribe(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_subscription_tPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_string) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_notification_get_string(handle,notification,name);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_string. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_string. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (char *)perl_event_notification_get_string(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_site) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_site(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_site. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_site. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_site(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_expt) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_expt(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_expt. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_expt. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_expt(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_group) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_group(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_group. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_group. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_group(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_host) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_host(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_host. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_host. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_host(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_objtype) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_objtype(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_objtype. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_objtype. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_objtype(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_objname) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_objname(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_objname. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_objname. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_objname(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_eventtype) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_eventtype(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_eventtype. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_eventtype. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_eventtype(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_arguments) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_arguments(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_arguments. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_arguments. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_arguments(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_set_arguments) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_notification_set_arguments(handle,note,buf);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_set_arguments. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_set_arguments. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (int )event_notification_set_arguments(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_get_sender) {

    char * _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_get_sender(handle,note);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_get_sender. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_get_sender. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (char *)event_notification_get_sender(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_event_notification_set_sender) {

    int  _result;
    event_handle_t  _arg0;
    event_notification_t  _arg1;
    char * _arg2;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: event_notification_set_sender(handle,note,buf);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_notification_set_sender. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of event_notification_set_sender. Expected event_notification.");
        XSRETURN(1);
    }
    _arg2 = (char *) SvPV(ST(2),na);
    _result = (int )event_notification_set_sender(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define event_handle_server_set(_swigobj,_swigval) (_swigobj->server = *(_swigval),_swigval)
XS(_wrap_event_handle_server_set) {

    elvin_handle_t * _result;
    struct event_handle * _arg0;
    elvin_handle_t * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_handle_server_set(struct event_handle *,elvin_handle_t *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_server_set. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"elvin_handle_tPtr")) {
        croak("Type error in argument 2 of event_handle_server_set. Expected elvin_handle_tPtr.");
        XSRETURN(1);
    }
    _result = (elvin_handle_t *)event_handle_server_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_handle_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_server_get(_swigobj) (&_swigobj->server)
XS(_wrap_event_handle_server_get) {

    elvin_handle_t * _result;
    struct event_handle * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_handle_server_get(struct event_handle *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_server_get. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (elvin_handle_t *)event_handle_server_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_handle_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_status_set(_swigobj,_swigval) (_swigobj->status = *(_swigval),_swigval)
XS(_wrap_event_handle_status_set) {

    elvin_error_t * _result;
    struct event_handle * _arg0;
    elvin_error_t * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_handle_status_set(struct event_handle *,elvin_error_t *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_status_set. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"elvin_error_tPtr")) {
        croak("Type error in argument 2 of event_handle_status_set. Expected elvin_error_tPtr.");
        XSRETURN(1);
    }
    _result = (elvin_error_t *)event_handle_status_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_error_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_status_get(_swigobj) (&_swigobj->status)
XS(_wrap_event_handle_status_get) {

    elvin_error_t * _result;
    struct event_handle * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_handle_status_get(struct event_handle *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_status_get. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (elvin_error_t *)event_handle_status_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_error_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_keydata_set(_swigobj,_swigval) (_swigobj->keydata = _swigval,_swigval)
XS(_wrap_event_handle_keydata_set) {

    unsigned char * _result;
    struct event_handle * _arg0;
    unsigned char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_handle_keydata_set(struct event_handle *,unsigned char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_keydata_set. Expected event_handle.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"unsigned charPtr")) {
        croak("Type error in argument 2 of event_handle_keydata_set. Expected unsigned charPtr.");
        XSRETURN(1);
    }
    _result = (unsigned char *)event_handle_keydata_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"unsigned charPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_keydata_get(_swigobj) ((unsigned char *) _swigobj->keydata)
XS(_wrap_event_handle_keydata_get) {

    unsigned char * _result;
    struct event_handle * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_handle_keydata_get(struct event_handle *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_keydata_get. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (unsigned char *)event_handle_keydata_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"unsigned charPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_handle_keylen_set(_swigobj,_swigval) (_swigobj->keylen = _swigval,_swigval)
XS(_wrap_event_handle_keylen_set) {

    int  _result;
    struct event_handle * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_handle_keylen_set(struct event_handle *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_keylen_set. Expected event_handle.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )event_handle_keylen_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define event_handle_keylen_get(_swigobj) ((int ) _swigobj->keylen)
XS(_wrap_event_handle_keylen_get) {

    int  _result;
    struct event_handle * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_handle_keylen_get(struct event_handle *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_handle")) {
        croak("Type error in argument 1 of event_handle_keylen_get. Expected event_handle.");
        XSRETURN(1);
    }
    _result = (int )event_handle_keylen_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define event_notification_elvin_notification_set(_swigobj,_swigval) (_swigobj->elvin_notification = *(_swigval),_swigval)
XS(_wrap_event_notification_elvin_notification_set) {

    elvin_notification_t * _result;
    struct event_notification * _arg0;
    elvin_notification_t * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_elvin_notification_set(struct event_notification *,elvin_notification_t *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_notification")) {
        croak("Type error in argument 1 of event_notification_elvin_notification_set. Expected event_notification.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"elvin_notification_tPtr")) {
        croak("Type error in argument 2 of event_notification_elvin_notification_set. Expected elvin_notification_tPtr.");
        XSRETURN(1);
    }
    _result = (elvin_notification_t *)event_notification_elvin_notification_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_notification_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_notification_elvin_notification_get(_swigobj) (&_swigobj->elvin_notification)
XS(_wrap_event_notification_elvin_notification_get) {

    elvin_notification_t * _result;
    struct event_notification * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_notification_elvin_notification_get(struct event_notification *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_notification")) {
        croak("Type error in argument 1 of event_notification_elvin_notification_get. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (elvin_notification_t *)event_notification_elvin_notification_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"elvin_notification_tPtr", (void *) _result);
    XSRETURN(argvi);
}

#define event_notification_has_hmac_set(_swigobj,_swigval) (_swigobj->has_hmac = _swigval,_swigval)
XS(_wrap_event_notification_has_hmac_set) {

    int  _result;
    struct event_notification * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: event_notification_has_hmac_set(struct event_notification *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_notification")) {
        croak("Type error in argument 1 of event_notification_has_hmac_set. Expected event_notification.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )event_notification_has_hmac_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define event_notification_has_hmac_get(_swigobj) ((int ) _swigobj->has_hmac)
XS(_wrap_event_notification_has_hmac_get) {

    int  _result;
    struct event_notification * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: event_notification_has_hmac_get(struct event_notification *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"event_notification")) {
        croak("Type error in argument 1 of event_notification_has_hmac_get. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (int )event_notification_has_hmac_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

static char * address_tuple_site_set(address_tuple *obj, char *val) {
    if (obj->site) free(obj->site);
    obj->site = (char *) malloc(strlen(val)+1);
    strcpy(obj->site,val);
    return val;
}
XS(_wrap_address_tuple_site_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_site_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_site_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_site_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_site_get(_swigobj) ((char *) _swigobj->site)
XS(_wrap_address_tuple_site_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_site_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_site_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_site_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_expt_set(address_tuple *obj, char *val) {
    if (obj->expt) free(obj->expt);
    obj->expt = (char *) malloc(strlen(val)+1);
    strcpy(obj->expt,val);
    return val;
}
XS(_wrap_address_tuple_expt_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_expt_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_expt_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_expt_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_expt_get(_swigobj) ((char *) _swigobj->expt)
XS(_wrap_address_tuple_expt_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_expt_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_expt_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_expt_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_group_set(address_tuple *obj, char *val) {
    if (obj->group) free(obj->group);
    obj->group = (char *) malloc(strlen(val)+1);
    strcpy(obj->group,val);
    return val;
}
XS(_wrap_address_tuple_group_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_group_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_group_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_group_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_group_get(_swigobj) ((char *) _swigobj->group)
XS(_wrap_address_tuple_group_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_group_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_group_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_group_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_host_set(address_tuple *obj, char *val) {
    if (obj->host) free(obj->host);
    obj->host = (char *) malloc(strlen(val)+1);
    strcpy(obj->host,val);
    return val;
}
XS(_wrap_address_tuple_host_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_host_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_host_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_host_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_host_get(_swigobj) ((char *) _swigobj->host)
XS(_wrap_address_tuple_host_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_host_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_host_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_host_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_objtype_set(address_tuple *obj, char *val) {
    if (obj->objtype) free(obj->objtype);
    obj->objtype = (char *) malloc(strlen(val)+1);
    strcpy(obj->objtype,val);
    return val;
}
XS(_wrap_address_tuple_objtype_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_objtype_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_objtype_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_objtype_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_objtype_get(_swigobj) ((char *) _swigobj->objtype)
XS(_wrap_address_tuple_objtype_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_objtype_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_objtype_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_objtype_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_objname_set(address_tuple *obj, char *val) {
    if (obj->objname) free(obj->objname);
    obj->objname = (char *) malloc(strlen(val)+1);
    strcpy(obj->objname,val);
    return val;
}
XS(_wrap_address_tuple_objname_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_objname_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_objname_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_objname_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_objname_get(_swigobj) ((char *) _swigobj->objname)
XS(_wrap_address_tuple_objname_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_objname_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_objname_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_objname_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

static char * address_tuple_eventtype_set(address_tuple *obj, char *val) {
    if (obj->eventtype) free(obj->eventtype);
    obj->eventtype = (char *) malloc(strlen(val)+1);
    strcpy(obj->eventtype,val);
    return val;
}
XS(_wrap_address_tuple_eventtype_set) {

    char * _result;
    address_tuple * _arg0;
    char * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_eventtype_set(address_tuple *,char *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_eventtype_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (char *) SvPV(ST(1),na);
    _result = (char *)address_tuple_eventtype_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_eventtype_get(_swigobj) ((char *) _swigobj->eventtype)
XS(_wrap_address_tuple_eventtype_get) {

    char * _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_eventtype_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_eventtype_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (char *)address_tuple_eventtype_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

#define address_tuple_scheduler_set(_swigobj,_swigval) (_swigobj->scheduler = _swigval,_swigval)
XS(_wrap_address_tuple_scheduler_set) {

    int  _result;
    address_tuple * _arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: address_tuple_scheduler_set(address_tuple *,int );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_scheduler_set. Expected address_tuple.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )address_tuple_scheduler_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define address_tuple_scheduler_get(_swigobj) ((int ) _swigobj->scheduler)
XS(_wrap_address_tuple_scheduler_get) {

    int  _result;
    address_tuple * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: address_tuple_scheduler_get(address_tuple *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"address_tuple")) {
        croak("Type error in argument 1 of address_tuple_scheduler_get. Expected address_tuple.");
        XSRETURN(1);
    }
    _result = (int )address_tuple_scheduler_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

#define callback_data_callback_notification_set(_swigobj,_swigval) (_swigobj->callback_notification = _swigval,_swigval)
XS(_wrap_callback_data_callback_notification_set) {

    event_notification_t  _result;
    struct callback_data * _arg0;
    event_notification_t  _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: callback_data_callback_notification_set(struct callback_data *,event_notification_t );");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of callback_data_callback_notification_set. Expected callback_data.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"event_notification")) {
        croak("Type error in argument 2 of callback_data_callback_notification_set. Expected event_notification.");
        XSRETURN(1);
    }
    _result = (event_notification_t )callback_data_callback_notification_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_notification", (void *) _result);
    XSRETURN(argvi);
}

#define callback_data_callback_notification_get(_swigobj) ((event_notification_t ) _swigobj->callback_notification)
XS(_wrap_callback_data_callback_notification_get) {

    event_notification_t  _result;
    struct callback_data * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: callback_data_callback_notification_get(struct callback_data *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of callback_data_callback_notification_get. Expected callback_data.");
        XSRETURN(1);
    }
    _result = (event_notification_t )callback_data_callback_notification_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"event_notification", (void *) _result);
    XSRETURN(argvi);
}

#define callback_data_next_set(_swigobj,_swigval) (_swigobj->next = _swigval,_swigval)
XS(_wrap_callback_data_next_set) {

    struct callback_data * _result;
    struct callback_data * _arg0;
    struct callback_data * _arg1;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: callback_data_next_set(struct callback_data *,struct callback_data *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of callback_data_next_set. Expected callback_data.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"callback_data")) {
        croak("Type error in argument 2 of callback_data_next_set. Expected callback_data.");
        XSRETURN(1);
    }
    _result = (struct callback_data *)callback_data_next_set(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"callback_data", (void *) _result);
    XSRETURN(argvi);
}

#define callback_data_next_get(_swigobj) ((struct callback_data *) _swigobj->next)
XS(_wrap_callback_data_next_get) {

    struct callback_data * _result;
    struct callback_data * _arg0;
    int argvi = 0;
    dXSARGS ;

    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: callback_data_next_get(struct callback_data *);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"callback_data")) {
        croak("Type error in argument 1 of callback_data_next_get. Expected callback_data.");
        XSRETURN(1);
    }
    _result = (struct callback_data *)callback_data_next_get(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"callback_data", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_perl5_event_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setiv("MAXHOSTNAMELEN", (long) 64);
    swig_setiv("ADDRESSTUPLE_ANY", (long) NULL);
    swig_setpv("ADDRESSTUPLE_ALL", "*");
    swig_setpv("OBJECTTYPE_TESTBED", "TBCONTROL");
    swig_setpv("OBJECTTYPE_TRAFGEN", "TRAFGEN");
    swig_setpv("EVENT_HOST_ANY", "*");
    swig_setiv("EVENT_NULL", (long) EVENT_NULL);
    swig_setiv("EVENT_TEST", (long) EVENT_TEST);
    swig_setiv("EVENT_SCHEDULE", (long) EVENT_SCHEDULE);
    swig_setiv("EVENT_TRAFGEN_START", (long) EVENT_TRAFGEN_START);
    swig_setiv("EVENT_TRAFGEN_STOP", (long) EVENT_TRAFGEN_STOP);
    sv = perl_get_sv("callback_data_list",TRUE | 0x2);
    sv_setref_pv(sv,"callback_data",(void *) 1);
    swig_create_magic(sv,"callback_data_list", MAGIC_CAST MAGIC_CLASS _wrap_set_callback_data_list, MAGIC_CAST MAGIC_CLASS _wrap_val_callback_data_list);
    sv = perl_get_sv("event_string_buffer",TRUE | 0x2);
    swig_create_magic(sv,"event_string_buffer",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_event_string_buffer);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(boot_event) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("eventc::var_event_init", _wrap_perl5_event_var_init, file);
	 newXS("eventc::address_tuple_alloc", _wrap_address_tuple_alloc, file);
	 newXS("eventc::address_tuple_free", _wrap_address_tuple_free, file);
	 newXS("eventc::event_register", _wrap_event_register, file);
	 newXS("eventc::event_register_withkeyfile", _wrap_event_register_withkeyfile, file);
	 newXS("eventc::event_register_withkeydata", _wrap_event_register_withkeydata, file);
	 newXS("eventc::event_unregister", _wrap_event_unregister, file);
	 newXS("eventc::c_event_poll", _wrap_c_event_poll, file);
	 newXS("eventc::c_event_poll_blocking", _wrap_c_event_poll_blocking, file);
	 newXS("eventc::dont_use_this_function_because_it_does_not_work", _wrap_dont_use_this_function_because_it_does_not_work, file);
	 newXS("eventc::event_notify", _wrap_event_notify, file);
	 newXS("eventc::event_schedule", _wrap_event_schedule, file);
	 newXS("eventc::event_notification_alloc", _wrap_event_notification_alloc, file);
	 newXS("eventc::event_notification_free", _wrap_event_notification_free, file);
	 newXS("eventc::event_notification_clone", _wrap_event_notification_clone, file);
	 newXS("eventc::event_notification_get_double", _wrap_event_notification_get_double, file);
	 newXS("eventc::event_notification_get_int32", _wrap_event_notification_get_int32, file);
	 newXS("eventc::event_notification_get_int64", _wrap_event_notification_get_int64, file);
	 newXS("eventc::event_notification_get_opaque", _wrap_event_notification_get_opaque, file);
	 newXS("eventc::c_event_notification_get_string", _wrap_c_event_notification_get_string, file);
	 newXS("eventc::event_notification_put_double", _wrap_event_notification_put_double, file);
	 newXS("eventc::event_notification_put_int32", _wrap_event_notification_put_int32, file);
	 newXS("eventc::event_notification_put_int64", _wrap_event_notification_put_int64, file);
	 newXS("eventc::event_notification_put_opaque", _wrap_event_notification_put_opaque, file);
	 newXS("eventc::event_notification_put_string", _wrap_event_notification_put_string, file);
	 newXS("eventc::event_notification_remove", _wrap_event_notification_remove, file);
	 newXS("eventc::c_event_subscribe", _wrap_c_event_subscribe, file);
	 newXS("eventc::event_notification_insert_hmac", _wrap_event_notification_insert_hmac, file);
	 newXS("eventc::event_notification_pack", _wrap_event_notification_pack, file);
	 newXS("eventc::event_notification_unpack", _wrap_event_notification_unpack, file);
	 newXS("eventc::xmalloc", _wrap_xmalloc, file);
	 newXS("eventc::xrealloc", _wrap_xrealloc, file);
	 newXS("eventc::allocate_callback_data", _wrap_allocate_callback_data, file);
	 newXS("eventc::free_callback_data", _wrap_free_callback_data, file);
	 newXS("eventc::dequeue_callback_data", _wrap_dequeue_callback_data, file);
	 newXS("eventc::enqueue_callback_data", _wrap_enqueue_callback_data, file);
	 newXS("eventc::perl_stub_callback", _wrap_perl_stub_callback, file);
	 newXS("eventc::stub_event_subscribe", _wrap_stub_event_subscribe, file);
	 newXS("eventc::event_notification_get_string", _wrap_event_notification_get_string, file);
	 newXS("eventc::event_notification_get_site", _wrap_event_notification_get_site, file);
	 newXS("eventc::event_notification_get_expt", _wrap_event_notification_get_expt, file);
	 newXS("eventc::event_notification_get_group", _wrap_event_notification_get_group, file);
	 newXS("eventc::event_notification_get_host", _wrap_event_notification_get_host, file);
	 newXS("eventc::event_notification_get_objtype", _wrap_event_notification_get_objtype, file);
	 newXS("eventc::event_notification_get_objname", _wrap_event_notification_get_objname, file);
	 newXS("eventc::event_notification_get_eventtype", _wrap_event_notification_get_eventtype, file);
	 newXS("eventc::event_notification_get_arguments", _wrap_event_notification_get_arguments, file);
	 newXS("eventc::event_notification_set_arguments", _wrap_event_notification_set_arguments, file);
	 newXS("eventc::event_notification_get_sender", _wrap_event_notification_get_sender, file);
	 newXS("eventc::event_notification_set_sender", _wrap_event_notification_set_sender, file);
	 newXS("eventc::event_handle_server_set", _wrap_event_handle_server_set, file);
	 newXS("eventc::event_handle_server_get", _wrap_event_handle_server_get, file);
	 newXS("eventc::event_handle_status_set", _wrap_event_handle_status_set, file);
	 newXS("eventc::event_handle_status_get", _wrap_event_handle_status_get, file);
	 newXS("eventc::event_handle_keydata_set", _wrap_event_handle_keydata_set, file);
	 newXS("eventc::event_handle_keydata_get", _wrap_event_handle_keydata_get, file);
	 newXS("eventc::event_handle_keylen_set", _wrap_event_handle_keylen_set, file);
	 newXS("eventc::event_handle_keylen_get", _wrap_event_handle_keylen_get, file);
	 newXS("eventc::event_notification_elvin_notification_set", _wrap_event_notification_elvin_notification_set, file);
	 newXS("eventc::event_notification_elvin_notification_get", _wrap_event_notification_elvin_notification_get, file);
	 newXS("eventc::event_notification_has_hmac_set", _wrap_event_notification_has_hmac_set, file);
	 newXS("eventc::event_notification_has_hmac_get", _wrap_event_notification_has_hmac_get, file);
	 newXS("eventc::address_tuple_site_set", _wrap_address_tuple_site_set, file);
	 newXS("eventc::address_tuple_site_get", _wrap_address_tuple_site_get, file);
	 newXS("eventc::address_tuple_expt_set", _wrap_address_tuple_expt_set, file);
	 newXS("eventc::address_tuple_expt_get", _wrap_address_tuple_expt_get, file);
	 newXS("eventc::address_tuple_group_set", _wrap_address_tuple_group_set, file);
	 newXS("eventc::address_tuple_group_get", _wrap_address_tuple_group_get, file);
	 newXS("eventc::address_tuple_host_set", _wrap_address_tuple_host_set, file);
	 newXS("eventc::address_tuple_host_get", _wrap_address_tuple_host_get, file);
	 newXS("eventc::address_tuple_objtype_set", _wrap_address_tuple_objtype_set, file);
	 newXS("eventc::address_tuple_objtype_get", _wrap_address_tuple_objtype_get, file);
	 newXS("eventc::address_tuple_objname_set", _wrap_address_tuple_objname_set, file);
	 newXS("eventc::address_tuple_objname_get", _wrap_address_tuple_objname_get, file);
	 newXS("eventc::address_tuple_eventtype_set", _wrap_address_tuple_eventtype_set, file);
	 newXS("eventc::address_tuple_eventtype_get", _wrap_address_tuple_eventtype_get, file);
	 newXS("eventc::address_tuple_scheduler_set", _wrap_address_tuple_scheduler_set, file);
	 newXS("eventc::address_tuple_scheduler_get", _wrap_address_tuple_scheduler_get, file);
	 newXS("eventc::callback_data_callback_notification_set", _wrap_callback_data_callback_notification_set, file);
	 newXS("eventc::callback_data_callback_notification_get", _wrap_callback_data_callback_notification_get, file);
	 newXS("eventc::callback_data_next_set", _wrap_callback_data_next_set, file);
	 newXS("eventc::callback_data_next_get", _wrap_callback_data_next_get, file);
/*
 * These are the pointer type-equivalency mappings. 
 * (Used by the SWIG pointer type-checker).
 */
	 SWIG_RegisterMapping("struct event_handle","event_handle_t",0);
	 SWIG_RegisterMapping("struct event_handle","event_handle",0);
	 SWIG_RegisterMapping("callback_data","callback_data_t",0);
	 SWIG_RegisterMapping("callback_data","struct callback_data",0);
	 SWIG_RegisterMapping("unsigned short","short",0);
	 SWIG_RegisterMapping("elvin_subscription_t","event_subscription_t",0);
	 SWIG_RegisterMapping("address_tuple","address_tuple_t",0);
	 SWIG_RegisterMapping("long","unsigned long",0);
	 SWIG_RegisterMapping("long","signed long",0);
	 SWIG_RegisterMapping("event_handle","event_handle_t",0);
	 SWIG_RegisterMapping("event_handle","struct event_handle",0);
	 SWIG_RegisterMapping("signed short","short",0);
	 SWIG_RegisterMapping("event_subscription_t","elvin_subscription_t",0);
	 SWIG_RegisterMapping("callback_data_t","callback_data",0);
	 SWIG_RegisterMapping("callback_data_t","struct callback_data",0);
	 SWIG_RegisterMapping("address_tuple_t","address_tuple",0);
	 SWIG_RegisterMapping("signed int","int",0);
	 SWIG_RegisterMapping("event_notification_t","event_notification",0);
	 SWIG_RegisterMapping("event_notification_t","struct event_notification",0);
	 SWIG_RegisterMapping("short","unsigned short",0);
	 SWIG_RegisterMapping("short","signed short",0);
	 SWIG_RegisterMapping("unsigned long","long",0);
	 SWIG_RegisterMapping("int","unsigned int",0);
	 SWIG_RegisterMapping("int","signed int",0);
	 SWIG_RegisterMapping("struct event_notification","event_notification_t",0);
	 SWIG_RegisterMapping("struct event_notification","event_notification",0);
	 SWIG_RegisterMapping("unsigned int","int",0);
	 SWIG_RegisterMapping("event_notification","event_notification_t",0);
	 SWIG_RegisterMapping("event_notification","struct event_notification",0);
	 SWIG_RegisterMapping("event_handle_t","event_handle",0);
	 SWIG_RegisterMapping("event_handle_t","struct event_handle",0);
	 SWIG_RegisterMapping("struct callback_data","callback_data_t",0);
	 SWIG_RegisterMapping("struct callback_data","callback_data",0);
	 SWIG_RegisterMapping("signed long","long",0);
	 ST(0) = &sv_yes;
	 XSRETURN(1);
}
