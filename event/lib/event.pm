# This file was automatically generated by SWIG
package event;
require Exporter;
require DynaLoader;
@ISA = qw(Exporter DynaLoader);
@EXPORT = qw(address_tuple_alloc address_tuple_free event_register event_register_withkeyfile event_register_withkeydata event_unregister c_event_poll c_event_poll_blocking dont_use_this_function_because_it_does_not_work event_notify event_schedule event_notification_alloc event_notification_free event_notification_clone event_notification_get_double event_notification_get_int32 event_notification_get_int64 event_notification_get_opaque c_event_notification_get_string event_notification_put_double event_notification_put_int32 event_notification_put_int64 event_notification_put_opaque event_notification_put_string event_notification_remove c_event_subscribe event_notification_insert_hmac event_notification_pack event_notification_unpack xmalloc xrealloc allocate_callback_data free_callback_data dequeue_callback_data enqueue_callback_data perl_stub_callback stub_event_subscribe event_notification_get_string event_notification_get_site event_notification_get_expt event_notification_get_group event_notification_get_host event_notification_get_objtype event_notification_get_objname event_notification_get_eventtype event_notification_get_arguments event_notification_set_arguments event_notification_get_sender event_notification_set_sender event_handle_server_set event_handle_server_get event_handle_status_set event_handle_status_get event_handle_keydata_set event_handle_keydata_get event_handle_keylen_set event_handle_keylen_get event_notification_elvin_notification_set event_notification_elvin_notification_get event_notification_has_hmac_set event_notification_has_hmac_get address_tuple_site_set address_tuple_site_get address_tuple_expt_set address_tuple_expt_get address_tuple_group_set address_tuple_group_get address_tuple_host_set address_tuple_host_get address_tuple_objtype_set address_tuple_objtype_get address_tuple_objname_set address_tuple_objname_get address_tuple_eventtype_set address_tuple_eventtype_get address_tuple_scheduler_set address_tuple_scheduler_get callback_data_callback_notification_set callback_data_callback_notification_get callback_data_next_set callback_data_next_get  );
package eventc;
bootstrap event;
var_event_init();

# ---------- BASE METHODS -------------

package event;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package event;

sub address_tuple_alloc {
    my @args = @_;
    my $result = eventc::address_tuple_alloc(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "address_tuple", $result;
    return bless \%resulthash, "address_tuple";
}
sub address_tuple_free {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::address_tuple_free(@args);
    return $result;
}
sub event_register {
    my @args = @_;
    my $result = eventc::event_register(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "event_handle", $result;
    return bless \%resulthash, "event_handle";
}
sub event_register_withkeyfile {
    my @args = @_;
    my $result = eventc::event_register_withkeyfile(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "event_handle", $result;
    return bless \%resulthash, "event_handle";
}
sub event_register_withkeydata {
    my @args = @_;
    my $result = eventc::event_register_withkeydata(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "event_handle", $result;
    return bless \%resulthash, "event_handle";
}
sub event_unregister {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::event_unregister(@args);
    return $result;
}
sub c_event_poll {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::c_event_poll(@args);
    return $result;
}
sub c_event_poll_blocking {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::c_event_poll_blocking(@args);
    return $result;
}
sub dont_use_this_function_because_it_does_not_work {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::dont_use_this_function_because_it_does_not_work(@args);
    return $result;
}
sub event_notify {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notify(@args);
    return $result;
}
sub event_schedule {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_schedule(@args);
    return $result;
}
sub event_notification_alloc {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_alloc(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "event_notification", $result;
    return bless \%resulthash, "event_notification";
}
sub event_notification_free {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_free(@args);
    return $result;
}
sub event_notification_clone {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_clone(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "event_notification", $result;
    return bless \%resulthash, "event_notification";
}
sub event_notification_get_double {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_double(@args);
    return $result;
}
sub event_notification_get_int32 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_int32(@args);
    return $result;
}
sub event_notification_get_int64 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_int64(@args);
    return $result;
}
sub event_notification_get_opaque {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_opaque(@args);
    return $result;
}
sub c_event_notification_get_string {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::c_event_notification_get_string(@args);
    return $result;
}
sub event_notification_put_double {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_put_double(@args);
    return $result;
}
sub event_notification_put_int32 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_put_int32(@args);
    return $result;
}
sub event_notification_put_int64 {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_put_int64(@args);
    return $result;
}
sub event_notification_put_opaque {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_put_opaque(@args);
    return $result;
}
sub event_notification_put_string {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_put_string(@args);
    return $result;
}
sub event_notification_remove {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_remove(@args);
    return $result;
}
sub c_event_subscribe {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[2] = tied(%{$args[2]});
    my $result = eventc::c_event_subscribe(@args);
    return $result;
}
sub event_notification_insert_hmac {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_insert_hmac(@args);
    return $result;
}
sub event_notification_pack {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_pack(@args);
    return $result;
}
sub event_notification_unpack {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::event_notification_unpack(@args);
    return $result;
}
*xmalloc = *eventc::xmalloc;
*xrealloc = *eventc::xrealloc;
sub allocate_callback_data {
    my @args = @_;
    my $result = eventc::allocate_callback_data(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "callback_data", $result;
    return bless \%resulthash, "callback_data";
}
sub free_callback_data {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::free_callback_data(@args);
    return $result;
}
sub dequeue_callback_data {
    my @args = @_;
    my $result = eventc::dequeue_callback_data(@args);
    return undef if (!defined($result));
    my %resulthash;
    tie %resulthash, "callback_data", $result;
    return bless \%resulthash, "callback_data";
}
sub enqueue_callback_data {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    my $result = eventc::enqueue_callback_data(@args);
    return $result;
}
sub perl_stub_callback {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::perl_stub_callback(@args);
    return $result;
}
sub stub_event_subscribe {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::stub_event_subscribe(@args);
    return $result;
}
sub event_notification_get_string {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_string(@args);
    return $result;
}
sub event_notification_get_site {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_site(@args);
    return $result;
}
sub event_notification_get_expt {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_expt(@args);
    return $result;
}
sub event_notification_get_group {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_group(@args);
    return $result;
}
sub event_notification_get_host {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_host(@args);
    return $result;
}
sub event_notification_get_objtype {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_objtype(@args);
    return $result;
}
sub event_notification_get_objname {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_objname(@args);
    return $result;
}
sub event_notification_get_eventtype {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_eventtype(@args);
    return $result;
}
sub event_notification_get_arguments {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_arguments(@args);
    return $result;
}
sub event_notification_set_arguments {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_set_arguments(@args);
    return $result;
}
sub event_notification_get_sender {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_get_sender(@args);
    return $result;
}
sub event_notification_set_sender {
    my @args = @_;
    $args[0] = tied(%{$args[0]});
    $args[1] = tied(%{$args[1]});
    my $result = eventc::event_notification_set_sender(@args);
    return $result;
}

############# Class : event_handle ##############

package event_handle;
@ISA = qw( event );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "eventc::event_handle_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "eventc::event_handle_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['server', 'status', 'keydata', 'keylen', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['server', 'status', 'keydata', 'keylen', ];
        return ();
    }
}


############# Class : event_notification ##############

package event_notification;
@ISA = qw( event );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "eventc::event_notification_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "eventc::event_notification_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['elvin_notification', 'has_hmac', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['elvin_notification', 'has_hmac', ];
        return ();
    }
}


############# Class : address_tuple ##############

package address_tuple;
@ISA = qw( event );
%OWNER = ();
%BLESSEDMEMBERS = (
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "eventc::address_tuple_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "eventc::address_tuple_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['site', 'expt', 'group', 'host', 'objtype', 'objname', 'eventtype', 'scheduler', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['site', 'expt', 'group', 'host', 'objtype', 'objname', 'eventtype', 'scheduler', ];
        return ();
    }
}


############# Class : callback_data ##############

package callback_data;
@ISA = qw( event );
%OWNER = ();
%BLESSEDMEMBERS = (
    callback_notification => 'event_notification',
    next => 'callback_data',
);

%ITERATORS = ();
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
    };

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
    };

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "eventc::callback_data_${field}_get";
    my $val = &$member_func($self);
    if (exists $BLESSEDMEMBERS{$field}) {
        return undef if (!defined($val));
        my %retval;
        tie %retval,$BLESSEDMEMBERS{$field},$val;
        return bless \%retval, $BLESSEDMEMBERS{$field};
    }
    return $val;
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "eventc::callback_data_${field}_set";
    if (exists $BLESSEDMEMBERS{$field}) {
        &$member_func($self,tied(%{$newval}));
    } else {
        &$member_func($self,$newval);
    }
}

sub FIRSTKEY {
    my $self = shift;
    $ITERATORS{$self} = ['callback_notification', 'next', ];
    my $first = shift @{$ITERATORS{$self}};
    return $first;
}

sub NEXTKEY {
    my $self = shift;
    $nelem = scalar @{$ITERATORS{$self}};
    if ($nelem > 0) {
        my $member = shift @{$ITERATORS{$self}};
        return $member;
    } else {
        $ITERATORS{$self} = ['callback_notification', 'next', ];
        return ();
    }
}


# ------- VARIABLE STUBS --------

package event;

*MAXHOSTNAMELEN = *eventc::MAXHOSTNAMELEN;
*ADDRESSTUPLE_ANY = *eventc::ADDRESSTUPLE_ANY;
*ADDRESSTUPLE_ALL = *eventc::ADDRESSTUPLE_ALL;
*OBJECTTYPE_TESTBED = *eventc::OBJECTTYPE_TESTBED;
*OBJECTTYPE_TRAFGEN = *eventc::OBJECTTYPE_TRAFGEN;
*EVENT_HOST_ANY = *eventc::EVENT_HOST_ANY;
*EVENT_NULL = *eventc::EVENT_NULL;
*EVENT_TEST = *eventc::EVENT_TEST;
*EVENT_SCHEDULE = *eventc::EVENT_SCHEDULE;
*EVENT_TRAFGEN_START = *eventc::EVENT_TRAFGEN_START;
*EVENT_TRAFGEN_STOP = *eventc::EVENT_TRAFGEN_STOP;

my %__callback_data_list_hash;
tie %__callback_data_list_hash,"callback_data", $eventc::callback_data_list;
$callback_data_list= \%__callback_data_list_hash;
bless $callback_data_list, callback_data;
*event_string_buffer = *eventc::event_string_buffer;
1;
#
# CODE PAST THIS POINT WAS NOT AUTOMATICALLY GENERATED BY SWIG
#
# For now, this has to get cat'ed onto the end of event.pm, since it
# doesn't seem possible to get SWIG to just pass it through into the
# output file
#

#
# Stash away the given callback and data, and call the C event_subscribe
# function that uses a stub callback
#
sub event_subscribe($$$;$) {
	my ($handle,$function,$tuple,$data) = @_;
	$event::callback = $function;
	$event::callback_data = $data;
	return stub_event_subscribe($handle,$tuple);
}

#
# Clear $callback_ready, call the C event_poll function, and see if the
# C callback got called (as evidenced by $callback_ready getting set) If it
# did, call the perl callback function. Handle both blocking and non-blocking
# versions of the call
#
sub internal_event_poll($$$) {
	my ($handle, $block, $timeout) = @_;

	my $rv;
	if ($block) {
		$rv = c_event_poll_blocking($handle,$timeout);
	} else {
		$rv = c_event_poll($handle);
	}

	if ($rv) {
		die "Trouble in event_poll - returned $rv\n";
	}

	while (my $data = dequeue_callback_data() ) {
		&$event::callback($handle,$data->{callback_notification},
				$event::callback_data);
		event_notification_free($handle,$data->{callback_notification});
		free_callback_data($data);
	}

	return 0;
}

#
# Wrapper for the internal polling function, non-blocking version
#
sub event_poll($) {
	my $handle = shift;
	return &internal_event_poll($handle,0,0);
}

#
# Same as above, but for the blocking version
#
sub event_poll_blocking($$) {
	my ($handle, $timeout) = @_;
	return &internal_event_poll($handle,1,$timeout);
}

#
# NOTE: The following line will only work if this module is included by
# a file that has already done a 'use lib' to get the path to testbed
# libraries in the INC path. But, since they had to do that to get this
# library anyway, shouldn't be a problem. (Didn't want to have to make
# this a .in file.)
#
use libtestbed;

#
# Conveniece functions - Intended to work like DBQuery* from libdb .
# Much of this code shamlessly ripped off from libdb.pm
#

#
# Warn after a failed event send. First argument is the error
# message to display. The contents of $EventErrorString is also printed.
# 
# usage: EventWarn(char *message)
#
sub EventWarn($) {
	my($message) = $_[0];
	my($text, $progname);

	#
	# Must taint check $PROGRAM_NAME cause it comes from outside. Silly!
	#
	if ($PROGRAM_NAME =~ /^([-\w.\/]+)$/) {
		$progname = $1;
	} else {
		$progname = "Tainted";
	}

	$text = "$message - In $progname\n" .
		"$EventErrorString\n";

	print STDERR "*** $text";
}

#
# Same as above, but die after the warning.
# 
# usage: EventFatal(char *message);
#
sub EventFatal($) {
	my($message) = $_[0];

	EventWarn($message);

	die("\n");
}


#
# Conveniece function - Intended to work like DBQueryFatal from libdb
#
sub EventSendFatal(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventFatal("Event Send failed");
	}

	return $result;
}

#
# Conveniece function - Intended to work like DBQueryWarn from libdb
#
sub EventSendWarn(@) {
	my @tuple = @_;
    
	my $result = EventSend(@tuple);

	if (!$result) {
		EventWarn("Event Send failed");
	}

	return $result;
}

#
# Register with the event system. You would use this if you are not
# running on boss. The inline registration below is a convenience for
# testbed software, but is technically bad practice. See the END block
# below where we disconnect at exit.
#
sub EventRegister(;$$) {
        my ($host, $port) = @_;

	if ($event::EventSendHandle) {
	        if (event_unregister($event::EventSendHandle) == 0) {
			warn "Could not unregister with event system";
		}
		$event::EventSendHandle = undef;
	}

	$host = TB_EVENTSERVER()
	    if (!defined($host));

	my $URL = "elvin://$host";
	$URL   .= ":$port"
	    if (defined($port));
	
	$event::EventSendHandle = event_register($URL,0);
	
	if (!$event::EventSendHandle) {
		$EventErrorString = "Unable to register with the event system";
		return undef;
	}

	return 1;
}

sub EventSend(@) {
	my %tuple_values = @_;

	#
	# Only connect on the first call - thereafter, just use the existing
	# handle. The handle gets disconnected in the END block below
	#
	if (!$event::EventSendHandle) {
		EventRegister("localhost", TB_BOSSEVENTPORT());

		if (!$event::EventSendHandle) {
			$EventErrorString =
				"Unable to register with the event system";
			return undef;
		}
	}

	my $tuple = address_tuple_alloc();
	if (!$tuple) {
		$EventErrorString = "Unable to allocate an address tuple";
		return undef;
	}

	#
	# Set the values the user requested
	#
	%$tuple = %tuple_values;

	my $notification = event_notification_alloc($event::EventSendHandle,
		$tuple);
	if (!$notification) {
		$EventErrorString = "Could not allocate notification";
		return undef;
	}

	if (!event_notify($event::EventSendHandle, $notification)) {
		$EventErrorString = "Could not send event notification";
		return undef;
	}

	event_notification_free($event::EventSendHandle, $notification);
	address_tuple_free($tuple);

	return 1;
}

#
# After a fork, undef the handle to the event system so that we form a
# a new connection in the child. Do not disconnect from the child; I have
# no idea what that will do to the parent connection.
#
sub EventFork() {
    $event::EventSendHandle = undef;
}

#
# When we exit, unregister with the event system if we're connected
#
END {
    	if ($event::EventSendHandle) {
		if (event_unregister($event::EventSendHandle) == 0) {
			warn "Could not unregister with event system";
		}
	}
}

push @EXPORT, qw(event_subscribe event_poll event_poll_blocking EventSend
	EventSendFatal EventSendWarn EventFork EventRegister);
1;

