#!/usr/bin/perl
package TestBed::XMLRPC::Client;
use SemiModern::Perl;
use Mouse;
use RPC::XML::Client;
use TBConfig;
use Data::Dumper;
use Carp;
use Tools;

my $loglevel = "INFO";
$loglevel = "DEBUG" if $TBConfig::DEBUG_XML_CLIENT;
my $logger = init_tbts_logger("XMLRPCClient", undef, "INFO", "SCREEN");


#ensures loading of client side SSL certificates
BEGIN {
  use TBConfig;
  $ENV{HTTPS_CERT_FILE} = glob($TBConfig::SSL_CLIENT_CERT);
  $ENV{HTTPS_KEY_FILE}  = glob($TBConfig::SSL_CLIENT_KEY);
}

#constructs RPC::XML::Client with 10 minute socket timeout
has 'client' => ( isa => 'RPC::XML::Client', is => 'rw', default => sub { 
  my $HTTP_TIMEOUT = $TBConfig::XMLRPC_SERVER_TIMEOUT;
  my $c = RPC::XML::Client->new($TBConfig::XMLRPC_SERVER, 'timeout' => ($HTTP_TIMEOUT));
  $c->{'__useragent'}->timeout($HTTP_TIMEOUT);
  $c; } );

#autoloaded/autogenerated/method_missings/etc
#automatically constructs XMLRPC resquests for any sub name not defined in the package
our $AUTOLOAD;
sub AUTOLOAD {
  my $self = shift;
  my $type = ref($self) or croak "$self is not an object";
  $self->xmlrpc_req_value(($self->xmlrpcfunc($AUTOLOAD))[0], $self->args(@_));
}

sub args { 
  my $self = shift;
  +{ @_ };
}

sub xmlrpcfunc {
  $_[1] =~ m/.*:([^:]*)::([^:]*)/;
  my ($package, $funcname) = (lc($1), $2);
  $funcname =~ s/\_.*//;
  ("$package.$funcname", $package, $funcname);
}

sub pkgfunclist { 
  my $caller = ((caller(3))[3]);
  (shift->xmlrpcfunc($caller));
}

sub pkgfunc { (shift->pkgfunclist())[0]; }
sub pkg     { (shift->pkgfunclist())[1]; }
sub func    { (shift->pkgfunclist())[2]; }

sub single_request {
  my ($self, $command, @args) = @_;
  $logger->debug(toperl($command, @args));
  $logger->debug("Sent");
  if ($TBConfig::DEBUG_XML_CLIENT) {
    say("Sent");
    sayperl($command, @args)
  }
  my $resp = $self->client->send_request($command, $TBConfig::XMLRPC_VERSION, @args); 
  $logger->debug("Received");
  $logger->debug( sub { Dumper($resp); } );
  if ($TBConfig::DEBUG_XML_CLIENT) {
    say("Received");
    say Dumper($resp);
  }
  if ((!ref($resp)) && ($resp =~ /SSL \w+ timeout/)) {
    die "SSL_SOCKET_TIMEOUT";
  }
  $resp;
}

sub xmlrpc_req        { single_request(@_)->value; }
sub xmlrpc_req_value  { single_request(@_)->value-> {'value'}; }
sub xmlrpc_req_output { single_request(@_)->value-> {'output'}; }
sub xmlrpc_req_code   { single_request(@_)->value-> {'code'}; }
sub augment { 
  my $self = shift;
  $self->xmlrpc_req_value($self->pkgfunc(), $self->args(@_));
}
sub augment_output { 
  my $self = shift;
  $self->xmlrpc_req_output($self->pkgfunc(), $self->args(@_));
}
sub augment_code { 
  my $self = shift;
  $self->xmlrpc_req_code($self->pkgfunc(), $self->args(@_));
}
sub augment_code0 { 
  my $self = shift;
  my $result = $self->xmlrpc_req($self->pkgfunc(), $self->args(@_));
  if ( $result->{'code'} ) {
    print $result->{'output'};
  }
  $result->{'code'};
}
sub augment_func { 
  my $self = shift;
  $self->xmlrpc_req_value($self->pkg() . "." . shift, $self->args(@_));
}
sub augment_func_output { 
  my $self = shift;
  $self->xmlrpc_req_output($self->pkg() . "." . shift, $self->args(@_));
}
sub augment_func_code { 
  my $self = shift;
  $self->xmlrpc_req_code($self->pkg() . "." . shift, $self->args(@_));
}

sub augment_func_code0 { 
  my $self = shift;
  my $result = $self->xmlrpc_req($self->pkg() . "." . shift, $self->args(@_));
  if ( $result->{'code'} ) {
    print $result->{'output'};
  }
  $result->{'code'};
}

=head1 NAME

TestBed::XMLRPC::Client

=over 4

=item C<< $client->args(@args) >>

default implementation of arg stuffing.
overridable by subclasses

=item C<< xmlrpcfunc($fq_package_name) >>

B<INTERNAL:>
takes a fully qualified package name and generates xml package and function names
strips _.* off the end of the function name
returns ("$package.$funcname", $package, $funcname)

=item C<< pkgfunclist >>

B<INTERNAL:> reaches up the caller chain three levels and returns the fully qualified package name

=item C<< pkgfunc >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< pkg >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< func >>

B<INTERNAL:> reaches up the caller chain three levels and returns the XMLRPC package.function

=item C<< $client->single_request($command, @args) >>

B<INTERNAL:> executes a single XMLRPC $command with @args and returns a XMLRPC response

=item C<< $client->xmlrpc_req_value(@args) >>

B<INTERNAL:> returns the value member of a XMLRPC call with @args 

=item C<< $client->xmlrpc_req_output(@args) >>

B<INTERNAL:> returns the output member of a XMLRPC call with @args 

=item C<< $client->xmlrpc_req_code(@args) >>

B<INTERNAL:> returns the code member of a XMLRPC call with @args 

=item C<< $client->augment(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse value

=item C<< $client->augment_output(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse ouput

=item C<< $client->augment_code(@other_args) >>

executes xmlrpc request divining the XMLRPC package and function from the current perl package and function
returns XMLRPC reponse code

=item C<< $client->augment_func($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse value

=item C<< $client->augment_func_output($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse output

=item C<< $client->augment_code($funcname, @other_args) >>

executes xmlrpc request divining the XMLRPC package from the current perl package
returns XMLRPC reponse code

=back

=cut

1;
