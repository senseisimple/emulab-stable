#! /usr/bin/env python

#
# EMULAB-COPYRIGHT
# Copyright (c) 2004, 2005, 2006 University of Utah and the Flux Group.
# All rights reserved.
#

import re
import pwd
import sys
import glob
import sets
import stat
import time
import getopt
import socket
import zipfile
import tempfile
import cStringIO
import threading
import xmlrpclib
import os, os.path
import ConfigParser

prefix = "@prefix@"

TBPATH = os.path.join(prefix, "lib")
if TBPATH not in sys.path:
    sys.path.append(TBPATH)
    pass

from tbevent import *

PACKAGE_VERSION = 0.1

# Default server
XMLRPC_SERVER = "@BOSSNODE@"
XMLRPC_PORT   = 3069

RSYNC = "@RSYNC@"
ACCEPTABLE_RSYNC_STATUS = [ 0 ]
NONRETRIABLE_RSYNC_STATUS = [ 0, 1, 2, 4 ]

DIRS = {
    "proj" : "proj",
    "groups" : "groups",
    }

EXPDIR_FMT = os.path.join("/", DIRS["proj"], "%(PID)s", "exp", "%(EID)s")

GLOBAL_LOGS = [
    "event-sched.log", "feedback.log", "../tbdata/feedback_data.tcl",
    "digest.out", "report.mail", "../tbdata/%(EID)s.report"
    ]

EXTENSIONS = [ ".zip" ]

LINK_DUMP_FMT = [ "trace_%s-%s.xmit", "trace_%s-%s.recv" ]

CLEANFILE = ".cleanonsync"

DOT_LOGHOLES = ""

DEFAULT_LOGHOLES = ["/var/emulab/logs", "/local/logs"]

DELAYLOG2XPLOT = os.path.join(prefix, "bin", "delaylog2xplot")

MERGECAP = "/usr/X11R6/bin/mergecap"
TCPTRACE = "/usr/local/bin/tcptrace"

PID = None
EID = None

COLLAB_PW = None
DPDBNAME  = None

try:
    pw = pwd.getpwuid(os.getuid())
    pass
except KeyError:
    sys.stderr.write("error: unknown user id %d" % os.getuid())
    sys.exit(2)
    pass

USER = pw.pw_name
HOME = pw.pw_dir

CERTIFICATE = os.path.join(HOME, ".ssl", "emulab.pem")

PARALLELIZATION = 25

DEBUG = 0

VERBOSITY_MACHINE = 1
VERBOSITY_HUMAN = 2

VERBOSITY = VERBOSITY_HUMAN

SERVER = None

OSIDS = {}

JOB_TRIES = 3
JOB_PROGRESS = [ "-", "\\", "|", "/" ]
JOB_PROGRESS_INDEX = 0

if len(XMLRPC_SERVER) == 0:
    sys.stderr.write("internal error: XMLRPC_SERVER is empty\n")
    sys.exit(2)
    pass

if len(RSYNC) == 0:
    sys.stderr.write("internal error: RSYNC is empty\n")
    sys.exit(2)
    pass

IDENTITY = None

try:
    auth = open(os.path.join(HOME, ".ssh", "authorized_keys"), "r").read()

    for (pub, full) in ((os.path.join(HOME, ".ssh", "identity.pub"),
                         (1, os.path.join(HOME, ".ssh", "identity"))),
                        (os.path.join(HOME, ".ssh", "id_rsa.pub"),
                         (2, os.path.join(HOME, ".ssh", "id_rsa")))):
        try:
            idpub = open(pub, "r").read()
            
            if auth.find(idpub) != -1:
                IDENTITY = full
                break
            pass
        except IOError:
            pass
        pass
    pass
except IOError:
    pass


def loghole_include(path):
    retval = ""

    prefix = "/"
    for comp in path.split("/"):
        if comp != "":
            prefix = prefix + comp + "/"
            retval = retval + "+ " + prefix + "\n"
            pass
        pass

    retval = retval + "+ " + prefix + "**\n"
    
    return retval

for path in DEFAULT_LOGHOLES:
    DOT_LOGHOLES += loghole_include(path)
    pass

##
# Initialize the XML-RPC server proxy, if it has not already been done.  After
# returning, the SERVER variable will hold the proxy object.
#
def init_server():
    global SERVER

    if not SERVER:
        if not os.path.exists(CERTIFICATE):
            sys.stderr.write("error: missing emulab certificate: %s\n" %
                             CERTIFICATE)
            sys.exit(2)
            pass
        
        from M2Crypto.m2xmlrpclib import SSL_Transport
        from M2Crypto import SSL
        
        URI = "https://" + XMLRPC_SERVER + ":" + str(XMLRPC_PORT) + prefix
        
        ctx = SSL.Context("sslv23")
        ctx.load_cert(CERTIFICATE, CERTIFICATE)
        ctx.set_verify(SSL.verify_none, 16)
        ctx.set_allow_unknown_ca(0)
        
        SERVER = xmlrpclib.ServerProxy(URI, SSL_Transport(ctx))
        pass
    return

##
# Download the user's experiment list from the XML-RPC server.
#
# @return A list of (pid, eid) pairs for each experiment created by the user.
#
def get_explist():
    global SERVER

    from emulabclient import RESPONSE_SUCCESS
    
    retval = []
    
    init_server()
    
    list_method = getattr(SERVER, "experiment.getlist")
    elist = list_method(PACKAGE_VERSION, {})
    
    if elist["code"] != RESPONSE_SUCCESS:
        sys.stderr.write("error: " + elist["output"] + "\n")
        sys.exit(1)
        pass
    else:
        for project in elist["value"]:
            for group in elist["value"][project]:
                for exp in elist["value"][project][group]:
                    retval.append((project, exp))
                    pass
                pass
            pass
        pass
    
    return retval

##
# Print the top level usage statement for the whole tool.
#
def usage():
    print "Usage: loghole [-hV] [-e pid/eid|-a] [OPTIONS] <action> [...]"
    print
    print "Manage an experiment's log hole."
    print
    print "Optional arguments:"
    print "  -h, --help                Print this message, or the action's"
    print "                            usage message."
    print "  -V, --version             Print version information."
    print "  -d, --debug               Turn on debugging messages."
    print "  -q, --quiet               Be less verbose."
    print "  -v, --verbose             Be more verbose."
    print "  -e, --experiment=PID/EID  Specify the experiment to manage."
    print "  -a, --all                 Perform the action on all of your "
    print "                            experiments."
    print "  -s, --server=SERVER       Specify the XML-RPC server to use."
    print "                            (Default: %s)" % XMLRPC_SERVER
    print "  -P, --port=PORT           Specify the XML-RPC server port."
    print "                            (Default: %d)" % XMLRPC_PORT
    print
    print "Actions:"
    print "  sync      Synchronize the experiment's log holes with the"
    print "            experiment's log directory."
    print "  archive   Archive the contents of the experiment's log directory."
    print "  change    Change the metadata of an existing archive."
    print "  list      Print a brief listing of the archives in the"
    print "            experiment's log directory."
    print "  show      Show a detailed listing of the archive(s) in the"
    print "            experiment directory."
    print "  validate  Validate the experiment logs."
    print "  clean     Clean the experiment log directory and node local"
    print "            directories."
    print "  gc        Garbage collect old archives."
    print
    print "Environment:"
    print "  cwd       The project and experiment ID will be inferred from the"
    print "            current working directory, if it is inside the"
    print "            experiment's directory (e.g. /proj/foo/exp/bar)."
    print
    print "Examples:"
    print "  $ loghole -e foo/bar sync"
    print "  $ loghole -e foo/bar list"
    return

##
# Print the usage statement for the "sync" action.
#
def sync_usage():
    print "Usage: loghole sync [-nPs] [-r remotedir] [-l localdir] [node1 ...]"
    print
    print "Synchronize the experiment's log holes with a local directory."
    print
    print "Optional arguments:"
    print "  -r, --remote=REMOTEDIR"
    print "               An additional remote directory to sync.  This option"
    print "               is additive, so you can download several additional"
    print "               directories."
    print "  -l, --local=LOCALDIR"
    print "               The local directory to store the downloaded files."
    print "               This defaults to the experiment's log directory."
    print "  -n, --no-standard"
    print "               Flag that indicates that the standard logholes"
    print "               (i.e. '/var/emulab/logs', '/local/logs') should not"
    print "               be downloaded."
    print "  -P, --no-post"
    print "               Do not do any additional post processing."
    print "  -s, --snapshot"
    print "               Send a SNAPSHOT event to any link trace agents."
    print "  node1 ...    The names of the virtual or physical nodes that "
    print "               should be synced.  The default behavior is to sync "
    print "               all of the nodes in an experiment."
    print
    print "Files:"
    print "  /proj/<pid>/exp/<eid>/logs/<node>/<loghole>"
    print "               The location of the log hole for a particular node."
    print
    print "Examples:"
    print "  $ loghole sync"
    return

##
# Print the usage statement for the "archive" action.
#
def archive_usage():
    print ("Usage: loghole archive [-k (i-delete|space-is-needed)] "
           "[-a days] [-c comment] [-d] [archive-name]")
    print
    print "Archive the contents of the experiment's log directory.  The"
    print "archive will be a zip file containing all of the directories"
    print "under the experiment's log directory, any extra log files"
    print "at the top (e.g. event-sched.log), and some metadata."
    print
    print "Optional arguments:"
    print "  -k, --keep-until=(i-delete|space-is-needed)"
    print "                         Keep the archive until you decide to"
    print "                         delete it manually or space is needed."
    print "                         (Default: space-is-needed)"
    print "  -a, --keep-atleast=N   Keep the archive atleast N days after"
    print "                         creation.  This value keeps the archive "
    print "                         from being garbage collected when more "
    print "                         space is needed. (Default: 3 days)"
    print "  -c, --comment=COMMENT  Add a comment to the archive. This comment"
    print "                         will be displayed in the listing generated"
    print "                         by the 'show' action.  Use a single dash "
    print "                         (-) to read the comment from standard in."
    print "  -d, --delete           Mark the experiment as clean-on-sync to"
    print "                         remove stale data before another sync."
    print
    print "Required arguments:"
    print "  archive-name  The name of the archive to create."
    print "                (Default: The experiment name)"
    print
    print "Files:"
    print "  /proj/<pid>/exp/<eid>/logs/<archive-name>.<instance>.zip"
    print
    print "Examples:"
    print "  $ loghole archive foobar"
    return

##
# Print the usage statement for the "list" action.
#
def list_usage():
    print "Usage: loghole list [-O1!Xo] [-m atmost] [-s megabytes]"
    print
    print "Print a brief listing of the archives in the experiment's log"
    print "directory.  The listing can be helpful in getting an idea of"
    print "what archives are in your experiment and when they are likely"
    print "to be garbage collected."
    print
    print "Optional arguments:"
    print "  -O                    Only list archives that are marked as 'keep"
    print "                        until \"i-delete\"'."
    print "  -1                    Only list archives that are a day from"
    print "                        their keep-atleast date."
    print "  -!                    Only list archives that are past their"
    print "                        keep-atleast date."
    print "  -X                    Only list archives that are ready to be"
    print "                        garbage collected."
    print "  -o                    List archives that do not match the above"
    print "                        flags."
    print "  -m, --keep-atmost=N   Keep at most N archives in the experiment."
    print "                        (Default: 100)"
    print "  -s, --keep-size=N     Keep at N megabytes of archives."
    print "                        (Default: 3.0 MB)"
    print
    print "Examples:"
    print "  $ loghole list"
    print "  GC  Name             Date"
    print
    print "  [ ] foobar.1.zip     10/15"
    print "  [!] foobar.0.zip     10/13"
    print "  ..."
    print
    print "  $ loghole -q list -!"
    print "  foobar.0.zip"
    return

##
# Print the usage statement for the "show" action.
#
def show_usage():
    print "Usage: loghole show [archive-name]"
    print
    print "Show a detailed listing of the archive(s) in the experiment"
    print "directory.  The listing shows all of the metadata for the archive,"
    print "comments, and the file listing."
    print
    print "Example:"
    print "  $ loghole show foobar"
    print "  Archive: foobar.0.zip"
    print "    Creator:\t\t%s" % USER
    print "    ..."
    print "  Archive: foobar.1.zip"
    print "    ..."
    return

##
# Print the usage statement for the "change" action.
#
def change_usage():
    print ("Usage: loghole change [-k (i-delete|space-is-needed)] "
           "[-a days] [-c comment] <archive-name1> [archive-name2 ...]")
    print
    print "Change the metadata of an existing archive."
    print
    print "Optional arguments:"
    print "  -k, --keep-until=(i-delete|space-is-needed)"
    print "                         Keep the archive until you decide to"
    print "                         delete it manually or space is needed."
    print "                         (Default: space-is-needed)"
    print "  -a, --keep-atleast=N   Keep the archive atleast N days after"
    print "                         creation.  This value keeps the archive "
    print "                         from being garbage collected when more "
    print "                         space is needed. (Default: 3 days)"
    print "  -c, --comment=COMMENT  Add a comment to the archive. This comment"
    print "                         will be displayed in the listing generated"
    print "                         by the 'show' action.  Use a single dash "
    print "                         (-) to read the comment from standard in."
    print
    print "Required arguments:"
    print "  archive-name  The name of the archive to change."
    print
    print "Files:"
    print "  /proj/<pid>/exp/<eid>/logs/<archive-name>.<instance>.zip"
    print
    print "Examples:"
    print "  $ loghole change -c 'Results bad...' foobar"
    return

##
# Print the usage statement for the "validate" action.
#
def validate_usage():
    print "Usage: loghole validate"
    print
    print "Validate the experiment logs.  Currently, this action will:"
    print
    print "  1. Examine the log files from individual logs from the "
    print "     program-agent to verify that the files are intact."
    print "  2. Check that the referent of any soft-links exist."
    print
    print "Examples:"
    print "  $ loghole validate"
    return

##
# Print the usage statement for the "clean" action.
#
def clean_usage():
    print "Usage: loghole clean [-fner] [node1 ...]"
    print
    print "Clean the experiment log directory by removing any subdirectories"
    print "and/or clean the log holes on the nodes.  The default behavior is"
    print "to clean both."
    print
    print "Optional arguments:"
    print "  -f, --force         Do not ask for confirmation."
    print "  -n, --nodes         Clean only the nodes log directories."
    print "  -e, --experiment    Clean only the experiment log directory."
    print "  -r, --root          Use sudo to clean nodes as root."
    print
    print "Examples:"
    print "  $ loghole clean"
    return

##
# Print the usage statement for the "gc" action.
#
def gc_usage():
    print "Usage: loghole gc [-n] [-m atmost] [-s megabytes]"
    print
    print "Garbage collect old log archives."
    print
    print "Optional arguments:"
    print "  -n, --dry-run         Perform a dry run, do not delete any files."
    print "  -m, --keep-atmost=N   Keep at most N archives in the experiment."
    print "                        (Default: 100)"
    print "  -s, --keep-size=N     Keep at N megabytes of archives."
    print "                        (Default: 3.0 MB)"
    print
    print "Examples:"
    print "  $ loghole gc -n -m 1"
    print "  Reclaimed 3421 bytes from foo/bar."
    print "  52434 bytes are still in foo/bar."
    print
    print "  $ loghole -q gc -m 1"
    print "  3421 52434"
    return

##
# Infer the project and experiment IDs from the given list of directories.
#
# @param *args The list of directories to check for likely PID/EID values.
# @return A pair containing the project and experiment IDs, which will be None
# if the IDs could not be inferred.
#
def infer_pid_eid(*args):
    pid = None
    eid = None
    for path in args:
        dirs = path.split(os.path.sep)
        if ((len(dirs) < 6) or not
            ((DIRS["proj"] in dirs and
              "exp" in dirs[dirs.index(DIRS["proj"]):]) or
             (len(dirs) >= 6 and
              (DIRS["groups"] in dirs and
               "exp" in dirs[dirs.index(DIRS["groups"]):])))):
            # No match...
            pass
        else:
            if DIRS["proj"] in dirs:
                pid = dirs[dirs.index(DIRS["proj"]) + 1]
                pass
            else:
                pid = dirs[dirs.index(DIRS["groups"]) + 1]
                pass
            eid = dirs[dirs.index("exp") + 1]
            pass
        pass

    return pid, eid

##
# Attempt to open a loghole archive located at the given path.  An archive
# must be a zip file with a "loghole.cfg" file stored in the root directory.
#
# @param path The path to the loghole archive.
# @return A pair containing the ZipFile object referring to the archive and a
# ConfigParser object that contains the archive's metadata.
#
def open_loghole(path, mode='r'):
    retval = None, None
    if zipfile.is_zipfile(path):
        zf = zipfile.ZipFile(path, mode)
        if "loghole.cfg" in zf.namelist():
            cio = cStringIO.StringIO(zf.read("loghole.cfg"))
            cp = ConfigParser.ConfigParser()
            cp.readfp(cio)
            retval = zf, cp
            zf = None
            pass
        if zf:
            zf.close()
            pass
        pass
    
    return retval

##
# Generate a name that is unique in the context of the given list of entries.
#
# @param base The base of the file name.
# @param ext The file name extension.
# @param entries An iterable containing any existing file names.
# @return A string of the form "<base>.<unique #>.<ext>".
#
def uniquish_name(base, ext, entries):
    retval = None
    lpc = 0
    while not retval:
        name = base + "." + str(lpc) + "." + ext
        if name not in entries:
            retval = name
            pass
        lpc = lpc + 1
        pass
    
    return retval

##
# Callback for os.walk() that writes files to the ZipFile.
#
# @param zf The ZipFile object that files should be added to.
# @param dirname The current directory name.
# @param names The list of files in the current directory.
#
def file_archiver(zf, dirname, names):
    for entry in names:
        entry = os.path.join(dirname, entry)
        if os.path.isfile(entry):
            zf.write(entry)
            pass
        pass

    return

##
# Sort the list of log archives in the current directory based on when they
# should be garbage collected.
#
# @param keep_atmost The maximum number of archives that should be kept, any
# extras are marked as collectable.
# @param keep_size The number of megabytes of archives to keep.
# @return A dictionary containing: "del", a list of archives that will be
# deleted at the next GC; "safe", a list of archives that are marked "keep
# until 'i-delete'"; "soon", the remaining archives; "reclaimed-size", the
# amount of data that will be reclaimed at the next GC; and "inuse-size", the
# amount of data that will remain after the next GC.
#
def sort_archives(keep_atmost, keep_size):
    
    keep_size = keep_size * 1024 * 1024

    reclaimed_size = 0
    inuse_size = 0 # In-use size for non-gc'able archives
    inuse_gc_size = 0 # In-use size for gc'able archives
    
    current_time = time.time()
    
    retval_del = []
    retval_safe = []
    retval_soon = []
    exp_logholes = []

    # Walk the directory collecting archives and sorting them into "safe" and
    # to-be-determined lists.
    for entry in os.listdir(os.curdir):
        st = os.stat(entry)
        lh, cp = open_loghole(entry)
        if lh:
            keep_until = cp.get("MAIN", "keep-until")
            if keep_until == "i-delete":
                if DEBUG:
                    print "loghole: ignoring - " + entry
                    pass

                retval_safe.append(entry)
                inuse_size = inuse_size + st[stat.ST_SIZE]
                pass
            else:
                created = time.mktime(time.strptime(cp.get("MAIN", "created")))
                keep_atleast = (cp.getint("MAIN", "keep-atleast") *
                                60 * 60 * 24)

                inuse_gc_size = inuse_gc_size + st[stat.ST_SIZE]
                exp_logholes.append((entry, st, created + keep_atleast))
                pass
            lh.close()
            pass
        pass

    # Sort the archives from oldest keep-atleast time to newest, then
    exp_logholes.sort(lambda x, y: cmp(x[2], y[2]))

    # ... divide them between the del list and the soon list depending on
    # whether or not space is needed.
    for entry, st, expiration in exp_logholes:
        if inuse_gc_size > keep_size:
            if DEBUG:
                print "loghole: stale entry - " + entry
                pass

            retval_del.append(entry)
            inuse_gc_size = inuse_gc_size - st[stat.ST_SIZE]
            reclaimed_size = reclaimed_size + st[stat.ST_SIZE]
            pass
        else:
            retval_soon.append(entry)
            pass
        pass

    # Resort the list in the reverse direction for keep-atleast time.
    exp_logholes = [x for x in exp_logholes if x[0] in retval_soon]
    exp_logholes.sort(lambda x, y: cmp(y[2], x[2]))

    # Update the inuse_size for the archives below the keep-atmost value, then
    for entry, st, expiration in exp_logholes[0:keep_atmost]:
        if DEBUG:
            print ("loghole: keeping '"
                   + entry
                   + "' until "
                   + time.ctime(expiration))
            pass

        inuse_size = inuse_size + st[stat.ST_SIZE]
        pass

    # ... move the rest to the "del" list and
    for entry, st, expiration in exp_logholes[keep_atmost:]:
        if DEBUG:
            print "loghole: excess entry - " + entry
            pass

        retval_soon.remove(entry)
        retval_del.append(entry)
        reclaimed_size = reclaimed_size + st[stat.ST_SIZE]
        pass

    # ... drop the end of the array.
    del retval_soon[keep_atmost:]

    return {
        "del" : retval_del,
        "safe" : retval_safe,
        "soon" : retval_soon,
        "reclaimed-size" : reclaimed_size,
        "inuse-size" : inuse_size,
        }

##
# Performs the "archive" action, which involves building a zip file containing
# all of the logs.
#
# @param args Action-specific command line arguments.
#
def do_archive(args):
    retval = 0

    keep_until = "space-is-needed"
    keep_atleast = 3
    comments = []
    delete_dir = False

    # Parse action-specific options and arguments.
    try:
        opts, args = getopt.getopt(args, "k:a:c:d", [
            "keep-until=", "keep-atleast=", "comment=", "delete" ])
        for opt, val in opts:
            if opt in ("-k", "--keep-until"):
                if val == "i-delete" or val == "space-is-needed":
                    keep_until = val
                    pass
                else:
                    raise getopt.error(
                        'error: expecting "i-delete" or "space-is-needed" for '
                        'keep until value, got - ' + val)
                pass
            elif opt in ("-a", "--keep-atleast"):
                try:
                    keep_atleast = int(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting integer for keep atleast value, '
                        'got - ' + val)
                pass
            elif opt in ("-c", "--comment"):
                if val == "-":
                    comments.append(sys.stdin.read())
                    pass
                else:
                    comments.append(val)
                    pass
                pass
            elif opt in ("-d", "--delete"):
                delete_dir = True
                pass
            pass
        
        if len(args) > 1:
            raise getopt.error(
                'error: too many arguments for "archive" action.')
        pass
    except getopt.error, e:
        print e.args[0]
        archive_usage()
        return 2

    if len(args) < 1:
        archive_base = EID
        pass
    else:
        archive_base = args[0]
        pass

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    # Figure out a unique name for the archive,
    archive_name = uniquish_name(archive_base, 'zip', os.listdir(logdir))

    # ... create a new zip file,
    zf = zipfile.ZipFile(archive_name, 'w', zipfile.ZIP_DEFLATED)

    # ... fill it up with the node log holes, and
    for entry in os.listdir(logdir):
        if os.path.isdir(entry):
            os.path.walk(entry, file_archiver, zf)
            pass
        pass

    # ... any global log files (e.g. event-sched.log).
    for log in GLOBAL_LOGS:
        formatted_log = log % { "PID" : PID, "EID" : EID }
        if os.path.exists(formatted_log):
            zf.write(formatted_log)
            pass
        pass

    # Construct the meta-data.
    cp = ConfigParser.ConfigParser()
    cp.add_section("MAIN")
    cp.set("MAIN", "created", time.ctime(time.time()))
    cp.set("MAIN", "creator", USER)
    cp.set("MAIN", "project", PID)
    cp.set("MAIN", "experiment", EID)
    cp.set("MAIN", "keep-until", keep_until)
    cp.set("MAIN", "keep-atleast", keep_atleast)
    
    cio = cStringIO.StringIO()
    cp.write(cio)

    loghole_zi = zipfile.ZipInfo()
    loghole_zi.filename = "loghole.cfg"
    ct = time.localtime(time.time())
    loghole_zi.date_time = (ct[0], ct[1], ct[2], ct[3], ct[4], ct[5])
    loghole_zi.compress_type = zipfile.ZIP_STORED
    loghole_zi.comment = "Log hole meta-data"
    
    zf.writestr(loghole_zi, cio.getvalue())

    # Add any comments.
    ct = time.localtime(time.time())
    lpc = 0
    for comment in comments:
        loghole_zi = zipfile.ZipInfo()
        loghole_zi.filename = "loghole-comment.%d.txt" % lpc
        loghole_zi.date_time = (ct[0], ct[1], ct[2], ct[3], ct[4], ct[5])
        loghole_zi.compress_type = zipfile.ZIP_DEFLATED
        loghole_zi.comment = "Loghole comment #%d" % lpc

        zf.writestr(loghole_zi, comment)

        lpc = lpc + 1
        pass
    
    if DEBUG:
        zf.printdir()
        pass
    
    zf.close()

    if delete_dir:
        open(CLEANFILE, 'w')
        os.chmod(CLEANFILE, 0664)
        pass

    if VERBOSITY == VERBOSITY_MACHINE:
        print archive_name
        pass
    elif VERBOSITY >= VERBOSITY_HUMAN:
        print "Created log hole archive: " + archive_name
        pass
    
    return retval

##
# Performs the "show" action, which shows a detailed listing of a log archive.
#
# @param args Action-specific command line arguments.
#
def do_show(args):
    retval = 0

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)
    
    for entry in os.listdir(logdir):
        if len(args) == 0 or entry.startswith(args[0]):
            lh, cp = open_loghole(entry)
            if lh:
                print "Archive: " + entry
                print ("  Project/Experiment:\t%s/%s" %
                       (cp.get("MAIN", "project"),
                        cp.get("MAIN", "experiment")))
                print "  Creator:\t\t%s" % cp.get("MAIN", "creator")
                print "  Created:\t\t%s" % cp.get("MAIN", "created")
                print "  Keep-until:\t\t%s" % cp.get("MAIN", "keep-until")
                print ("  Keep-atleast:\t\t%s days" %
                       cp.get("MAIN", "keep-atleast"))
                if "report.mail" in lh.namelist():
                    print "Report:"
                    print lh.read("report.mail")
                    pass
                for name in lh.namelist():
                    if re.match(r'loghole-comment.*\.txt', name):
                        before = 38 - (len(name) / 2)
                        after = 77 - before - len(name)
                        print "%s %s %s" % ("-" * before, name, "-" * after)
                        print lh.read(name)
                        pass
                    pass
                print "=" * 79
                try:
                    lh.printdir()
                    pass
                except IOError:
                    pass
                lh.close()
                print
                pass
            pass
        pass
    
    return retval

##
# Run rsync for a given host and list of files.
#
# @param host The host to sync against.
# @param base The local directory where the downloaded files should be placed.
# @param *args The list of directories to sync.
# @retval The exit status of the rsync command-line.
#
def rsync(host, base, dlpath, paths = ["/"], port = None, output = False,
          delay = 0, as_root = False):
    global RSYNC, HOME, DEBUG
    
    retval = 0
    for path in paths:
        fullpath = os.path.join("", base, path[1:], "")
        try:
            os.makedirs(fullpath)
            pass
        except OSError:
            pass
        cmd = [RSYNC,
               "-rtgoDlz",
               "-v", # XXX
               "--copy-unsafe-links",
               "--include-from=" + dlpath]
        if VERBOSITY > VERBOSITY_HUMAN:
            cmd.append("-v")
            pass
        ssh_args = ("ssh -o BatchMode=yes -o StrictHostKeyChecking=no "
                    + "-o UserKnownHostsFile="
                    + os.path.join(HOME, ".ssh", "emulab_known_hosts"))
        if IDENTITY:
            ssh_args += " -o Protocol=%d -i %s" % IDENTITY
            pass
        if port:
            ssh_args += " -p " + str(port)
            pass
        cmd.extend([("--rsh=" + ssh_args),
                    host + ":" + path,
                    fullpath])
        if DEBUG:
            print `cmd`
            retval = -1
            pass
        else:
            retval = os.fork()
            if retval != 0:
                # Parent
                pass
            else:
                try:
                    if delay > 0:
                        time.sleep(delay)
                        pass
                    os.close(0)
                    os.open("/dev/null", os.O_RDONLY)
                    if output:
                        os.close(1)
                        fd = os.open(os.path.join(base, ".rsync.out"),
                                     os.O_CREAT|os.O_TRUNC|os.O_WRONLY,
                                     0664)
                        os.dup2(fd, 2)
                        pass
                    try:
                        os.execve(RSYNC, cmd, os.environ)
                    except OSError, e:
                        sys.stderr.write(
                            "error: unable to exec '%s' - %s\n"
                            "error: args=%s\n"
                            % (RSYNC, e.strerror, `cmd`))
                        pass
                    os._exit(127)
                    pass
                except:
                    sys.exit(1)
                    pass
                pass
            pass
        pass
    
    return retval

def rmstar(host, port, delay, as_root, *args):
    global HOME, DEBUG

    retval = 0
    for path in args:
        cmd = ["/usr/bin/ssh",
               "-o", "BatchMode=yes",
               "-o", "StrictHostKeyChecking=no",
               "-o", ("UserKnownHostsFile=" +
                      os.path.join(HOME, ".ssh", "emulab_known_hosts"))]
        if port:
            cmd.extend([ "-p", str(port) ])
            pass
        cmd.extend([ host ])
        if as_root:
            cmd.extend(["sudo"])
        cmd.extend(["rm", "-rf", path ])
        if DEBUG:
            print `cmd`
            retval = -1
            pass
        else:
            retval = os.fork()
            if retval != 0:
                # Parent
                pass
            else:
                if delay > 0:
                    time.sleep(delay)
                    pass
                os.execve("/usr/bin/ssh", cmd, os.environ)
                os._exit(127)
                pass
            pass
        pass
    
    return retval

def print_status(msg):
    if not sys.stdout.isatty() or VERBOSITY < VERBOSITY_HUMAN:
        return
    
    sys.stdout.write(msg)
    sys.stdout.flush()
    
    return

def print_job_status(mode, hosts, jobs, hoststatus, hoststart):
    if not sys.stdout.isatty() or VERBOSITY < VERBOSITY_HUMAN:
        return
    
    lmsg = "nodes todo/doing/done %d/%d/%d "
    rmsg = mode + " time min/avg/max: %.2f/%.2f/%.2f secs"

    hosttimes = map(lambda x:
                    hoststatus.get(x, (time.time(),))[0] - hoststart[x],
                    hoststart.keys())
    
    if len(hosttimes) == 0:
        hosttimes = [0]
        avg = 0.0
        pass
    else:
        avg = sum(hosttimes) / len(hosttimes)
        pass
    lmsg = lmsg % (
        len(hosts) - len(hoststatus) - len(jobs),
        len(jobs),
        len(hoststatus))
    rmsg = rmsg % (
        min(hosttimes),
        avg,
        max(hosttimes))
    line_len = len(lmsg) + len(rmsg) + 2
    if line_len < 79:
        lmsg += " " * (79 - line_len)
        pass
    print_status(lmsg + rmsg + " "
                 + JOB_PROGRESS[JOB_PROGRESS_INDEX % len(JOB_PROGRESS)] + "\r")

    return

##
# Detect changes in the rsync log file sizes.
#
# @param jobs The hashtable of jobs
# @param logsize The hashtable of previous log file sizes.
# @param logdir The root directory for log files.
# @return True if the size of any of the log files has changed.
#
def making_progress(jobs, logsize, logdir):
    retval = False
    for pid in jobs:
        phost, vhost = jobs[pid]
        try:
            st = os.stat(os.path.join(logdir, vhost, ".rsync.out"))
            if st[stat.ST_SIZE] > logsize[pid]:
                retval = True
                logsize[pid] = st[stat.ST_SIZE]
                pass
            pass
        except OSError:
            pass
        pass
    
    return retval

##
# Trace preprocessing.
#
# @param traces Sequence of dictionaries describing the active link tracers.
#
def trace_pre(traces):
    at = address_tuple()
    at.eventtype = "SNAPSHOT"
    at.expt = "%s/%s" % (PID, EID)
    at.scheduler = 1

    tv = timeval()
    tv.tv_sec = int(time.time())
    
    notified = {}
    ec = EventClient(server="event-server",
                     keyfile=os.path.join("/proj", PID, "exp", EID,
                                          "tbdata", "eventkey"))

    for trace in traces:
        if trace["trace_type"] == "monitor":
            continue
        
        lvn = trace["linkvname"]
        if lvn not in notified:
            at.objname = "%s-tracemon" % (lvn,)
            en = ec.create_notification(at)
            ec.schedule(en, tv)
            notified[lvn] = 1
            pass
        
        pass

    if len(notified) > 0:
        time.sleep(1)
        pass
    
    return

##
# Trace post processing
#
# @param link2trace Dictionary containing the link names that map to a sequence
# of dictionaries containing individual trace information.
#
def trace_post(link2trace):
    lpc = 1
    for linkvname in link2trace.keys():
        print_status("linktrace post processing %d/%d  " %
                     (lpc, len(link2trace)))
        args = {}
        sql  = []
        os.chdir(linkvname)
        for filename in glob.glob("*.recv*"):
            base, ext = os.path.splitext(filename)
            if base.startswith("__") or ext == ".recv":
                continue
            al = args.get(ext, [])
            al.append(filename)
            args[ext] = al

            stuff = base.split(".");
            trace_db = link2trace[linkvname][stuff[0]]["trace_db"]
            if trace_db != "0":
                sql.append(linkvname + "/" + filename)
                pass
            pass
        for ext in args.keys():
            if ext == ".recv":
                continue
            dst = "__all.recv%s" % (ext,)
            print_status(".")
            if os.path.exists(MERGECAP):
                os.system(MERGECAP + " -w %s %s" % (dst, " ".join(args[ext])))
                pass
            print_status(".")
            if ext != ".0":
                if not os.path.exists(ext[1:]):
                    os.mkdir(ext[1:])
                    pass
                os.chdir(ext[1:])
                dst = os.path.join(os.path.pardir, dst)
                pass
            if os.path.exists(TCPTRACE):
                os.system(TCPTRACE + " -y -G %s > .tcptrace.out" % (dst,))
                pass
            if ext != ".0":
                os.chdir(os.path.pardir)
                pass
            pass
        print_status("\r")
        os.chdir(os.path.pardir)
        lpc += 1
        pass

    if len(link2trace.keys()):
        print_status("\n")
        pass

    # Now do the DB enters.
    if len(sql) != 0:
        SNORTCONF  = ".snort.conf"
        SNORTOUT   = ".snort.out"
        USERRULES  = "snort.rules"
        
        print_status("Entering trace data into mysql DB %s" % DPDBNAME)

        # snort needs a config file to do anything useful
        os.system("/bin/rm -f %s %s" % (SNORTCONF, SNORTOUT))
        
        fp = open(SNORTCONF, 'w')
        os.chmod(SNORTCONF, 0600)
        fp.write("output database: log, mysql, dbname=%s password=%s\n" %
                 (DPDBNAME, COLLAB_PW))

        # Allow user to override default rules.
        if os.path.exists(USERRULES):
            fp.write("include ./%s" % (USERRULES,))
            pass
        else:
            fp.write("log ip any any -> any any\n")
            fp.write("log icmp any any -> any any\n")
            pass
        fp.close()
        
        for filename in sql:
            print_status(".")
            os.system("snort -l ./ -c ./%s -r %s > %s 2>&1" %
                      (SNORTCONF, filename, SNORTOUT))
            print_status(".")
            pass
        print_status("\n")
        pass
    
    return

##
# Performs the "sync" action, which synchronizes the logholes for a group of
# nodes.
#
# XXX This method is in dire need of a rewrite.
#
# @param args Action-specific command line arguments.
#
def do_sync(args, mode="sync", must_be_active=1, as_root=False):
    from emulabclient import RESPONSE_SUCCESS
    global OSIDS, SERVER, DOT_LOGHOLES, JOB_PROGRESS_INDEX
    global DPDBNAME, COLLAB_PW
    
    retval = 0

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")

    standard_logholes = True
    snapshot_traces = False
    post_process = True
    extra_logholes = []

    try:
        opts, node_list = getopt.getopt(args, "nl:r:Ps", [
            "no-standard", "local=", "remote=",
            ])
        for opt, val in opts:
            if opt in ("-n", "--no-standard"):
                standard_logholes = False
                pass
            elif opt in ("-P", "--no-post"):
                post_process = False
                pass
            elif opt in ("-l", "--local"):
                logdir = os.path.abspath(val)
                if not os.path.isdir(logdir):
                    raise getopt.error(
                        'error: local directory does not exist - '
                        + logdir)
                pass
            elif opt in ("-r", "--remote"):
                extra_logholes.append(val)
                pass
            elif opt in ("-s", "--snapshot"):
                snapshot_traces = True
                pass
            pass
        pass
    except getopt.error, e:
        print e.args[0]
        sync_usage()
        return 2

    if not standard_logholes:
        DOT_LOGHOLES = ""
        pass
    
    for path in extra_logholes:
        DOT_LOGHOLES += loghole_include(path)
        pass

    DOT_LOGHOLES += "- *\n"
    
    init_server()
    
    state_method = getattr(SERVER, "experiment.state")
    
    os.chdir(logdir)
    
    if standard_logholes and os.path.exists(CLEANFILE):
        do_clean(["-f", "-e"])
        os.unlink(CLEANFILE)
        pass

    dlhandle = tempfile.NamedTemporaryFile(prefix=".logholes")
    dlhandle.write(DOT_LOGHOLES)
    dlhandle.flush()

    state = state_method(PACKAGE_VERSION, { "proj" : PID, "exp" : EID })
    if state["code"] != RESPONSE_SUCCESS:
        sys.stderr.write("error: " + state["output"] + "\n")
        retval = 1
        pass
    elif (state["value"] != "active" and
          state["value"] != "activating" and
          state["value"] != "modify_reswap"):
        if must_be_active:
            sys.stderr.write("error: %s/%s is not an active experiment!\n" %
                             (PID, EID))
            retval = 2
            pass
        else:
            retval = 0
            pass
        pass
    else:
        info_method = getattr(SERVER, "experiment.info")
        osinfo_method = getattr(SERVER, "osid.info")
        ssh_method = getattr(SERVER, "node.sshdescription")
        collabpw_method = getattr(SERVER, "user.collabpassword")
        dpinfo_method = getattr(SERVER, "experiment.dpinfo")

        # Get any bits of information we need from the RPC server.
        physical = info_method(PACKAGE_VERSION, {
            "proj" : PID,
            "exp" : EID,
            "aspect" : "mapping",
            })

        traces = info_method(PACKAGE_VERSION, {
            "proj" : PID,
            "exp" : EID,
            "aspect" : "traces",
            })

        ssh_data = ssh_method(PACKAGE_VERSION, {
            "proj" : PID,
            "exp" : EID
            })

        collab_data = collabpw_method(PACKAGE_VERSION, { })
        dpinfo_data = dpinfo_method(PACKAGE_VERSION, { "proj" : PID,
                                                       "exp" : EID, })
        
        if ((physical["code"] != RESPONSE_SUCCESS) or
            (traces["code"] != RESPONSE_SUCCESS) or
            (collab_data["code"] != RESPONSE_SUCCESS) or
            (dpinfo_data["code"] != RESPONSE_SUCCESS) or
            (ssh_data["code"] != RESPONSE_SUCCESS)):
            sys.stderr.write("error: xmlrpc failed - %s\n" %
                             (physical["output"],))
            retval = 1
            pass
        else:
            physical = physical["value"]
            traces = traces["value"]
            ssh_data = ssh_data["value"]
            COLLAB_PW = collab_data["value"]
            DPDBNAME  = dpinfo_data["value"]["dbname"]

            if snapshot_traces:
                trace_pre(traces)
                pass

            # Separate the nodes into those that are up
            hosts = [(x["node"], x["name"]) for x in physical.values()
                     if ((x["erole"] == "virthost" or
                          x["erole"] == "node" or
                          x["erole"] == "delaynode") and
                         (x["status"] == "up" and x["eventstatus"] == "ISUP"))]

            # ... or down.
            downhosts = [(x["node"], x["name"]) for x in physical.values()
                     if ((x["erole"] == "virthost" or
                          x["erole"] == "node" or
                          x["erole"] == "delaynode") and
                         (x["status"] != "up" or x["eventstatus"] != "ISUP"))]

            phosts = sets.Set([x[0] for x in hosts])
            vhosts = sets.Set([x[1] for x in hosts])
            dphosts = sets.Set([x[0] for x in downhosts])
            dvhosts = sets.Set([x[1] for x in downhosts])
            if len(node_list) == 0:
                node_list = vhosts
                
                for host in downhosts:
                    sys.stderr.write("warning: '%s' is down, its logs will "
                                     "not be retrieved\n" % (host[1],))
                    pass
                pass

            known_nodes = sets.Set(node_list) & (phosts | vhosts)
            unknown_nodes = known_nodes ^ sets.Set(node_list)

            jobs = {}
            hoststatus = {}
            hoststart = {}
            hosttries = {}
            logsize = {}
            while len(hosts) > 0 or len(jobs) > 0:
                if len(hosts) > 0:
                    ht = hosts.pop()
                    phost, vhost = ht
                    pass
                else:
                    phost = ""
                    vhost = ""
                    pass
                if (vhost in node_list) or (phost in node_list):
                    # Start a job for the next host.
                    osid = physical[vhost]["osid"]
                    if osid not in OSIDS:
                        oi = osinfo_method(PACKAGE_VERSION, {
                            "osid" : osid })
                        if oi["code"] == RESPONSE_SUCCESS:
                            OSIDS[osid] = oi["value"]
                            pass
                        else:
                            OSIDS[osid] = None
                            pass
                        pass

                    # Make sure we can talk to it.
                    if not OSIDS[osid]:
                        sys.stderr.write("warning: unknown OSID %s for %s\n" %
                                         (physical[vhost]["osid"], vhost))
                        continue
                    else:
                        vos = OSIDS[physical[vhost]["osid"]]
                        if "ssh" not in vos["osfeatures"]:
                            if VERBOSITY > VERBOSITY_HUMAN:
                                sys.stderr.write("warning: %s OS, %s, does "
                                                 "not support ssh, skipping\n"
                                                 % (vhost, vos["osname"]))
                                pass
                            continue
                        pass

                    # Start the job.
                    if ht in hosttries:
                        delay = 3
                        pass
                    else:
                        delay = 0
                        pass
                    if mode == "sync":
                        pid = rsync(phost, os.path.join(logdir, vhost),
                                    dlhandle.name,
                                    port = ssh_data[phost].get("port", None),
                                    output = True,
                                    delay = delay,
                                    as_root = as_root)
                        pass
                    elif mode == "clean":
                        pid = rmstar(phost,
                                     ssh_data[phost].get("port", None),
                                     delay,
                                     as_root,
                                     "/local/logs/*")
                        pass
                    else:
                        assert 0
                    
                    jobs[pid] = ht
                    logsize[pid] = 0
                    hoststart[ht] = time.time()

                    if ht not in hosttries:
                        hosttries[ht] = 0
                        pass
                    hosttries[ht] += 1
                    pass
                
                try:
                    # Wait for the children and update the status.
                    while len(jobs) == PARALLELIZATION or len(hosts) == 0:
                        print_job_status(mode, node_list, jobs,
                                         hoststatus, hoststart)
                        # Check for any changes in the log files.
                        if (mode == "sync" and
                            making_progress(jobs, logsize, logdir)):
                            JOB_PROGRESS_INDEX += 1
                            pass
                        # Check for processes that have ended.
                        pid, sts = os.waitpid(0, os.WNOHANG)
                        if pid in jobs:
                            # Retry on some errors 
                            if (mode == "clean" and sts == 255 and
                                hosttries[jobs[pid]] <= JOB_TRIES):
                                hosts.append(jobs[pid])
                                pass
                            elif (mode == "sync" and
                                  sts not in NONRETRIABLE_RSYNC_STATUS and
                                  hosttries[jobs[pid]] <= JOB_TRIES):
                                hosts.append(jobs[pid])
                                pass
                            else:
                                hoststatus[jobs[pid]] = (time.time(), sts)
                                pass
                            del jobs[pid]
                            pass

                        if len(jobs) == PARALLELIZATION or len(hosts) == 0:
                            time.sleep(0.5)
                            pass
                        pass
                    pass
                except OSError:
                    pass
                pass

            sys.stdout.write("\n")

            # Clue the user in if there were nodes that they specified nodes
            # we don't know about.
            if len(unknown_nodes) > 0:
                for vhost in unknown_nodes:
                    if vhost in dvhosts or vhost in dphosts:
                        sys.stderr.write("error: node '%s' is down\n" %
                                         (vhost,))
                        pass
                    else:
                        sys.stderr.write("error: unknown node - %s\n" %
                                         (vhost,))
                        pass
                    pass
                retval = 2
                pass

            # Check the status of the jobs and dump logs for any that failed.
            for ht, (etime, sts) in hoststatus.items():
                phost, vhost = ht
                if VERBOSITY > VERBOSITY_HUMAN:
                    print "info: %s - %.2f" % (vhost, etime - hoststart[ht])
                    pass
                if mode == "clean":
                    continue
                if sts not in ACCEPTABLE_RSYNC_STATUS:
                    sys.stderr.write("error: failed to %s node '%s'\n" %
                                     (mode, vhost))
                    eout = open(os.path.join(logdir, vhost, ".rsync.out"),
                                "r").read()
                    sys.stderr.write(
                        vhost + ": " + re.sub(r'\n',
                                              "\n" + vhost + ": ",
                                              eout[:-1]) + eout[-1])
                    retval = 3
                    pass
                else:
                    # Post process the delay-agent log files, if there are any.
                    vdir = os.path.join(vhost, "var", "emulab", "logs")
                    if (os.path.exists(vdir) and
                        os.path.exists("delayagent.debug")):
                        os.chdir(vdir)
                        os.system("%s %s" %
                                  (DELAYLOG2XPLOT, "delayagent.debug"))
                        pass
                    os.chdir(logdir)
                    pass
                pass

            # Add symbolic links to the trace files.
            link2trace = {}
            for trace in traces:
                if trace["trace_type"] == "monitor":
                    continue

                tl = link2trace.get(trace["linkvname"], {})
                tl[trace["vnode"]] = trace
                link2trace[trace["linkvname"]] = tl
                
                fullpath = os.path.join(logdir, trace["linkvname"])
                try:
                    os.makedirs(fullpath)
                    pass
                except OSError:
                    pass
                for fmt in LINK_DUMP_FMT:
                    src = os.path.join(trace["delayvname"],
                                       "local",
                                       "logs",
                                       fmt % (trace["vnode"],
                                              trace["linkvname"]))
                    for filename in glob.glob(src + "*"):
                        dst = os.path.split(filename)
                        dst = dst[len(dst) - 1].split('.')
                        comp = [trace["vnode"]]
                        comp.extend(dst[1:])
                        dst = ".".join(comp)
                        dst = os.path.join(fullpath, dst)
                        try:
                            os.unlink(dst)
                            pass
                        except OSError:
                            pass
                        os.symlink(os.path.join(os.pardir, filename), dst)
                        pass
                    pass

                # Add some links to the xplot log files created by
                # delaylog2xplot
                src = os.path.join(trace["delayvname"],
                                   "var", "emulab", "logs",
                                   "%s-%s-*.xpl" % (trace["linkvname"],
                                                    trace["vnode"]))
                for filename in glob.glob(src):
                    aspect = filename.split("-")[2].split(".")[0]
                    dst = "%s-%s.xpl" % (trace["vnode"], aspect)
                    dst = os.path.join(fullpath, dst)
                    try:
                        os.unlink(dst)
                        pass
                    except OSError:
                        pass
                    os.symlink(os.path.join(os.pardir, filename), dst)
                    pass
                pass

            if post_process:
                trace_post(link2trace)
                pass
            
            pass
        pass
    
    return retval

##
# Performs the "archive" action, which displays a brief summary of the log
# files in the experiment.
#
# @param args Action-specific command line arguments.
#
def do_list(args):
    retval = 0

    keep_atmost = 100
    keep_size = 3.0

    list_gc = ""
    
    try:
        opts, args = getopt.getopt(args, "O1!Xom:s:", [
            "keep-atmost=", "keep-size="
            ])
        for opt, val in opts:
            if opt in ("-O", "-1", "-!", "-X"):
                list_gc = list_gc + opt[1]
                pass
            elif opt in ("-o"):
                list_gc = list_gc + ' '
                pass
            elif opt in ("-m", "--keep-atmost"):
                try:
                    keep_atmost = int(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting integer for keep atmost value, '
                        'got - ' + val)
                pass
            elif opt in ("-s", "--keep-size"):
                try:
                    keep_size = float(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting float for keep size value, '
                        'got - ' + val)
                pass
            pass
        
        if len(args) > 0:
            raise getopt.error(
                'error: too many arguments passed to "list" action')
        pass
    except getopt.error, e:
        print e.args[0]
        list_usage()
        return 2

    if len(list_gc) == 0:
        list_gc = "O1!X "
        pass
    
    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    sa = sort_archives(keep_atmost, keep_size)

    exp_logholes = []
    for entry in os.listdir(logdir):
        lh, cp = open_loghole(entry)
        if lh:
            created = time.mktime(time.strptime(cp.get("MAIN", "created")))
            exp_logholes.append((entry, cp, created))
            pass
        pass

    current_time = time.time()
    tomorrow_time = current_time + (60 * 60 * 24)
    
    if len(exp_logholes) > 0:
        max_entry_len = max([len(x[0]) for x in exp_logholes])

        if VERBOSITY >= VERBOSITY_HUMAN:
            print "GC  Name%sDate" % (" " * (max_entry_len - 4 + 5))
            print
            pass
        
        exp_logholes.sort(lambda x, y: cmp(y[2], x[2]))
        for entry, cp, created in exp_logholes:
            keep_until = cp.get("MAIN", "keep-until")
            keep_atleast = (cp.getint("MAIN", "keep-atleast") * 60 * 60 * 24)
            created = time.mktime(time.strptime(cp.get("MAIN", "created")))
            created_str = time.strftime("%m/%d", time.localtime(created))
            if keep_until == "i-delete":
                ball = "O"
                pass
            elif entry in sa["del"]:
                ball = "X"
                pass
            elif entry in sa["soon"]:
                if current_time > keep_atleast:
                    ball = "!"
                    pass
                elif (tomorrow_time - created) > keep_atleast:
                    ball = "1"
                    pass
                else:
                    ball = " "
                    pass
                pass

            if ball in list_gc:
                if VERBOSITY == VERBOSITY_MACHINE:
                    print entry
                    pass
                elif VERBOSITY >= VERBOSITY_HUMAN:
                    gap = " " * (max_entry_len - len(entry) + 5)
                    print "[%s] %s%s%s" % (ball, entry, gap, created_str)
                    pass
                pass
            pass
        if len(exp_logholes) == 0:
            if VERBOSITY >= VERBOSITY_HUMAN:
                print "  <No log holes found in %s/%s>" % (PID, EID)
                pass
            pass

        if VERBOSITY == VERBOSITY_MACHINE:
            pass
        elif VERBOSITY >= VERBOSITY_HUMAN:
            print
            print "%d bytes are in use." % (sa["inuse-size"],)
            print ("%d bytes will be reclaimed at the next gc." %
                   (sa["reclaimed-size"],))
            print
            print "GC Legend:"
            print "  O - Archive will not be deleted automatically."
            print "  1 - Archive is one day away from its keep-until date."
            print "  ! - Archive is past its keep-until date and will be"
            print "      deleted when space is needed."
            print "  X - Archive is ready to be garbage collected."
            pass
        pass
    
    return retval

##
# Performs the "change" action, which involves updating the metadata for an
# existing archive.
#
# @param args Action-specific command line arguments.
#
def do_change(args):
    retval = 0

    keep_until = None
    keep_atleast = None
    comments = []

    # Parse action-specific options and arguments.
    try:
        opts, args = getopt.getopt(args, "k:a:c:", [
            "keep-until=", "keep-atleast=", "comment=", ])
        for opt, val in opts:
            if opt in ("-k", "--keep-until"):
                if val == "i-delete" or val == "space-is-needed":
                    keep_until = val
                    pass
                else:
                    raise getopt.error(
                        'error: expecting "i-delete" or "space-is-needed" for '
                        'keep until value, got - ' + val)
                pass
            elif opt in ("-a", "--keep-atleast"):
                try:
                    keep_atleast = int(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting integer for keep atleast value, '
                        'got - ' + val)
                pass
            elif opt in ("-c", "--comment"):
                if val == "-":
                    comments.append(sys.stdin.read())
                    pass
                else:
                    comments.append(val)
                    pass
                pass
            pass
        
        if len(args) == 0:
            raise getopt.error(
                'error: not enough arguments for "change" action.')
        pass
    except getopt.error, e:
        print e.args[0]
        change_usage()
        return 2

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    for archive_name in args:
        if os.path.exists(archive_name):
            full_archive_name = archive_name
            pass
        else:
            full_archive_name = os.path.join(logdir, archive_name)
            pass
        if (not archive_name.endswith(".zip") and
            not os.path.exists(full_archive_name)):
            for ext in EXTENSIONS:
                tmp_name = full_archive_name + ext
                if os.path.exists(tmp_name):
                    full_archive_name = tmp_name
                    break
                pass
            if full_archive_name != tmp_name:
                print "error: bad archive name - " + archive_name
                continue
            pass

        lh, cp = open_loghole(full_archive_name, mode='a')

        if not lh:
            sys.stderr.write("error: %s is not a loghole archive\n" %
                             (archive_name,))
            continue

        try:
            lh.infolist().remove(lh.getinfo("loghole.cfg"))
            pass
        except:
            sys.stderr.write("warning: loghole.cfg is missing from %s\n" %
                             (archive_name,))
            pass

        # Change the meta-data.
        if keep_until:
            cp.set("MAIN", "keep-until", keep_until)
            pass
        if keep_atleast:
            cp.set("MAIN", "keep-atleast", keep_atleast)
            pass

        if keep_until or keep_atleast:
            cio = cStringIO.StringIO()
            cp.write(cio)
            
            loghole_zi = zipfile.ZipInfo()
            loghole_zi.filename = "loghole.cfg"
            ct = time.localtime(time.time())
            loghole_zi.date_time = (ct[0], ct[1], ct[2], ct[3], ct[4], ct[5])
            loghole_zi.compress_type = zipfile.ZIP_STORED
            loghole_zi.comment = "Log hole meta-data"
            
            lh.writestr(loghole_zi, cio.getvalue())
            pass
        
        # Add any comments.
        ct = time.localtime(time.time())
        for comment in comments:
            loghole_zi = zipfile.ZipInfo()
            loghole_zi.filename = uniquish_name(
                "loghole-comment",
                "txt",
                [x.filename for x in lh.infolist()])
            loghole_zi.date_time = (ct[0], ct[1], ct[2], ct[3], ct[4], ct[5])
            loghole_zi.compress_type = zipfile.ZIP_DEFLATED
            loghole_zi.comment = "Loghole comment"
            
            lh.writestr(loghole_zi, comment)
            pass
    
        if DEBUG:
            try:
                lh.printdir()
                pass
            except IOError:
                pass
            pass
    
        lh.close()
        
        if VERBOSITY >= VERBOSITY_HUMAN:
            print "Changed log hole archive: " + archive_name
            pass
        pass
    
    return retval

def validate_visitor(arg, dirname, names):
    for name in names:
        fname = os.path.join(dirname, name)
        
        mo = re.match(r'[^\.]+\.status\.([0-9]+)', name)
        if mo:
            try:
                token = int(mo.group(1))
                
                status = {}
                for line in open(os.path.join(dirname, name)):
                    (key, value) = line.split("=")
                    status[key] = value
                    pass
                
                if token != int(status.get("TOKEN", "-1")):
                    print "warning: ignoring %s" % name
                    continue
                
                base, ext = os.path.splitext(name)
                base, ext = os.path.splitext(base)
                
                st = os.stat(os.path.join(dirname, base + ".out." + `token`))
                if st[stat.ST_SIZE] != long(status.get("OUTSIZE", "-1")):
                    print "warning: '%s' size doesn't match status" % fname
                    arg["retval"] = 1
                    pass
                if st[stat.ST_MTIME] != long(status.get("OUTMTIME", "-1")):
                    print "warning: '%s' mtime doesn't match status" % fname
                    arg["retval"] = 1
                    pass
                
                st = os.stat(os.path.join(dirname, base + ".err." + `token`))
                if st[stat.ST_SIZE] != long(status.get("ERRSIZE", "-1")):
                    print "warning: '%s' size doesn't match status" % fname
                    arg["retval"] = 1
                    pass
                if st[stat.ST_MTIME] != long(status.get("ERRMTIME", "-1")):
                    print "warning: '%s' mtime doesn't match status" % fname
                    arg["retval"] = 1
                    pass
                pass
            except OSError:
                pass
            pass

        if not os.path.exists(fname):
            print "warning: '%s' references nonexistent file!" % fname
            pass
        pass
    
    return

##
# Performs the "validate" action, which XXX
#
# @param args Action-specific command line arguments.
#
def do_validate(args):
    retval = 0

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    rc = { "retval" : 0 }
    os.path.walk(os.path.curdir, validate_visitor, rc)
    retval = rc["retval"]

    return retval

##
# Performs the "clean" action, which deletes logs from the experiment
# directory.
#
# @param args Action-specific command line arguments.
#
def do_clean(args):
    retval = 0

    force = 0
    do_nodes = 1
    do_experiment = 1
    confirm_msg = "Are you sure you want to remove ALL log files? [y/N] "
    as_root = False

    # Parse action-specific options and arguments.
    try:
        opts, args = getopt.getopt(args, "fner", [
            "force", "nodes", "experiment", "root", ])
        for opt, val in opts:
            if opt in ("-f", "--force"):
                force = 1
                pass
            elif opt in ("-n", "--nodes"):
                do_nodes = 1
                do_experiment = 0
                confirm_msg = ("Are you sure you want to remove log files on "
                               "the nodes? [y/N] ")
                pass
            elif opt in ("-e", "--experiment"):
                do_nodes = 0
                do_experiment = 1
                confirm_msg = ("Are you sure you want to remove log files "
                               "from the experiment log directory? [y/N] ")
                pass
            elif opt in ("-r", "--root"):
                as_root = True
            pass
        pass
    except getopt.error, e:
        print e.args[0]
        clean_usage()
        return 2

    if not force:
        line = raw_input(confirm_msg)
        if not (line.startswith("y") or line.startswith("Y")):
            return 0
        pass
    
    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    if do_experiment:
        for entry in os.listdir(logdir):
            entry = os.path.join(logdir, entry)
            if os.path.isdir(entry):
                for root, dirs, files in os.walk(entry, topdown=False):
                    for name in files:
                        os.remove(os.path.join(root, name))
                        pass
                    for name in dirs:
                        os.rmdir(os.path.join(root, name))
                        pass
                    pass
                os.rmdir(entry)
                pass
            pass
        pass
    
    if do_nodes:
        do_sync(args, mode="clean", must_be_active=0, as_root = as_root)
        pass

    return retval

##
# Performs the "gc" action, which garbage collects old/extra log files.
#
# @param args Action-specific command line arguments.
#
def do_gc(args):
    retval = 0

    keep_atmost = 100
    keep_size = 3.0
    dry_run = False
    
    try:
        opts, args = getopt.getopt(args, "nm:s:", [
            "dry-run", "keep-atmost=", "keep-size="
            ])
        for opt, val in opts:
            if opt in ("-m", "--keep-atmost"):
                try:
                    keep_atmost = int(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting integer for keep atmost value, '
                        'got - ' + val)
                pass
            elif opt in ("-s", "--keep-size"):
                try:
                    keep_size = float(val)
                    pass
                except:
                    raise getopt.error(
                        'error: expecting float for keep size value, '
                        'got - ' + val)
                pass
            elif opt in ("-n", "--dry-run"):
                dry_run = True
                pass
            pass
        
        if len(args) > 0:
            raise getopt.error(
                'error: too many arguments passed to "gc" action')
        pass
    except getopt.error, e:
        print e.args[0]
        gc_usage()
        return 2

    logdir = os.path.join(EXPDIR_FMT % { "PID" : PID, "EID" : EID }, "logs")
    os.chdir(logdir)

    sa = sort_archives(keep_atmost, keep_size)

    if not dry_run:
        for file in sa["del"]:
            os.remove(file)
            pass
        pass

    if VERBOSITY == VERBOSITY_MACHINE:
        print "%s %s" % (str(reclaimed_size), str(inuse_size))
        pass
    elif VERBOSITY >= VERBOSITY_HUMAN:
        print ("Reclaimed %d bytes from %s/%s." %
               (sa["reclaimed-size"], PID, EID))
        print "%d bytes are still in %s/%s." % (sa["inuse-size"], PID, EID)
        pass
    
    return retval

def notimplemented():
    raise "loghole: not implemented yet"

ACTIONS = {
    "get" : (do_sync, sync_usage),
    "sync" : (do_sync, sync_usage),
    "validate" : (do_validate, validate_usage),
    "archive" : (do_archive, archive_usage),
    "list" : (do_list, list_usage),
    "show" : (do_show, show_usage),
    "change" : (do_change, change_usage),
    "clean" : (do_clean, clean_usage),
    "gc" : (do_gc, gc_usage),
    }

exp_list = []

try:
    action = None
    all_experiments = False
    
    opts, req_args = getopt.getopt(sys.argv[1:],
                                   "hVdqve:aP:s:",
                                   [ "help",
                                     "version",
                                     "debug",
                                     "quiet",
                                     "verbose",
                                     "experiment=",
                                     "all",
                                     "port=",
                                     "server=", ])
    if len(req_args) > 0:
        action = req_args[0].lower()
        pass
    
    for opt, val in opts:
        if opt in ("-h", "--help"):
            if action in ACTIONS:
                ACTIONS[action][1]()
                pass
            else:
                usage()
                pass
            sys.exit()
            pass
        elif opt in ("-V", "--version"):
            print PACKAGE_VERSION
            sys.exit()
            pass
        elif opt in ("-d", "--debug"):
            DEBUG = DEBUG + 1
            pass
        elif opt in ("-q", "--quiet"):
            VERBOSITY = VERBOSITY - 1
            pass
        elif opt in ("-v", "--verbose"):
            VERBOSITY = VERBOSITY + 1
            pass
        elif opt in ("-e", "--experiment"):
            pair = val.split('/')
            if len(pair) == 2 and len(pair[0]) > 0 and len(pair[1]) > 0:
                exp_list.append(pair)
                pass
            else:
                raise getopt.error('error: -e argument is of the form pid/eid')
            pass
        elif opt in ("-a", "--all"):
            all_experiments = True
            pass
        elif opt in ("-P", "--port"):
            XMLRPC_PORT = int(val)
            pass
        elif opt in ("-s", "--server"):
            XMLRPC_SERVER = val
            pass
        else:
            assert False
            pass
        pass

    if len(req_args) < 1:
        raise getopt.error('error: too few arguments')

    action = req_args[0].lower()
    if action not in ACTIONS:
        raise getopt.error('error: unknown action - ' + req_args[0] + '\n'
                           'error: action must be one of: '
                           + str(ACTIONS.keys()))

    if all_experiments:
        exp_list.extend(get_explist())
        pass
    
    if len(exp_list) == 0:
        exp_list.append(infer_pid_eid(sys.argv[0], os.getcwd()))
        if not exp_list[0][0]:
            raise getopt.error(
                'error: -e argument was not given and the current directory\n'
                'error: is not in an experiment directory.')
        pass
    pass
except getopt.error, e:
    print e.args[0]
    usage()
    sys.exit(2)
    pass

try:
    for PID, EID in exp_list:
        if DEBUG:
            sys.stderr.write("loghole: pid/eid - " + PID + "/" + EID + "\n")
            pass
        
        rc = ACTIONS[action][0](req_args[1:])
        if rc != 0:
            sys.exit(rc)
            pass
        pass
    pass
except KeyboardInterrupt:
    sys.exit(1)
    pass
