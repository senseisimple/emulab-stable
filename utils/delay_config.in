#!/usr/bin/perl -w

#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2003 University of Utah and the Flux Group.
# All rights reserved.
#

use English;
use Getopt::Std;

#
# Change delay params for a link.
#
sub usage()
{
    print(STDERR
	  "Usage: delay_config [-m] [-d] [-s vnode] <pid> <eid> <link>".
	  " PARAM=VALUE ...\n".
	  "Required: pid, eid, link, and at least one parameter to change!\n".
	  "  pid = Project ID\n".
	  "  eid = Experiment ID\n".
	  " link = link name from ns file, ie. 'link1' in\n".
	  "        'set link1 [\$ns duplex-link \$A \$B 10Kb 0ms DropTail]'\n".
	  "Options:\n".
	  "   -d = turn on debugging\n".
	  "   -s = Select the source of the link to determine which pipe\n".
	  "        This is easier than using the -p option!\n".
	  "   -m = Modify the base experiment in addition to current state.\n".
	  "Parameters:\n".
	  " BANDWIDTH=NNN    - N=bandwidth (10-100000 Kbits per second)\n",
	  " PLR=NNN          - N=lossrate (0 <= plr < 1)\n".
	  " DELAY=NNN        - N=delay (one-way delay in milliseconds > 0)\n".
	  " LIMIT=NNN        - The queue size in bytes or packets\n".
	  " QUEUE-IN-BYTES=N - 0 means in packets, 1 means in bytes\n".
	  "RED/GRED Options: (only if link was specified as RED/GRED)\n".
	  " MAXTHRESH=NNN    - Maximum threshold for the average queue size\n".
	  " THRESH=NNN       - Maximum threshold for the average queue size\n".
	  " LINTERM=NNN      - Packet dropping probability\n".
	  " Q_WEIGHT=NNN     - For calculating the average queue size\n");
    # Web interface cares about this return value!
    exit(2);
}
my  $optlist = "dms:";

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TEVC        = "$TB/bin/tevc";
my $debug	= 0;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use libtestbed;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
if (@ARGV < 4) {
    usage();
}
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}

my $pid    = shift(@ARGV);
my $eid    = shift(@ARGV);
my $link   = shift(@ARGV);
my $modify = 0;
my $srcvnode;
my %config;
my $pipeno;
my $pipe;

if (defined($options{"m"})) {
    $modify = 1;
}
if (defined($options{"s"})) {
    $srcvnode = $options{"s"};
}

#
# Permission check.
#
if ($UID && !TBAdmin($UID) &&
    ! TBExptAccessCheck($UID, $pid, $eid, TB_EXPT_MODIFY)) {
    die("*** $0:\n".
	"    You do not have permission to modify the delay parameters!\n");
}

#
# No transitional experiments.
#
my $query_result =
    DBQueryFatal("select state,expt_locked from experiments ".
		 "where eid='$eid' and pid='$pid'");

if (! $query_result->numrows) {
    die("*** $0:\n".
	"    No such experiment $pid/$eid exists!\n");
}
my ($estate,$expt_locked) = $query_result->fetchrow_array();

if (defined($expt_locked)) {
    die("*** $0:\n".
	"    Experiment $pid/$eid went into transition at $expt_locked.\n".
	"    You will be notified via email when experiment transition ".
	"    is complete and you can alter its delay configuration.\n");
}

#
# Parse options, which will modify the existing configuration below.
#
while (@ARGV) {
    my $opt = shift(@ARGV);

    #
    # The parameter names correspond roughly to the names that the user
    # uses in the NS file. The $config{} keys correspond to the names of
    # the slots in the DB table. Well, roughly correspond since the delays
    # table uses q0_ and q1_, but we handle that below.
    #
    # XXX If you add to this list, be sure to add to agentmap hash below.
    #
    SWITCH: for ($opt) {
	/^BANDWIDTH=([0-9]*)$/i && do {
	    if ($1 > 100000 || $1 < 10) {
		usage();
	    }
	    $config{"bandwidth"} = $1;
	    last SWITCH;
	};
	/^DELAY=([0-9]*)$/i && do {
	    if ($1 < 0) {
		usage();
	    }
	    $config{"delay"} = $1;
	    last SWITCH;
	};
	/^PLR=([0-9\.]*)$/i && do {
	    if ($1 < 0 || $1 > 1) {
		usage();
	    }
	    $config{"lossrate"} = $1;
	    last SWITCH;
	};
	/^LIMIT=([0-9]*)$/i && do {
	    $config{"q_limit"} = $1;
	    last SWITCH;
	};
	/^QUEUE-IN-BYTES=(\d)$/i && do {
	    if ($1 != 0 && $1 != 1) {
		usage();
	    }
	    $config{"q_qinbytes"} = $1;
	    last SWITCH;
	};
	/^MAXTHRESH=(\d*)$/i && do {
	    $config{"q_maxthresh"} = $1;
	    last SWITCH;
	};
	/^THRESH=(\d*)$/i && do {
	    $config{"q_minthresh"} = $1;
	    last SWITCH;
	};
	/^LINTERM=([0-9\.]*)$/i && do {
	    $config{"q_linterm"} = $1;
	    last SWITCH;
	};
	/^Q_WEIGHT=([0-9\.]*)$/i && do {
	    $config{"q_weight"} = $1;
	    last SWITCH;
	};
	print "Invalid config option: $opt\n";
	usage();
    }
}

#
# More sanity checks.
#
foreach my $key (keys(%config)) {
    my $val = $config{$key};

    if ($debug) {
	print "$key=$val\n";
    }
}

#
# These map the names I'm using in the config hash (which correspond
# to the DB slot names) into the event parameter names to send over to the
# delay agent.
#
my %agentmap =
    ( bandwidth		=> BANDWIDTH,
      delay             => DELAY,
      lossrate		=> PLR,
      q_limit		=> LIMIT,
      q_qinbytes	=> "QUEUE-IN-BYTES",
      q_maxthresh	=> MAXTHRESH,
      q_minthresh	=> THRESH,
      q_linterm		=> LINTERM,
      q_weight		=> Q_WEIGHT
    );

#
# Link or Lan!
# 
$query_result =
    DBQueryFatal("select member from virt_lans ".
		 "where pid='$pid' and eid='$eid' and vname='$link'");
if (!$query_result->numrows) {
    die("*** $0:\n".
	"    $link is not a link in $pid/$eid!\n");
}
my $islink = ($query_result->numrows == 2 ? 1 : 0);

#
# If experiment is not active, all we can do is change virt_lans.
#
if ($estate ne EXPTSTATE_ACTIVE) {
    if ($modify) {
	ChangeVirtLans();
    }
    else {
	print "Experiment $pid/$eid is not active. If you want to change\n".
	    "the base experiment configuration, please use the -m option!\n";
    }
    exit(0);
}

#
# Check to see if linkdelays or normal delay nodes. This is a gross
# complication of this entire script!
#
if (ChangeDelayConfig() < 0 &&
    ChangeLinkDelayConfig() < 0) {
    die("*** $0:\n".
	"    $link is not a traffic shaped link in $pid/$eid!\n");
}
if ($modify) {
    ChangeVirtLans();
}

#
# Inject an event. 
#
my $inject_string = "$TEVC -e $pid/$eid now $link";

# Direct the event to the whoever is handling this particular delay.
$inject_string .= "-${srcvnode} "
    if (defined($srcvnode));

$inject_string .= " modify ";

# Append the parameters.
foreach my $key (keys(%config)) {
    my $val = $config{$key};
    my $str = $agentmap{$key};
    
    $inject_string .= "${str}=$val ";
}
if ($debug) {
    print "$inject_string\n";
}

system($inject_string) &&
    die("*** $0:\n".
	"    Failed to inject delay update event!\n");
    
exit(0);

#
# Get current delay configuration. 
# 
sub ChangeDelayConfig() {
    my $query_clause;
    my $query_string;

    $query_string = "select * from delays ".
	"where pid='$pid' and eid='$eid' and vname='$link' ";

    $query_string .= "and (vnode0='$srcvnode' or vnode1='$srcvnode')"
	if (defined($srcvnode));

    #
    # Okay, see if there is a delay node.
    # 
    my $query_result = DBQueryFatal($query_string);
    if (! $query_result->numrows) {
	return -1;
    }
    
    if (defined($srcvnode) && $islink) {
	#
	# If given a source node of a duplex link, must map that into
	# the actual delay pipe side and the pipe number, since the
	# names of the slots in the DB table have a 0/1 appended. Big
	# Yuck.
	#
	if ($query_result->numrows != 1) {
	    die("*** $0:\n".
		"    Too many delay links for $link in $pid/$eid!\n");
	}
	my %row = $query_result->fetchhash();

	if ($row{'vnode0'} eq $srcvnode) {
	    $pipe   = 0;
	}
	else {
	    $pipe   = 1;
	}
	$pipeno = $row{"pipe${pipe}"};
	
	foreach my $key (keys(%config)) {
	    my $val = $config{$key};

	    $query_clause .= ", "
		if (defined($query_clause));
		
	    if ($key =~ /^q_(.*)/) {
		$query_clause .= "q${pipe}_${1}=$val";
	    }
	    else {
		$query_clause .= "${key}${pipe}=$val";
	    }
	}
    }
    else {
	#
	# We are changing a link or entire lan symmetrically, or we are
	# changing one node in a lan symmetrically. Note, we cannot yet
	# make an asymmetric change to an indvidual lan node. Sorry, too
	# much pain. 
	#
	foreach my $key (keys(%config)) {
	    my $val = $config{$key};

	    $query_clause .= ", "
		if (defined($query_clause));
		
	    if ($key =~ /^q_(.*)/) {
		$query_clause .= "q0_${1}=$val,q1_${1}=$val";
	    }
	    else {
		$query_clause .= "${key}0=$val,${key}1=$val";
	    }
	}
    }
    
    #
    # Update the delays table.
    #
    $query_string =
	"update delays set $query_clause ".
	"where pid='$pid' and eid='$eid' and vname='$link' ";
    
    if (defined($srcvnode)) {
	$query_string .= "and (vnode0='$srcvnode' or vnode1='$srcvnode')";
    }
    if ($debug) {
	print "$query_string\n";
    }
    DBQueryFatal($query_string);
    return 0;
}    

#
# Change linkdelays.
# 
sub ChangeLinkDelayConfig() {
    my @query_clauses;
    my $query_string;

    $query_string = "select * from linkdelays ".
	"where pid='$pid' and eid='$eid' and vlan='$link' ";

    $query_string .= "and vnode='$srcvnode'"
	if (defined($srcvnode));

    #
    # Okay, see if there is a linkdelay.
    # 
    my $query_result = DBQueryFatal($query_string);
    if (! $query_result->numrows) {
	return -1;
    }

    #
    # This is much easier than delay nodes! As above, we cannot change a
    # lan node asymmetrically yet.
    #
    foreach my $key (keys(%config)) {
	my $val = $config{$key};

	push(@query_clauses, "${key}=$val");
	
	#
	# For a lan node, must also set the "r" params.
	# 
	if (!$islink &&
	    ($key eq "delay" ||
	     $key eq "bandwidth" ||
	     $key eq "lossrate")) {

	    push(@query_clauses, "r${key}=$val");
	}
    }
    
    #
    # Update the delays table.
    #
    $query_string = "update linkdelays set ".
	join(",", @query_clauses) . 
	" where pid='$pid' and eid='$eid' and vlan='$link' ";
    
    if (defined($srcvnode)) {
	$query_string .= "and vnode='$srcvnode'";
    }
    if ($debug) {
	print "$query_string\n";
    }
    DBQueryFatal($query_string);
    return 0;
}

#
# Change the virt_lans entry.
#
sub ChangeVirtLans() {
    my @query_clauses;
    my $query_string;
    my @query_clauses2;
    
    #
    # When changing an entire link or lan symmetrically its easy; they can
    # be done the same. When changing one node in a lan (symmetrically),
    # the numbers are slightly different for delay/lossrate, but otherwise
    # its the same operation, except for operating on a single node.
    #
    if (!defined($srcvnode) || !$islink) {
	foreach my $key (keys(%config)) {
	    my $val = $config{$key};

	    if ($key eq "delay") {
		my $delay = $val;

		# This follows what is done in the parser.
		$delay = $delay / 2.0
		    if ($islink);

		push(@query_clauses, "delay=$delay");
		push(@query_clauses, "rdelay=$delay");
	    }
	    elsif ($key eq "lossrate") {
		my $lossrate = $val;

		# This follows what is done in the parser.
		$lossrate = 1-sqrt(1-$lossrate)
		    if ($islink);

		push(@query_clauses, "lossrate=$lossrate");
		push(@query_clauses, "rlossrate=$lossrate");
	    }
	    elsif ($key eq "bandwidth") {
		push(@query_clauses, "bandwidth=$val");
		push(@query_clauses, "rbandwidth=$val");
	    }
	    else {
		push(@query_clauses, "$key=$val");
	    }
	}

	$query_string = "update virt_lans set ".
	    join(",", @query_clauses) .
	    " where pid='$pid' and eid='$eid' and vname='$link'";

	#
	# A lan node change since it cannot be a link if srcvnode defined.
	# 
	if (defined($srcvnode)) {
	    $query_string .= " and member like '${srcvnode}:%'";
	}

	if ($debug) {
	    print "$query_string\n";
	}
	DBQueryFatal($query_string);
    }
    else {
	#
	# Here we change a duplex link asymmetrically. In a duplex link
	# the delay/bw/plr params are split between the two virt_lan
	# members using the "r" params to hold the "from switch" half of
	# the value. This makes it rather confusing. 
	# 
	foreach my $key (keys(%config)) {
	    my $val = $config{$key};

	    if ($key eq "delay") {
		my $delay = $val / 2.0;

		push(@query_clauses,  "delay=$delay");
		push(@query_clauses2, "rdelay=$delay");
	    }
	    elsif ($key eq "lossrate") {
		my $lossrate = 1-sqrt(1-$val);

		push(@query_clauses, "lossrate=$lossrate");
		push(@query_clauses2, "rlossrate=$lossrate");
	    }
	    elsif ($key eq "bandwidth") {
		push(@query_clauses, "bandwidth=$val");
		push(@query_clauses2, "rbandwidth=$val");
	    }
	    else {
		push(@query_clauses, "$key=$val");
	    }
	}
	$query_string = "update virt_lans set ".
	    join(",", @query_clauses) .
	    " where pid='$pid' and eid='$eid' and ".
	    "      vname='$link' and member like '${srcvnode}:%'";
	
	if ($debug) {
	    print "$query_string\n";
	}
	DBQueryFatal($query_string);

	$query_string = "update virt_lans set ".
	    join(",", @query_clauses2) .
	    " where pid='$pid' and eid='$eid' and ".
	    "      vname='$link' and member not like '${srcvnode}:%'";
	
	if ($debug) {
	    print "$query_string\n";
	}
	DBQueryFatal($query_string);
    }
}
