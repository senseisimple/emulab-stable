#!/usr/bin/perl -wT
#
# EMULAB-COPYRIGHT
# Copyright (c) 2000-2007 University of Utah and the Flux Group.
# All rights reserved.
#
use English;
use Getopt::Std;

#
# Parse ssh public keys and enter into the DB. The default format is
# openssh, but if the key is not in that format, then use ssh-keygen
# to see if it can be converted from either SSH2 or SECSH format into
# openssh format. This gets called from the webpage to parse keys
# uploaded by users.
#
sub usage()
{
    print "Usage: addpubkeys [-k | -f] [-n | -u <user>] [<keyfile> | <key>]\n";
    print "       addpubkeys [-i [-r] | -w] <user>\n";
    print "Options:\n";
    print " -k      Indicates that key was passed in on the command line\n";
    print " -f      Indicates that key was passed in as a filename\n";
    print " -n      Verify key format only; do not enter into into DB\n";
    print " -w      Generate new authkeys (protocol 1 and 2) file for user\n";
    print " -i      Initialize mode; generate initial key for user\n";
    print " -r      Force a regenerate of initial key for user\n";
    exit(-1);
}
my $optlist   = "kniwfu:r";
my $iskey     = 0;
my $verify    = 0;
my $initmode  = 0;
my $force     = 0;
my $genmode   = 0;
my $nobody    = 0;
my $noemail   = 0;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBAUDIT     = "@TBAUDITEMAIL@";
my $OURDOMAIN   = "@OURDOMAIN@";
my $KEYGEN	= "/usr/bin/ssh-keygen";
my $USERUID;

# Locals
my $user;
my $this_user;
my $target_user;
my $keyfile;
my $keyline;
my $key;
my $comment;
my $user_name;
my $user_email;
my $user_dbid;
my $user_uid;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libaudit;
use libdb;
use libtestbed;

#
# Function prototypes
#
sub ParseKey($);
sub InitUser();
sub GenerateKeyFile();
sub fatal($);

my $HOMEDIR = USERROOT();

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

#
# Please do not run it as root. Hard to track what has happened.
# 
if ($UID == 0) {
    die("*** $0:\n".
	"    Please do not run this as root!\n");
}

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
%options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"k"})) {
    $iskey = 1;
}
if (defined($options{"f"})) {
    $iskey = 0;
}
if (defined($options{"n"})) {
    $verify = 1;
}
if (defined($options{"i"})) {
    $initmode = 1;
}
if (defined($options{"r"})) {
    $force = 1;
}
if (defined($options{"w"})) {
    $genmode = 1;
}
if (defined($options{"u"})) {
    $user = $options{"u"};
}
if ($verify && $genmode) {
    usage();
}
if ($initmode || $genmode) {
    usage()
	if (@ARGV != 1);

    $user = $ARGV[0];
}
else {
    usage()
	if (@ARGV != 1);
    usage()
	if (!$verify && !defined($user));
    
    $keyfile = $ARGV[0];
}

#
# Untaint the arguments.
#
if (defined($user)) {
    if ($user =~ /^([-\w]+)$/i) {
	$user = $1;
    }
    else {
	fatal("Tainted username: $user");
    }
    # Map user to object.
    $target_user = User->Lookup($user);
    if (! defined($target_user)) {
	fatal("$user does not exist!")
    }

    $user_name  = $target_user->name();
    $user_email = $target_user->email();
    $user_dbid  = $target_user->dbid();
    $user_uid   = $target_user->uid();
}

#
# If invoked as "nobody" its for a user with no actual account.
# 
if (getpwuid($UID) eq "nobody") {
    if ($initmode || $genmode) {
	fatal("Bad usage as 'nobody'");
    }
    $nobody = 1;
}
else {
    $USERUID = getpwnam($user);

    # Map invoking user to object.
    $this_user = User->LookupByUnixId($UID);

    if (! defined($this_user)) {
	fatal("You ($UID) do not exist!");
    }
}

#
# Initmode or genmode, do it and exit.
#
if ($initmode) {
    # Drop root privs, switch to target user.
    $EUID = $USERUID;
    exit InitUser();
}
if ($genmode) {
    # Drop root privs, switch to target user.
    $EUID = $USERUID;
    exit GenerateKeyFile();
}

# Else, key parse mode ...
if ($iskey) {
    if ($keyfile =~ /^([-\w\s\.\@\+\/\=]*)$/) {
	$keyfile = $1;
    }
    else {
	fatal("Tainted key: $keyfile");
    }
    $keyline = $keyfile;
}
else {
    if ($keyfile =~ /^([-\w\.\/]+)$/) {
	$keyfile = $1;
     }
    else {
	fatal("Tainted filename: $keyfile");
    }
    if (! -e $keyfile) {
	fatal("No such file: $keyfile\n");
    }
    $keyline = `head -1 $keyfile`;
}

#
# Check user
#
if (!$verify) {
    # If its the user himself, then we can generate a new authkeys file. 
    if (!$nobody && !TBAdmin() && !$target_user->SameUser($this_user)) {
	fatal("You are not allowed to set pubkeys for $target_user\n");
    }
    if (-d "$HOMEDIR/$user_uid/.ssh") {
	$genmode = 1;
    }
    
    #
    # This script is audited when not in verify mode. Since all keys are first
    # checked with verify mode, this should not cause any extra email from bad
    # keys.
    #
    AuditStart(0);
}

# Drop root privs, switching to user.
if (!$nobody) {
    $EUID = $USERUID;
}

#
# Grab the first line of the file. Parse it to see if its in the
# format we like (openssh), either protocol 1 or 2.
#
if (ParseKey($keyline)) {
    exit 0;
}
# If the key was entered on the command line, then nothing more to do.
if ($iskey) {
    exit 1;
}

#
# Run ssh-keygen over it and see if it can convert it. 
#
if (! open(KEYGEN, "ssh-keygen -i -f $keyfile 2>/dev/null |")) {
    fatal("*** $0:\n".
	  "    Could not start ssh-keygen\n");
}
$keyline = <KEYGEN>;
if (close(KEYGEN) && ParseKey($keyline)) {
    exit 0;
}
exit 1;

sub ParseKey($) {
    my ($keyline) = @_;

    # Enforce a reasonable length on the key.
    if (length($keyline) > 4096) {
	print "Key is too long!\n";
	print "Key: $keyline\n";
	return 0;
    }
    
    if ($keyline =~ /^(\d*\s\d*\s[0-9a-zA-Z]*) ([-\w\@\.\ ]*)\s*$/) {
        # Protocol 1
	$type    = "ssh-rsa1";
	$key     = $1;
	$comment = $2;
    }
    elsif ($keyline =~ /^(\d*\s\d*\s[0-9a-zA-Z]*)\s*$/) {
        # Protocol 1 but no comment field.
	$type    = "ssh-rsa1";
	$key     = $1;
    }
    elsif ($keyline =~
	   /^(ssh-rsa|ssh-dss) ([-\w\.\@\+\/\=]*) ([-\w\@\.\ ]*)$/) {
        # Protocol 2
	$type    = $1;
	$key     = "$1 $2";
	$comment = $3;
    }
    elsif ($keyline =~ /^(ssh-rsa|ssh-dss) ([-\w\.\@\+\/\=]*)$/) {
        # Protocol 2 but no comment field
	$type    = $1;
	$key     = "$1 $2";
    }

    if (!defined($key)) {
	print "Key cannot be parsed!\n";
	print "Key: $keyline\n";
	return 0;
    }

    # Do not enter into DB if in verify mode.
    if ($verify) {
	print "Key was good: $type\n";
	return 1;
    }

    #
    # Make up a comment field for the DB. 
    #
    if (!defined($comment)) {
	$comment = "$type-${user_email}";
    }
    $key = "$key $comment";

    DBQueryFatal("replace into user_pubkeys ".
		 "values ('$user_uid', '$user_dbid', ".
		 "        0, '$key', now(), '$comment')");

    #
    # Mark user record as modified so nodes are updated.
    #
    TBNodeUpdateAccountsByUID($user_uid);

    my $chunked = "";

    while (length($key)) {
	$chunked .= substr($key, 0, 65, "");
	if (length($key)) {
	    $chunked .= "\n";
	}
    }
    print "SSH Public Key for '$user' added:\n";
    print "$chunked\n";
    
    # Generate new auth keys file. 
    if ($genmode) {
	GenerateKeyFile();
    }

    if (! $noemail) {
	SENDMAIL("$user_name <$user_email>",
		 "SSH Public Key for '$user_uid' Added",
		 "SSH Public Key for '$user_uid' added:\n".
		 "\n".
		 "$chunked\n",
		 "$TBOPS");
    }
    return 1;
}

#
# Init function for new users. Generate the first key for the user (which
# is loaded into the DB), and then generate the keyfiles. Note that the
# user might have preloaded personal keys.
#
sub InitUser()
{
    my $sshdir  = "$HOMEDIR/$user_uid/.ssh";

    #
    # Set up the ssh key, but only if not done so already.
    #
    if (! -e "$sshdir") {
	mkdir("$sshdir", 0700) or
	    fatal("Could not mkdir $sshdir: $!");
    }
    if (! -e "$sshdir/identity" || $force) {
	print "Creating ssh protocol 1 key for $user.\n";

	#
	# Want to delete existing key from DB.
	#
	if (-e "$sshdir/identity") {
	    my $ident = `cat $sshdir/identity.pub`;

	    if ($ident =~ /(\d*\s\d*\s[0-9a-zA-Z]*)\s([-\w\@\.]*)/) {
		DBQueryFatal("delete from user_pubkeys ".
			     "where uid_idx='$user_dbid' and pubkey='$1 $2'");
	    }
	    unlink("$sshdir/identity");
	}

	# Hmm, need to use -C option so comment field makes sense.
    
	if (system("$KEYGEN -t rsa1 -P '' ".
		   "-C '${user}" . "\@" . ${OURDOMAIN} . "' ".
		   "-f $sshdir/identity")) {
	    fatal("Failure in ssh-keygen!");
	}

	#
	# Grab a copy for the DB.
	# 
	my $ident = `cat $sshdir/identity.pub`;

	if ($ident =~ /(\d*\s\d*\s[0-9a-zA-Z]*)\s([-\w\@\.]*)/) {
	    DBQueryFatal("replace into user_pubkeys ".
			 "values ('$user_uid', '$user_dbid', ".
			 "        0, '$1 $2', now(), '$2')");
	}
	else {
	    fatal("Bad protocol 1 public key: $ident\n");
	}
    }
    #
    # Moving to V2 keys ...
    #
    if (! -e "$sshdir/id_rsa" || $force) {
	print "Creating ssh protocol 2 key for $user.\n";

	#
	# Want to delete existing key from DB.
	#
	if (-e "$sshdir/id_rsa") {
	    my $ident = `cat $sshdir/id_rsa.pub`;

	    if ($ident =~
		/^(ssh-rsa [-\w\.\@\+\/\=]*) ([-\w\@\.\ ]*)$/) {
		DBQueryFatal("delete from user_pubkeys ".
			     "where uid_idx='$user_dbid' and pubkey='$1 $2'");
	    }
	    unlink("$sshdir/id_rsa");
	}

	# Hmm, need to use -C option so comment field makes sense.
    
	if (system("$KEYGEN -t rsa -P '' ".
		   "-C '${user}" . "\@" . ${OURDOMAIN} . "' ".
		   "-f $sshdir/id_rsa")) {
	    fatal("Failure in ssh-keygen!");
	}

	#
	# Grab a copy for the DB.
	# 
	my $ident = `cat $sshdir/id_rsa.pub`;

	if ($ident =~
	    /^(ssh-rsa [-\w\.\@\+\/\=]*) ([-\w\@\.\ ]*)$/) {
	    DBQueryFatal("replace into user_pubkeys ".
			 "values ('$user_uid', '$user_dbid', ".
			 "        0, '$1 $2', now(), '$2')");
	}
	else {
	    fatal("Bad protocol 2 public key: $ident\n");
	}
    }
    return GenerateKeyFile();
}

#
# Generate ssh authorized_keys files. Either protocol 1 or 2.
# Returns 0 on success, -1 on failure.
#
sub GenerateKeyFile()
{
    my @pkeys   = ();
    my $sshdir  = "$HOMEDIR/$user_uid/.ssh";
    my $keyfile = "$sshdir/authorized_keys";
	
    if (! -e $sshdir) {
	if (! mkdir($sshdir, 0700)) {
	    warn("*** WARNING: Could not mkdir $sshdir: $!\n");
	    return -1;
	}
    }
    my $query_result =
	DBQueryFatal("select pubkey from user_pubkeys ".
		     "where uid_idx='$user_dbid'");

    while (my ($key) = $query_result->fetchrow_array()) {
	push(@pkeys, $key);
    }
    
    print "Generating $keyfile ...\n";

    if (!open(AUTHKEYS, "> ${keyfile}.new")) {
	warn("*** WARNING: Could not open ${keyfile}.new: $!\n");
	return -1;
    }
    print AUTHKEYS "#\n";
    print AUTHKEYS "# DO NOT EDIT! This file auto generated by ".
	"Emulab.Net account software.\n";
    print AUTHKEYS "#\n";
    print AUTHKEYS "# Please use the web interface to edit your ".
	"public key list.\n";
    print AUTHKEYS "#\n";
    
    foreach my $key (@pkeys) {
	print AUTHKEYS "$key\n";
    }
    close(AUTHKEYS);

    if (!chmod(0600, "${keyfile}.new")) {
	warn("*** WARNING: Could not chmod ${keyfile}.new: $!\n");
	return -1;
    }
    if (-e "${keyfile}") {
	if (system("cp -p -f ${keyfile} ${keyfile}.old")) {
	    warn("*** Could not save off ${keyfile}: $!\n");
	    return -1;
	}
	if (!chmod(0600, "${keyfile}.old")) {
	    warn("*** Could not chmod ${keyfile}.old: $!\n");
	}
    }
    if (system("mv -f ${keyfile}.new ${keyfile}")) {
	warn("*** Could not mv ${keyfile} to ${keyfile}.new: $!\n");
    }
    elsif (-e "$sshdir/authorized_keys2") {
	#
	# Save to remove deprecated authorized_keys2 file at this point.
	#
	unlink("$sshdir/authorized_keys2");
    }
    return 0;
}

sub fatal($) {
    my($mesg) = $_[0];

    die("*** $0:\n".
	"    $mesg\n");
}
